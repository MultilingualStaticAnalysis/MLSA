#!/usr/bin/env python
# MLSA Multilingual Software Analysis
# This program is part of the MLSA package under development at Fordham University Department of Computer and Information Science.
# cFunCall2.py takes in the text AST file generated by cSA.py using Clang. 
#		The program calls the cFunCall Island Grammar (input of AST) to find all the function calls in the C/C++ program. 
#		The program also finds the scope of the call (if it is found inside another function definition or in the main body of the program),
#		the class of the call (if it is a member function -> if not, class is GLOBAL), and the arguments of the call
# Author: Anne Marie Bogar
# Date: May 9, 2018
# this code can be copied or used and is without warrenty or support, but this header needs to be copied along with the program FU2017
# Input: text file of C/C++ program's AST
# Output: csv file
#		call_id(int),class(string),scope(string),function_name(string),argument1(string),argument2(string)...
# for arguments, all literals are encased in <> (ex: <5>)
# function calls that are arguments of another function call have their id next to () in csv line of the other function call
#               ex: 6,GLOBAL,file.py,function1,function2()4
#				**actually, right now the function is just shown as the ID

import sys
import os
import commands
import json
import csv
from copy import deepcopy

error = 'MLSA: cFunCall; '
# get path of Island Grammar so the program can be called from anywhere
path = "/IG/"
for x in os.environ['PATH'].split(':'):
	if "MLSA/bin" in x:
		path = x+path
		break
#INDICES
LAST_ELEMENT = -1
#Island Grammar Indices
ISLAND_GRAMMAR_CALLS = 1
ISLAND_GRAMMAR_FUNCS = 1
ISLAND_GRAMMAR_STATUS = 0
#Call Indices
CALL_FILE = 0
CALL_ID = 1
CALL_MEM = 2
CALL_SCOPE = 3
CALL_NAME = 4
#Function Indices
FUNC_FILE = 0
FUNC_SCOPE = 1
FUNC_NAME = 2

# calls the IG and collects the function calls printed in a list
def collectCalls(astfile, calls):
	i = commands.getstatusoutput(path+"cFunCall < "+astfile) # returns output of the IG to variable 


	# only accept programs that were successfully parsed by the IG

        syn_error= "syntax error" in i[ISLAND_GRAMMAR_CALLS]
        syn_error= False
	if i[ISLAND_GRAMMAR_STATUS] == 0 and i[ISLAND_GRAMMAR_CALLS] != "" and not syn_error:
 
                c = i[ISLAND_GRAMMAR_CALLS].split('\n')
		for d in c:
			#id,MEMBER/GLOBAL,scope,name,args...
			calls.append(d.split(','))


# only include function calls that were called inside the body of the program
def refineCalls(cfile, calls, fileCalls):
	for c in calls:                
		if len(c) > CALL_SCOPE:
			# change the main program to the name of the C/C++ file (for the call graph)
			if c[CALL_SCOPE] == "main":
				c[CALL_SCOPE] = cfile

	for c in calls:
		# find all the calls inside the body of the program and deep copy them
		# must be deep copy because they are lists
		if cfile in c[CALL_FILE]:
			fileCalls.append(deepcopy(c))
			# the name of the file is only important for this function
			# the name of the file must be removed before writing CSV file for uniformity
			fileCalls[-1].pop(0)
		c.pop(0)

# call the IG for functions (cFuncDecl) and collects the functions
def collectFuncs(astfile, functions):
	i = commands.getstatusoutput(path+"cFuncDecl < "+astfile)

        syn_error1= "syntax error" in i[ISLAND_GRAMMAR_CALLS]
        syn_error1=False  
	if i[ISLAND_GRAMMAR_STATUS] == 0 and i[ISLAND_GRAMMAR_FUNCS] != "" and not syn_error1:
		c = i[ISLAND_GRAMMAR_FUNCS].split('\n')
		for d in c:
			#filename,MEMBER/GLOBAL,functionName
			functions.append(d.split(','))


# only include functions defined in the program
def refineFuncs(cfile, functions, fileFunctions):
	for f in functions:
		add = True
		if cfile in f[FUNC_FILE]:
			#make sure that you are not adding a duplicate (this happens)
			for ff in fileFunctions:
				if (ff[FUNC_FILE] == f[FUNC_FILE]) and (ff[FUNC_SCOPE] == f[FUNC_SCOPE]) and (ff[FUNC_NAME] == f[FUNC_NAME]):
					add = False
			if add:
				fileFunctions.append(deepcopy(f))

# print the function calls to CSV file filename.c[pp]_call.csv
def printCalls(csvfile, fileCalls):
	try:
		with open(csvfile, 'w') as f:
			writer = csv.writer(f)
			writer.writerows(fileCalls)
	except IOError:
		sys.exit(error+"problem writing Function Call csv file")

# print the functions to the CSV file codebaseName_funcs.csv
def printFuncs(funcfile, fileFunctions):
	try:
		with open(funcfile, 'a') as f:
			writer = csv.writer(f)
			writer.writerows(fileFunctions)
	except IOError:
		sys.exit(error+"problem writing Function csv file")

def main(astfile, cfile, csvfile, funcfile):
	calls = []
	functions = []
	fileFunctions = []
	fileCalls = []
	collectFuncs(astfile, functions) # collect function info from cFuncDecl IG
	refineFuncs(cfile, functions, fileFunctions) # only keep functions defined inside program
	collectCalls(astfile, calls) # collect function call info from cFunCall IG
	refineCalls(cfile, calls, fileCalls) # only keep function calls called inside program
	printCalls(csvfile, fileCalls) # print function call info to csv file
	printFuncs(funcfile, fileFunctions) # print function info to csv file

# **use this code for debugging
#if len(sys.argv) < 2:
#    sys.exit(ERROR+"arguments needed")

#main(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4])
