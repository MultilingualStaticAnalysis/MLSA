# MLSA Multilingual Software Analysis
# This program is part of the MLSA package under development at Fordham University Department of Computer and Information Science.
# <This program parses the Abstract Syntax Tree for a C program, and generates the forward and reverse control flow graphs>
# Limitations: The parser ignores everything before the main() functions appear, therefore all functions must be defined AFTER the main
# Author: <Nicholas Estelami and Sunand Raghupathi> 
# Date: <6/13/17>
# This code can be copied or used and is without warrenty or support, but this header needs to be coppied along with the program FU2017
# Input: <the abstract syntax tree (.txt) generated by Clang>
# Output: a CSV in the format: <line number, potential preceding (or following) line numbers>

import csv
import sys 



def Main(inputfile, fileName, fcfgFile, rcfgFile):
	global AST_LINE_COUNT

#--------------FileName Conventions-----------------------#

	AST_LINE_COUNT = 0
	# Read the contents of the abstract syntax tree output produced by Clang.
	# This is generated by typing clang -cc1 -ast-dump file.cpp >> ast.txt
	
	error = "MLSA: CControlFlow "




	try:
		with open(inputfile, "r") as txtFile:
			treeLines = txtFile.readlines()
			txtFile.close()
	except Exception:
		sys.exit(error + "file " + '"' + inputfile + '"' + " not found")


	#Remove path from fileName	
	fileNameTemp = fileName.split('/')[-1]


	treeLines = findSource(treeLines, fileNameTemp)
	#print treeLines
	treeList = []


	# Parse the textual representation of the ast and extract the important lines.
	
	for line in treeLines:

		line = line.replace(".cpp", "<line")
		line = line.replace(".c", "<line")
	


		#if (line.find(" main") != -1):
		#	mainFound = True

		if (line.find("-") != -1 and line.find("line:") != -1) or line.find('NULL') != -1:
			treeList.insert(len(treeList), line)

	
	#DONE1


	astList = []
	lineNum = 0

	while (lineNum < len(treeList) - 1):
		# Parse the root ast node.
		astParent = ParseItemAtLine(treeList, lineNum)

		lineNum = lineNum + 1
		

		astCollection = ParseASTItem(treeList, lineNum, astParent)
	

		# Iterate through the children of our root node.
		lineNum = ProcessChildren(treeList, astParent, astParent.lineIndex) + 1

		astList.insert(len(astList), astParent)



	resultMap = []
	resultMapReverse = []

	NUM_LINES = AST_LINE_COUNT

	#print("NUM_LINES: " + str(NUM_LINES))

    # Generate the CFG and Reverse CFG
	for i in range(NUM_LINES + 1):
		#Here, i represents each line number in the program being processed
		resultMap.insert(len(resultMap), [])
		resultMapReverse.insert(len(resultMapReverse), [])

	for astParent in astList:
		#Iterates to 1 before the last line of code
		temp1 = astParent.lineNum
		temp2 = astParent.lineNumEnd

		for i in range(temp1, temp2):
		
			result = FindItemForLine(i, treeList, astParent)
				
			if (result == None):
				strResult = [i + 1]

			if (result != None):
				if (result.lineNum == -1 or result.lineNumEnd == -1) and (result.typeString == 'IfStmt' or result.typeString == 'CompoundStmt'):
					print error + "missing line number information"			
					print treeList[result.lineIndex]
				#if lineChecker(i, astList):
				strResult = result.GetNextLineNumbers(treeList)



				#else:
				#	strResult = [i + 1]
					
				if (i == result.lineNumEnd):
					if (result.typeString == "WhileStmt"):
						strResult = [ result.lineNum ]
					elif (result.typeString == "CompoundStmt" and result.parent != None):
						strResult = [ result.parent.lineNumEnd+1 ]
					elif (result.typeString == "FunctionDecl"):
						strResult = [] 
					else:
						strResult = [ result.lineNumEnd+1 ]


				if ((result.typeString == "WhileStmt") and len(strResult) > 1):
					#print(str(strResult[1]))
					resultMap[strResult[1]-1] = [strResult[0]-1]



			resultMap[i] = strResult
			for item in strResult:
				if item < len(resultMapReverse):		
					resultMapReverse[item-0].insert(len(resultMapReverse), i)

	
        # Print out the results.
	'''	
	for i in range(1, NUM_LINES+1):
		if (i < len(resultMap)):
			print("Line: " + str(i) + " Destination(s): " + str(resultMap[i]))
			print("R-Line: " + str(i) + " " + str(resultMapReverse[i]))


	print(str(resultMap))
	print(str(resultMapReverse))
	'''


        # Output the reverse cfg to a csv file.
	with open(rcfgFile, 'w') as csvFile:
		csvWriter = csv.writer(csvFile, delimiter=',',
			    quotechar='|', quoting=csv.QUOTE_MINIMAL)

		for i in range(1, len(resultMapReverse)):
			items = []
			items.insert(len(items), i);
		
			for line in resultMapReverse[i]:
				items.insert(len(items), line)
			csvWriter.writerow(items)

	with open(fcfgFile, 'w') as csvFile:
		csvWriter = csv.writer(csvFile, delimiter=',',
			    quotechar='|', quoting=csv.QUOTE_MINIMAL)

		for i in range(1, len(resultMap)):
			items = []
			items.insert(len(items), i);
		
			for line in resultMap[i]:
				items.insert(len(items), line)
			csvWriter.writerow(items)

#################Testing function

def findSource(treeLines, inputfile):

	treeList = []

	#Strip _ast.txt
	fileName = inputfile


	fileFound = False
	
	for line in treeLines:
		if line.find('<') != -1 and line.find('>') != -1 and (line.find('.c') != -1 or line.find('.cpp') != -1 or line.find('.h') != -1):
			tempLine = line.split()
			for index in tempLine:
				if index.find('<') != -1 and (index.find('.c') != -1 or index.find('.cpp') != -1 or index.find('.h') != -1):

					index = colonRemoverBefore(index)
					index = backslashRemoverAfter(index)
					index = index.strip('<')
					if index == fileName:
						fileFound = True
					else:
						fileFound = False
		
		if fileFound:
			treeList.append(line)

	return treeList


def backslashRemoverAfter(text):
	count = 0
	index = 0
	for i in text:
		count = count + 1
		if i == '/':
			index = count

	return text[index:]

#Returns the part of the string BEFORE the colon
def colonRemoverBefore(text):
	colonCount = 0
	for index in text:
		colonCount = colonCount + 1
		if (index == ':'):
			break
	text = text[:colonCount - 1]
	return text


##########################








#Fills in information for children of children (of parent)
def ProcessChildren(treeList, astParent, currentLine):
	for child in astParent.children:
		if (child.lineIndex + 1 < len(treeList)):
			child = ParseASTItem(treeList, child.lineIndex + 1, child)[0]
			
			currentLine = ProcessChildren(treeList, child, currentLine)

			if (child.lineIndex > currentLine):
				currentLine = child.lineIndex

	return currentLine


#Given a line number, returns the corresponding node (or None)
def FindItemForLine(lineNum, treeList, astParent):
	
	#temp = None

	if astParent.lineNum == lineNum or astParent.lineNumEnd == lineNum:
		return astParent

	
	if (astParent.possibleElseStmt == True and lineNum == astParent.lineNum - 1):
		return astParent
	
	for child in astParent.children:
		result = FindItemForLine(lineNum, treeList, child)
		if result != None:
			return result
	
	return None

def GetChildCountOfType(astItem, childType):
	childCount = 0

	for child in astItem.children:
		if (child.typeString == childType):
			childCount = childCount + 1

	return childCount

#Fills information for children of parent (but not children of children)
def ParseASTItem(treeLines, index, astParent):
	line = treeLines[index]

	while index < len(treeLines):
		astItem = ParseItemAtLine(treeLines, index)

		if (astParent.treeLevel >= astItem.treeLevel):
			break

		#if ((astParent.treeLevel + 2 == astItem.treeLevel) or (astParent.treeLevel + 1 == astItem.treeLevel)):
		if (astParent.treeLevel + 2 == astItem.treeLevel):

			#if (astParent.typeString == "WhileStmt"):
			#	yes = 1;

			astParent.children.insert(len(astParent.children), astItem)
			astItem.parent = astParent

			line = treeLines[index]

			if (astItem.typeString == "CompoundStmt" and line.find("`") != -1 and ((astItem.parent != None and (astParent.typeString != "WhileStmt" and astParent.typeString != "FunctionDecl")))):
				astItem.possibleElseStmt = True
			else:
				astItem.possibleElseStmt = False

			if (astItem.lineNum == -1):
				astItem.lineNum = astItem.parent.lineNum
			
		index = index + 1

	return astParent, index

#Fills information for the node at the passed index
def ParseItemAtLine(treeLines, index):
	global AST_LINE_COUNT

	line = treeLines[index]

	#line = line.replace("testline", "line")

	astItem = ASTEntry()

	temp1 = ""
	temp2 = ""


	#Here, we are extracting information from a line in the AST to get the type of string (if, while, compound, etc..)
	#An example of what this line should look like is: 
	#`-IfStmt 0x7fe02d076c00 <line:3:2, line:7:2>
	if line.find('NULL') != -1:
		astItem.typeString == 'NULL'

	else:
		if line.find("0x") != -1:
			temp1 = line.split("0x")
			if "-" in temp1[0]:
				temp2 = temp1[0].split("-")
			else:
				print error + 'String does not match expected input.'
		else:
			print error + 'String does not match expected input.'


		astItem.typeString = temp2[1].replace(" ", "")

	#astItem.typeString = line.split("0x")[0].split("-")[1].replace(" ", "")


	if (line.find("<line:") != -1):
		astItem.lineNum = int(line.split("line:")[1].split(":")[0])
	else:
		astItem.lineNum = -1

	astItem.lineNumEnd = -1
	astItem.possibleElseStmt = False
	
	if (astItem.typeString == "IfStmt" or astItem.typeString == "WhileStmt" or astItem.typeString == "FunctionDecl"
	or astItem.typeString == "CompoundStmt"):
		if (line.find(", line:") != -1):
			astItem.lineNumEnd = int(line.split(", line:")[1].split(":")[0])
	
	if (astItem.typeString == "CompoundStmt" and line.find("`") != -1 and ((astItem.parent != None and astItem.typeString != "WhileStmt"))):
		astItem.possibleElseStmt = True
		#It is also possible that this is NOT an else statement.

	if (astItem.typeString == "FunctionDecl"):
		astItem.lineNum = int(line.split(":")[1].split(":")[0])
		if (astItem.lineNumEnd > AST_LINE_COUNT):
			AST_LINE_COUNT = astItem.lineNumEnd
	
	
	astItem.treeLevel = GetTreeLevel(line)
	astItem.lineIndex = index

	return astItem

def StringFind(text, items):
	
	for item in items:
		if (text.find(item) != -1):
			return True;

	return False;

def GetTreeLevel(text):
	spaceCount = 0

	for character in text:
		if (character == '-'):
			break;
		else:
			spaceCount = spaceCount + 1


		#if character == ' ':
		#	spaceCount = spaceCount + 1
		#elif character == '|':
		#	spaceCount = spaceCount - 1
		#elif character == "`":
		#	spaceCount = spaceCount - 1
		#elif character == '-':
		#	spaceCount = spaceCount + 1
		#	break

	return spaceCount

#Fixing Nick's Code:
def lineChecker(lineNum, astList):
	"""Checks to see if line number being passed appears in the AST (represented as astList)."""
	check = False
	for i in astList:
		if i != None:
			if lineNum == i.lineNum or lineNum == i.lineNumEnd:
				return True
			else:

				check = lineChecker(lineNum, i.children)

	return check
				

class ASTEntry(object):
	def __init__(self):
		self.typeString = ""
		self.lineNum = -1
		self.lineNumEnd = -1
		self.treeLevel = -1
		self.lineIndex = -1
		self.children = []
		self.parent = None
		self.ifCompound = False
		
	def GetNextLineNumbers(self, treeList):
		result = []

		if (self.typeString == "IfStmt" or self.typeString == "WhileStmt" or self.typeString == "CompoundStmt"):

			hasCompoundStatements = False
			hasElseStatements = False
			hasElseCompounds = False

			if self.typeString == "IfStmt":

				if treeList[self.children[-1].lineIndex].find("NULL") == -1:
					result.insert(len(result), self.children[-1].lineNum)
					hasElseStatements = True
					result.insert(len(result), self.lineNum + 1)
					#
				numCompounds = GetChildCountOfType(self, "CompoundStmt")
				if numCompounds == 0:
					self.ifCompound = False
				elif numCompounds == 1 and self.children[-1].typeString == "CompoundStmt":
					self.ifCompound = False
				else:
					self.ifCompound = True






			for child in self.children:

				if (child.typeString == "CompoundStmt"):


					if (child.possibleElseStmt == True):
						result.insert(len(result), child.lineNum)


						hasElseStatements = True
					else:
						
						if child.lineNum == self.lineNum:
							result.insert(len(result), child.lineNum + 1)


						else:

							result.insert(len(result), child.lineNum)


					hasCompoundStatements = True



				
			#	p = 0;


			if (hasCompoundStatements == False):
				result.insert(len(result), self.lineNum+1)
				#Testing
				if self.typeString == "IfStmt" and hasElseStatements == False:
					result.insert(len(result), self.lineNumEnd+1)
			else:
				if (self.typeString == "IfStmt"):

					if (hasElseStatements == False):
						result.insert(len(result), self.lineNumEnd+1)



				elif (self.typeString == "WhileStmt"):
					result.insert(len(result), self.lineNumEnd+1);
					

			#Debugging
			'''if (self.typeString == "CompoundStmt"):
				if (self.parent != None):
					print(self.parent.typeString)
			'''
					#if (self.parent.typeString == "IfStmt" or self.parent.typeString == "WhileStmt"):
						#if (self.lineNumEnd != -1):
							#result.insert(len(result), self.lineNumEnd)
			#elif (self.typeString == "WhileStmt" or (self.typeString == "IfStmt" and hasCompoundStatements == False)):
				#result.insert(len(result), self.lineNumEnd+1)

		elif (self.typeString == "UnaryOperator" or self.typeString == "CompoundStmt" or self.typeString == "BinaryOperator"):
			if self.parent.typeString == "IfStmt":
				if self.parent.ifCompound == False:
			
					result.insert(len(result), self.parent.lineNumEnd + 1)

				else:
					
					result.insert(len(result), self.lineNum + 1)
			else:
				#Looks for last statement in an if compound
				if self.parent != None and self == self.parent.children[-1] and self.parent.typeString == "CompoundStmt" and self.parent.parent != None and self.parent.parent.typeString == "IfStmt":
					result.insert(len(result), self.parent.parent.lineNumEnd + 1)
				else:		
					result.insert(len(result), self.lineNum + 1)
				

		else:
			if (self.typeString != "FunctionDecl" or (self.typeString == "FunctionDecl" and len(self.children) > 0)):
				if self.parent != None and self.parent.typeString == "IfStmt":
					if self.parent.ifCompound == False:
						result.insert(len(result), self.parent.lineNumEnd + 1)
				else:
					if self.parent != None and self == self.parent.children[-1] and self.parent.typeString == "CompoundStmt" and self.parent.parent.typeString == "IfStmt":
						result.insert(len(result), self.parent.parent.lineNumEnd + 1)
					else:		
						result.insert(len(result), self.lineNum + 1)

		return list(set(result))

class Line(object):
	def __init__(self):
		self.line = -1;
		self.destLines = []

#Main("2test.c_ast.txt", '2test.c', '2test.c_fcfg.csv', '2test.c_rcfg.csv')

