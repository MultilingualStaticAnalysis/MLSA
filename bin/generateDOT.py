# MLSA Multilingual Software Analysis
# This program is part of the MLSA package under development at Fordham University Department of Computer and Information Science.
# generateDOT.py takes in the csv file generated by mergeFunCall. The program creates a tree structure to visualize the csv file from mergeFunCall, and then writes to a dot file that then generates a pdf of the tree through GraphViz
# Author: Anne Marie Bogar
# Date: June 29, 2017
# this code can be copied or used and is without warrenty or support, but this header needs to be copied along with the program FU2017
# Input: csv file
#		program_name(string),program_type(int),program_of_function_def(string),call_id(int),class(string),scope(string),function_name(string),argument1(string),argument2(string)...
# Output: dot file
#		Node0x859365863 [shape=rectangle, label="file1.py"];
#	        Node0x120389922 [shape=rectangle, label="0. (file2.py) \n function(arg)"];
#	        Node0x859365863 -> Node0x120389922;
# for arguments, all literals are encased in <> (ex: <5>)
# function calls that are arguments of another function call have their id next to () in csv line of the other function call
#               ex: function1(function2()4, arg)

import random
import os
import csv
import sys

#global variables
IDlist = {} #all the unique Node IDS
system = [] #all the programs in the system being analyzed
functions = [] #all the functions in the system
functionCalls = []
dot = ''
ERROR = 'MLSA: generateDOT; '
#CSV file from mergeFunCall
CSV_MAIN_PROGRAM_FIELD = 0
CSV_PROGRAM_TYPE_FIELD = 1
CSV_PROGRAM_FIELD = 2
CSV_ID_FIELD = 3
CSV_CLASS_FIELD = 4
CSV_SCOPE_FIELD = 5
CSV_CALL_FIELD = 6
CSV_ARG_FIELD = 7
#Program class member variable self.csv
PROGRAM_CSV_PROGRAM_FIELD = 0
PROGRAM_CSV_CLASS_FIELD = 1
PROGRAM_CSV_SCOPE_FIELD = 2
PROGRAM_CSV_CALL_FIELD = 3
PROGRAM_CSV_ID_FIELD = 4
#Function class member variable self.calls
CALL_NAME_FIELD = 0
CALL_SCOPE_FIELD = 1
CALL_CLASS_FIELD = 2
CALL_ID_FIELD = 3
#Call class member variable self.callHistory
HISTORY_NAME_FIELD = 0
HISTORY_PROGRAM_FIELD = 1

#dictionaries -> change if adding another language
#example of how to change if adding java: typeDict = {'c':'1', 'cpp':'1', 'py':'2', 'js':'3', 'java':'4'}
typeDict = {'py': '2', 'js': '3', 'c': '1', 'cpp': '1'}
shapeDict = {'1':'oval', '2':'rectangle', '3':'hexagon'}
#example of how to change if adding java: progCallDict = {'1':['py()', 'js()', 'java()'], '2':['js()', 'c()', 'cpp()', 'java()'], '3':['py()', 'c()', 'cpp()', 'java()'], '4':['c()', 'cpp()', 'py()', 'js()']}
progCallDict = {'1':['py()', 'js()'], '2':['js()', 'c()', 'cpp()'], '3':['py()', 'c()', 'cpp()']}
errorDict = {'Python':'2', 'JavaScript':'3', 'C/C++':'1'}

#---------------------------Function Class------------------------------#

#Function is a function called in the main body of a program
class Function:
    def __init__(self, name, program, className):
        self.name = name
        self.program = program
        self.className = className
        self.calls = [] #all of the calls in a function definition

    def addFuncCall(self, name, program, className, callID):
        self.calls.append([name, program, className, callID])

#------------------------------------------------------------------------#

#------------------------------Call Class--------------------------------#

class Call:
    def __init__(self, name, ID, program, className, pType, parentName, parentID, callID, ind=False):
        #for print Flow and Node
        self.name = name
        self.ID = ID
        self.parentName = parentName
        self.parentID = parentID
        self.callID = callID
        #for finding the matching Function in the functions list
        self.program = program
        self.className = className
        #for determining shape
        self.pType = pType
        #for determing if the call is recursive or circular
        self.callHistory = []
        self.progHistory = [program]
        self.circular = False
        self.recursive = False
        #for adding Calls to the functionCalls list
        self.used = False
        #if the call is a main function (not called by any other function) -> first to be printed
        self.independent = ind

    def setUsed(self, used):
        self.used = used

    def setHistory(self, history, parentProg=''):
        if self.independent == False: #if true, there is no history because no function calls this function
            self.callHistory.append([self.parentName, parentProg])
            for h in history:
                self.callHistory.append(h)
            self.setRecursive()

    def setProgHistory(self, history):
        if self.progHistory != history:
            self.progHistory = history+self.progHistory
        self.setCircular()

    def setRecursive(self):
        global HISTORY_NAME_FIELD, HISTORY_PROGRAM_FIELD
        if not self.circular: #programs can only be circular, not recursive
            for h in self.callHistory:
                if h[HISTORY_NAME_FIELD].split('(')[0] == self.name.split('(')[0] and h[HISTORY_PROGRAM_FIELD] == self.program: #same function
                    self.recursive = True

    def setCircular(self):
        count = 0
        for h in self.progHistory:
            if h == self.program:
                count += 1
        if count > 1: #if there is more than one of the current program, the program is being called again -> circular
            self.circular = True

#------------------------------------------------------------------------#

#---------------------------Program Class--------------------------------#

#Program is a program in the system
class Program:
    def __init__(self, t, name):
        self.name = name
        self.hasMain = False
        self.pType = t #1 for c/c++, 2 for python, 3 for javascript
        self.csv = [] #copy of the csv to analyze

    #copies the information from the csv file to this array for the entire program
    def setCsv(self, line):
        global CSV_PROGRAM_FIELD, CSV_ID_FIELD, CSV_CLASS_FIELD, CSV_SCOPE_FIELD, CSV_CALL_FIELD, CSV_ARG_FIELD
        args = self.getArgs(line)
        call = str(line[CSV_CALL_FIELD]+'('+''.join(args)+')')
        self.csv.append([line[CSV_PROGRAM_FIELD], line[CSV_CLASS_FIELD], line[CSV_SCOPE_FIELD], call, line[CSV_ID_FIELD]])

    #determines if the program has a main program and can run independently
    def setIndependent(self):
        global PROGRAM_CSV_SCOPE_FIELD
        for c in self.csv:
            self.name, c[PROGRAM_CSV_SCOPE_FIELD]
            if self.name in c[PROGRAM_CSV_SCOPE_FIELD]: #scope
                self.hasMain = True #the program can run independently
                break

    #returns a list of arguments for the fucntion call
    def getArgs(self, line):
        global CSV_ARG_FIELD
        args = line[CSV_ARG_FIELD:]
        for x in range(0, len(args)-1):
            if x != len(args)-1:
                args[x] = args[x]+", " #add a comma and extra space at end for aesthetics
        return args #args is a list of all arguments for the call

    #add all the functions called in the program to functions list as Function objects
    def setFuncs(self):
        global functions, PROGRAM_CSV_PROGRAM_FIELD, PROGRAM_CSV_CLASS_FIELD, PROGRAM_CSV_SCOPE_FIELD, PROGRAM_CSV_CALL_FIELD, PROGRAM_CSV_ID_FIELD
        self.setIndependent()
        #if the program has a main function, add to functions list
        if self.hasMain:
            functions.append(Function(self.name, self.name, 'GLOBAL'))
        #add all called functions to functions list
        for c in self.csv:
            add = True
            for f in functions:
                #if already in functions, don't add
                #split('(')[0] gets the name of the call without arguments or ()
                if c[PROGRAM_CSV_CALL_FIELD].split('(')[0] == f.name and c[PROGRAM_CSV_PROGRAM_FIELD] == f.program and c[PROGRAM_CSV_CLASS_FIELD] == f.className:
                    add = False
            if add:
                functions.append(Function(c[PROGRAM_CSV_CALL_FIELD].split('(')[0], c[PROGRAM_CSV_PROGRAM_FIELD], c[PROGRAM_CSV_CLASS_FIELD]))
        #add all functions not called, but that appear in csv (scope)
        for c in self.csv:
            add = True
            #if already in functions, don't add
            for f in functions:
                if 'OBJ.' in f.name:
                    fn = f.name[4:] #gets rid of OBJ.
                else:
                    fn = f.name
                if c[PROGRAM_CSV_SCOPE_FIELD] == fn and self.name == f.program and c[PROGRAM_CSV_CLASS_FIELD] == f.className:
                    add = False
                elif c[PROGRAM_CSV_SCOPE_FIELD] == f.name and self.name == f.program and 'GLOBAL' == f.className:
                    add = False
            if add:
                functions.append(Function(c[PROGRAM_CSV_SCOPE_FIELD], self.name, 'GLOBAL'))
        #add all calls inside the functions
        for c in self.csv:
            for i, f in enumerate(functions):
                if 'OBJ.' in f.name:
                    fn = f.name[4:] #gets rid of OBJ.
                else:
                    fn = f.name
                if c[PROGRAM_CSV_SCOPE_FIELD] == fn and self.name == f.program and (f.className == c[PROGRAM_CSV_CLASS_FIELD] or f.className == 'GLOBAL'):
                    functions[i].addFuncCall(c[PROGRAM_CSV_CALL_FIELD], c[PROGRAM_CSV_PROGRAM_FIELD], c[PROGRAM_CSV_CLASS_FIELD], c[PROGRAM_CSV_ID_FIELD])

#------------------------------------------------------------------------#

#----------------------------Body Functions------------------------------#

#finds random, unused number (for dot file) and adds it to IDlist
def randNum():
    global IDlist
    i = ""
    while True:
        #this version allows for 100,000,000 function calls
        i = "Node0x"+str(random.randint(100000000, 999999999)) #id assignment
        if IDlist.get(i, None) == None: #check to see if ID is already used
            IDlist[i] = 'taken'
            break
    return i

#determinesdot information and adds a call to programCalls if another program is called from this program
def prepareNode(call):
    global shapeDict
    #shapeDict = {'1':'oval', '2':'rectangle', '3':'hexagon'}
    recursiveDict = {True: ', style=dashed', False: ''}
    circularDict = {True: ', style=dashed, peripheries=2', False: ''}
    name = ''

    if "File_Cannot_Be_Discerned" in call.name:
        errorNode(call.name[:-2], call.ID, call.program)
    else:
        if call.program == call.name:
            name = call.name
        else:
            name = '('+call.program+')\\n'+call.name
        if not call.independent:
            name = call.callID+'. '+name
        printNode(call.ID, shapeDict[call.pType], name, circularDict[call.circular]+recursiveDict[call.recursive])
    if call.independent == False:
        printFlow(call.parentID, call.ID)

def errorNode(name, ID, program):
    global errorDict, shapeDict
    #shapeDict = {'1':'oval', '2':'rectangle', '3':'hexagon'}
    #errorDict = {'Python':'2', 'JavaScript':'3', 'C/C++':'1'}
    progType = name.split('_')[1]
    printNode(ID, shapeDict[errorDict[progType]], "("+program+") Anonymous-Dynamic", ', style=dashed, peripheries=2')

#adds the appropriate ID to the next available call of the appropriate name in programCalls
def addCall(name, ID, parentName, parentID, progName, className, pType, callID):
    global functionCalls, typeDict, progCallDict, functions
    #typeDict = {'py': '2', 'js': '3', 'c': '1', 'cpp': '1'}
    #progCallDict = {'1':['py()', 'js()'], '2':['js()', 'c()', 'cpp()'], '3':['py()', 'c()', 'cpp()']}
    parentProgHistory = []
    parentCallHistory = []
    parentProg = ''
    add = True
    for c in functionCalls:
        if c.name == parentName and c.ID == parentID:
            parentProgHistory = c.progHistory
            parentCallHistory = c.callHistory
            parentProg = c.program #used for call history
            #do not add if the parent is circular or recursive
            if c.circular or c.recursive:
                add = False
    if add:
        #check to see if the program calls another type of program
        if name.split('.')[-1] in progCallDict[pType]:
            #name[:-2] takes out the () in the call, so the resulting name is just the programs (ex: file.js() -> file.js)
            #main difference between adding this call and another is that the name of the program and the program type are dependent on the call name
            functionCalls.append(Call(name[:-2], ID, name[:-2], className, typeDict[name[:-2].split('.')[-1]], parentName, parentID, callID))
            functionCalls[-1].setProgHistory(parentProgHistory)
        else:
            functionCalls.append(Call(name, ID, progName, className, pType, parentName, parentID, callID))
        #all calls (regardless if they are multilingual) inherit the call history of their parent
        functionCalls[-1].setHistory(parentCallHistory, parentProg)

#initialize functionCalls list with all main functions of independent programs
def setFunctionCalls():
    global system, functionCalls, progCallDict, PROGRAM_CSV_CALL_FIELD
    #progCallDict = {'1':['py()', 'js()'], '2':['js()', 'c()', 'cpp()'], '3':['py()', 'c()', 'cpp()']}
    temp = []
    for program in system:
        for c in program.csv:
            #c[3].split('.')[-1] gets the suffix of the program (ex: .c, .py...)
            if c[PROGRAM_CSV_CALL_FIELD].split('.')[-1] in progCallDict[program.pType]:
                temp.append(c[PROGRAM_CSV_CALL_FIELD][:-2])

    for p in system:
        if p.hasMain == True:
            add = True
            for t in temp:
                if p.name == t:
                    add = False
            if add:
                functionCalls.append(Call(p.name, randNum(), p.name, 'GLOBAL', p.pType, '', -1, '', True))
                functionCalls[-1].setHistory([])

#print the flow information in the dot format
def printFlow(fID, sID):
    global dot
    dot.write(str("\t"+fID+" -> "+sID+";\n"))

#print the node information in the dot format
def printNode(ID, shape, name, extras):
    global dot
    dot.write(str('\t'+ID+' [shape='+shape+extras+', label="'+name+'"];\n'))

def addProgram(t, pName):
    global system
    if system:
        system[-1].setFuncs()
    system.append(Program(t, pName))

#------------------------------------------------------------------------#

#-----------------------------Main Function------------------------------#

def main(cgCsv, title, cgDot):
    global IDlist, system, dot, ERROR, functionCalls, typeDict, functions
    global CSV_MAIN_PROGRAM_FIELD, CSV_PROGRAM_TYPE_FIELD, CALL_NAME_FIELD, CALL_SCOPE_FIELD, CALL_CLASS_FIELD, CALL_ID_FIELD

    try:
        with open(cgCsv, "r") as csvfile:
            reader = csv.reader(csvfile)
            progname = ''
            count = 0
            for i, row in enumerate(reader):
                count += 1
                if progname != row[CSV_MAIN_PROGRAM_FIELD]:
                    progname = row[CSV_MAIN_PROGRAM_FIELD]
                    addProgram(row[CSV_PROGRAM_TYPE_FIELD], progname)
                system[-1].setCsv(row) #add line to Program object's csv array
            if count == 0:
                sys.exit(ERROR+'no function calls found in any programs')
            system[-1].setFuncs() #sets functions for last program in system
    except IOError:
        sys.exit(ERROR+mlcsv+" does not exist")

    #make array of all programs NOT called by another program
    setFunctionCalls()
    if len(functionCalls) == 0:
        sys.exit(ERROR+"no main program in system")

    #make a list of all function calls in the system
    while True:
        added = False
        for call in functionCalls:
            if call.used == False:
                call.setUsed(True)
                for func in functions:
                    if func.name == call.name.split('(')[0] and func.program == call.program and func.className == call.className:
                        for c in func.calls:
                            addCall(c[CALL_NAME_FIELD], randNum(), call.name, call.ID, c[CALL_SCOPE_FIELD], c[CALL_CLASS_FIELD], typeDict[c[CALL_SCOPE_FIELD].split('.')[-1]], c[CALL_ID_FIELD])
                            added = True
        if added == False:
            break

    try:
        with open(cgDot, "w") as dot:
            dot.write('digraph "'+title+' Call Graph" {\n') #set name for call graph
            dot.write('\tgraph [dpi=300\n') #set dpi to 300
            dot.write('\t\trankdir=LR\n') #make graph vertical
            dot.write('\t\tsize="7.5, 10"\n') #condense size to an 8.5x11 paper
            dot.write('\t\tlabel="'+title+' Call Graph"\n') #display name of call graph
            dot.write('\t];\n\n')
            for call in functionCalls:
                prepareNode(call)
            dot.write("}")
    except IOError:
        sys.exit(ERROR+"problem writing dot file "+cdDot)

    #os.system("rm "+cgCsv)

#main("mlcsv.csv", 'mlcg.dot')
