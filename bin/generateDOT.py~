#!/usr/bin/env python
# MLSA Multilingual Software Analysis
# This program is part of the MLSA package under development at Fordham University Department of Computer and Information Science.
# generateDOT.py takes in the csv file generated by mergeFunCall. The program creates a tree structure to visualize the csv file from mergeFunCall, 
#       and then writes to a dot file that then generates a pdf of the tree through GraphViz
# Author: Anne Marie Bogar
# Date: June 29, 2017
# this code can be copied or used and is without warrenty or support, but this header needs to be copied along with the program FU2017
# Input: csv file
#		program_name(string),program_type(int),program_of_function_def(string),call_id(int),class(string),scope(string),function_name(string),argument1(string),argument2(string)...
# Output: dot file
#		Node0x859365863 [shape=rectangle, label="file1.py"];
#	        Node0x120389922 [shape=rectangle, label="0. (file2.py) \n function(arg)"];
#	        Node0x859365863 -> Node0x120389922;
# for arguments, all literals are encased in <> (ex: <5>)
# function calls that are arguments of another function call have their id next to () in csv line of the other function call
#               ex: function1(function2()4, arg)

import random
import os
import csv
import sys

#global variables
IDlist = {} #all the unique Node IDs
system = [] #all the programs in the system being analyzed
functions = [] #all the functions in the system
functionCalls = [] #all the function calls that need to be added to the dot file
dot = ''
ERROR = 'MLSA: generateDOT; '
#CSV file from mergeFunCall
CSV_MAIN_PROGRAM_FIELD = 0
CSV_PROGRAM_TYPE_FIELD = 1
CSV_PROGRAM_FIELD = 2
CSV_ID_FIELD = 3
CSV_CLASS_FIELD = 4
CSV_SCOPE_FIELD = 5
CSV_CALL_FIELD = 6
CSV_ARG_FIELD = 7
#Program class member variable self.csv
PROGRAM_CSV_PROGRAM_FIELD = 0
PROGRAM_CSV_CLASS_FIELD = 1
PROGRAM_CSV_SCOPE_FIELD = 2
PROGRAM_CSV_CALL_FIELD = 3
PROGRAM_CSV_ID_FIELD = 4
#Function class member variable self.calls
CALL_NAME_FIELD = 0
CALL_SCOPE_FIELD = 1
CALL_CLASS_FIELD = 2
CALL_ID_FIELD = 3
#Call class member variable self.callHistory
HISTORY_NAME_FIELD = 0
HISTORY_PROGRAM_FIELD = 1

#dictionaries -> change if adding another language
#example of how to change if adding java: typeDict = {'c':'1', 'cpp':'1', 'py':'2', 'js':'3', 'java':'4'}
typeDict = {'py': '2', 'js': '3', 'c': '1', 'cpp': '1'}
shapeDict = {'1':'oval', '2':'rectangle', '3':'hexagon'}
#example of how to change if adding java: progCallDict = {'1':['py()', 'js()', 'java()'], '2':['js()', 'c()', 'cpp()', 'java()'], '3':['py()', 'c()', 'cpp()', 'java()'], '4':['c()', 'cpp()', 'py()', 'js()']}
progCallDict = {'1':['py()', 'js()'], '2':['js()', 'c()', 'cpp()'], '3':['py()', 'c()', 'cpp()']}
errorDict = {'Python':'2', 'JavaScript':'3', 'C/C++':'1'}

#---------------------------Function Class------------------------------#

#Function is a function called in the main body of a program
class Function:
    def __init__(self, name, program, className):
        #name of the function
        self.name = name
        #program it was defined in
        self.program = program
        #if member function, classname (or GLOBAL if regular function)
        self.className = className
        #all of the calls in a function definition
        self.calls = []

    # adds the information of a function called inside of the function's definition
    def addFuncCall(self, name, program, className, callID):
        self.calls.append([name, program, className, callID])

#------------------------------------------------------------------------#

#------------------------------Call Class--------------------------------#

#Call is a function call
class Call:
    def __init__(self, name, ID, program, className, pType, parentName, parentID, callID, ind=False):
        ### for print Flow and Node ###
        #name of the function
        self.name = name
        #function ID from CSV file
        self.ID = ID
        #name of the function in which this function was called
        self.parentName = parentName
        #ID of the function in which this function was callled
        self.parentID = parentID
        #unique Node0x ID for dot file
        self.callID = callID

        ### for finding the matching Function in the functions list ###
        #program in which this function was defined
        self.program = program
        #if member function, class name. If not, GLOBAL
        self.className = className

        ### for determining shape ###
        #program type (i.e. Python, C/C++...)
        self.pType = pType

        ### for determing if the call is recursive or circular ###
        #list of functions called before this function (e.g. func1 calls func2, func2 calls func3...)
        #used for determining recursive value
        self.callHistory = []
        #list of programs before this function (e.g. prog1 calls func2 in prog2...)
        # used for determining circular value
        self.progHistory = [program]
        #if the call is circuler (prog1 calls prog2, prog2 calls prog1) -> this is marked as a HAZARD
        self.circular = False
        #if the call is recursive
        self.recursive = False

        ### for adding Calls to the functionCalls list ###
        self.used = False
        #if the call is a main function (not called by any other function) -> first to be printed
        self.independent = ind

    #set true if the calls inside the function definition of this function call have been added to functionCalls
    def setUsed(self, used):
        self.used = used

    #add the call history of the call's parent function
    def setHistory(self, history, parentProg=''):
        if self.independent == False: #if true, there is no history because no function calls this function
            self.callHistory.append([self.parentName, parentProg])
            for h in history:
                self.callHistory.append(h)
            #determine if recursive based on call history
            self.setRecursive()

    #add the program history of the call's parent function
    def setProgHistory(self, history):
        if self.progHistory != history:
            self.progHistory = history+self.progHistory
        #determine if circular based of program history
        self.setCircular()

    #set true if there is a function in the call history that is identical to this function
    def setRecursive(self):
        global HISTORY_NAME_FIELD, HISTORY_PROGRAM_FIELD
        if not self.circular: #programs can only be circular, not recursive
            for h in self.callHistory:
                if h[HISTORY_NAME_FIELD].split('(')[0] == self.name.split('(')[0] and h[HISTORY_PROGRAM_FIELD] == self.program: #same function
                    self.recursive = True

    #set true if there are at least two programs in the prog history and one that is not the last one is the same as the function's program
    def setCircular(self):
        count = 0
        for h in self.progHistory:
            if h == self.program:
                count += 1
        if count > 1: #if there is more than one of the current program, the program is being called again -> circular
            self.circular = True

#------------------------------------------------------------------------#

#---------------------------Program Class--------------------------------#

#Program is a program in the system
class Program:
    def __init__(self, t, name):
        #name of the program
        self.name = name
        #assume the program does not have a main function -> will change later
        self.hasMain = False
        self.pType = t #1 for c/c++, 2 for python, 3 for javascript
        #copy of the csv to analyze
        self.csv = [] 

    #copies the information from the csv file to this array for the entire program
    def setCsv(self, line):
        global CSV_PROGRAM_FIELD, CSV_ID_FIELD, CSV_CLASS_FIELD, CSV_SCOPE_FIELD, CSV_CALL_FIELD, CSV_ARG_FIELD
        #retrieve all the arguments from the call information
        args = self.getArgs(line)
        #set the name of the function call -> function(arg1,arg2)
        call = str(line[CSV_CALL_FIELD]+'('+''.join(args)+')')
        #add only the important fields to csv list
        self.csv.append([line[CSV_PROGRAM_FIELD], line[CSV_CLASS_FIELD], line[CSV_SCOPE_FIELD], call, line[CSV_ID_FIELD]])

    #determines if the program has a main program and can run independently
    def setIndependent(self):
        global PROGRAM_CSV_SCOPE_FIELD
        for c in self.csv:
            #check whether the name of the file is in the scope of any function calls
            #earlier, the main function's name was changed to the name of the program
            if self.name in c[PROGRAM_CSV_SCOPE_FIELD]:
                self.hasMain = True #the program can run independently
                break

    #returns a list of arguments for the fucntion call
    def getArgs(self, line):
        global CSV_ARG_FIELD
        args = line[CSV_ARG_FIELD:]
        for x in range(0, len(args)-1):
            if x != len(args)-1:
                args[x] = args[x]+", " #add a comma and extra space at end for aesthetics
        return args #args is a list of all arguments for the call

    #add all the functions called in the program to functions list as Function objects
    def setFuncs(self):
        global functions, PROGRAM_CSV_PROGRAM_FIELD, PROGRAM_CSV_CLASS_FIELD, PROGRAM_CSV_SCOPE_FIELD, PROGRAM_CSV_CALL_FIELD, PROGRAM_CSV_ID_FIELD
        self.setIndependent()
        #if the program has a main function, add to functions list
        if self.hasMain:
            functions.append(Function(self.name, self.name, 'GLOBAL'))
        #add all called functions to functions list
        for c in self.csv:
            add = True
            for f in functions:
                #if already in functions, don't add
                #split('(')[0] gets the name of the call without arguments or ()
                if c[PROGRAM_CSV_CALL_FIELD].split('(')[0] == f.name and c[PROGRAM_CSV_PROGRAM_FIELD] == f.program and c[PROGRAM_CSV_CLASS_FIELD] == f.className:
                    add = False
            if add:
                functions.append(Function(c[PROGRAM_CSV_CALL_FIELD].split('(')[0], c[PROGRAM_CSV_PROGRAM_FIELD], c[PROGRAM_CSV_CLASS_FIELD]))
        #add all functions not called, but that appear in csv (scope)
        for c in self.csv:
            add = True
            #if already in functions, don't add
            for f in functions:
                callClass = "GLOBAL" #assume global, change later
                if "::" in f.name or "OBJ." in f.name:
                    callClass = "MEMBER"
                if 'OBJ.' in f.name:
                    fn = f.name[4:] #gets rid of OBJ.
                else:
                    fn = f.name
                if c[PROGRAM_CSV_SCOPE_FIELD] == fn and self.name == f.program and callClass == f.className:
                    add = False
            if add:
                functions.append(Function(c[PROGRAM_CSV_SCOPE_FIELD], c[PROGRAM_CSV_PROGRAM_FIELD], c[PROGRAM_CSV_CLASS_FIELD]))
        #add all calls inside the functions
        for c in self.csv:
            scopeClass = "GLOBAL" #assume GLOBAL, change later
            if "::" in c[PROGRAM_CSV_SCOPE_FIELD] or "OBJ." in c[PROGRAM_CSV_SCOPE_FIELD]:
                scopeClass = "MEMBER"
            for i, f in enumerate(functions):
                if 'OBJ.' in f.name:
                    fn = f.name[4:] #gets rid of OBJ.
                else:
                    fn = f.name
                if c[PROGRAM_CSV_SCOPE_FIELD] == fn and self.name == f.program and f.className == scopeClass:
                    functions[i].addFuncCall(c[PROGRAM_CSV_CALL_FIELD], c[PROGRAM_CSV_PROGRAM_FIELD], c[PROGRAM_CSV_CLASS_FIELD], c[PROGRAM_CSV_ID_FIELD])

#------------------------------------------------------------------------#

#----------------------------Body Functions------------------------------#

#finds random, unused number (for dot file) and adds it to IDlist
def randNum():
    global IDlist
    i = ""
    while True:
        #this version allows for 100,000,000 function calls
        i = "Node0x"+str(random.randint(100000000, 999999999)) #id assignment
        if IDlist.get(i, None) == None: #check to see if ID is already used
            IDlist[i] = 'taken'
            break
    return i

#determines dot information and adds a call to programCalls if another program is called from this program
def prepareNode(call):
    global shapeDict
    #shapeDict = {'1':'oval', '2':'rectangle', '3':'hexagon'}
    recursiveDict = {True: ', style=dashed', False: ''}
    circularDict = {True: ', style=dashed, peripheries=2', False: ''}
    name = ''

    #interoperability API in which the name of the program could not be determined -> mark as HAZARD
    if "File_Cannot_Be_Discerned" in call.name:
        errorNode(call.name[:-2], call.ID, call.program)
    else:
        if call.program == call.name: #main function -> name is just the program name
            name = call.name
        else:
            name = '('+call.program+')\\n'+call.name
        if not call.independent: #an independent function is the main function of the program -> nothing calls it
            name = call.callID+'. '+name
        printNode(call.ID, shapeDict[call.pType], name, circularDict[call.circular]+recursiveDict[call.recursive])
    if call.independent == False: #link back to the parent function
        printFlow(call.parentID, call.ID)

#prints an error node
def errorNode(name, ID, program):
    global errorDict, shapeDict
    #shapeDict = {'1':'oval', '2':'rectangle', '3':'hexagon'}
    #errorDict = {'Python':'2', 'JavaScript':'3', 'C/C++':'1'}
    progType = name.split('_')[1] #get's type of program (program language)
    printNode(ID, shapeDict[errorDict[progType]], "("+program+") Anonymous-Dynamic", ', style=dashed, peripheries=2')

#adds a new Call to the functionCalls list
def addCall(name, ID, parentName, parentID, progName, className, pType, callID):
    global functionCalls, typeDict, progCallDict, functions
    #typeDict = {'py': '2', 'js': '3', 'c': '1', 'cpp': '1'}
    #progCallDict = {'1':['py()', 'js()'], '2':['js()', 'c()', 'cpp()'], '3':['py()', 'c()', 'cpp()']}
    parentProgHistory = []
    parentCallHistory = []
    parentProg = ''
    add = True
    #get the histories of the parent function
    for c in functionCalls:
        if c.name == parentName and c.ID == parentID:
            parentProgHistory = c.progHistory
            parentCallHistory = c.callHistory
            parentProg = c.program #used for call history
            #do not add if the parent is circular or recursive
            if c.circular or c.recursive:
                add = False
    if add:
        #check to see if the program calls another type of program
        if name.split('.')[-1] in progCallDict[pType]:
            #name[:-2] takes out the () in the call, so the resulting name is just the program's (ex: file.js() -> file.js)
            #main difference between adding this call and another is that the name of the program and the program type are dependent on the call name
            functionCalls.append(Call(name[:-2], ID, name[:-2], className, typeDict[name[:-2].split('.')[-1]], parentName, parentID, callID))
            functionCalls[-1].setProgHistory(parentProgHistory) # only set program history if calling another program
        else:
            functionCalls.append(Call(name, ID, progName, className, pType, parentName, parentID, callID))
        #all calls (regardless if they are multilingual) inherit the call history of their parent
        functionCalls[-1].setHistory(parentCallHistory, parentProg)

#initialize functionCalls list with all main functions of independent programs
def setFunctionCalls():
    global system, functionCalls, progCallDict, PROGRAM_CSV_CALL_FIELD
    #progCallDict = {'1':['py()', 'js()'], '2':['js()', 'c()', 'cpp()'], '3':['py()', 'c()', 'cpp()']}
    temp = []
    #print "%%%%%5", system
    for program in system:
        for c in program.csv:
            #c[3].split('.')[-1] gets the suffix of the program (ex: .c, .py...)
            #collect all the Calls called within the main program in a temporary list
            if c[PROGRAM_CSV_CALL_FIELD].split('.')[-1] in progCallDict[program.pType]:
                temp.append(c[PROGRAM_CSV_CALL_FIELD][:-2])

    for p in system:
        if p.hasMain == True:
            add = True # add all the main functions in the system
            for t in temp:
                if p.name == t: #make sure there are no duplicates
                    add = False
            if add:
                functionCalls.append(Call(p.name, randNum(), p.name, 'GLOBAL', p.pType, '', -1, '', True))
                functionCalls[-1].setHistory([])

#print the flow information in the dot format
def printFlow(fID, sID):
    global dot
    #Node0x123456789 -> Node0x987654321
    dot.write(str("\t"+fID+" -> "+sID+";\n"))

#print the node information in the dot format
def printNode(ID, shape, name, extras):
    global dot
    # Node0x123456789 [shape:..., label:..., name:...]
    dot.write(str('\t'+ID+' [shape='+shape+extras+', label="'+name+'"];\n'))

#add a Program to the system list
def addProgram(t, pName):
    global system
    if system: #finish up with the last program added before adding a new one
        system[-1].setFuncs() #sets functions for last program in system
    system.append(Program(t, pName))

#------------------------------------------------------------------------#

#-----------------------------Main Function------------------------------#

def main(cgCsv, title, cgDot):
    global IDlist, system, dot, ERROR, functionCalls, typeDict, functions
    global CSV_MAIN_PROGRAM_FIELD, CSV_PROGRAM_TYPE_FIELD, CALL_NAME_FIELD, CALL_SCOPE_FIELD, CALL_CLASS_FIELD, CALL_ID_FIELD

    try:
        with open(cgCsv, "r") as csvfile:
            reader = csv.reader(csvfile)
            progname = ''
            count = 0 #to determine if there is anything in the csv file (if there are any function calls in the program)
            for i, row in enumerate(reader):
                count += 1
                if progname != row[CSV_MAIN_PROGRAM_FIELD]: #new program
                    progname = row[CSV_MAIN_PROGRAM_FIELD] #set progname to this new program
                    addProgram(row[CSV_PROGRAM_TYPE_FIELD], progname) #add new program
                system[-1].setCsv(row) #add line to Program object's csv array
            if count == 0: #no function calls in the program
                sys.exit(ERROR+'no function calls found in any programs')
            system[-1].setFuncs() #sets functions for last program in system
    except IOError:
        sys.exit(ERROR+mlcsv+" does not exist")

    #make array of all programs NOT called by another program
    setFunctionCalls()
    if len(functionCalls) == 0: #no main functions in the system -> does not create a graph
        sys.exit(ERROR+"no main functions in system")

    #make a list of all function calls in the system
    while True:
        added = False
        for call in functionCalls:
            if call.used == False: #have not yet added all the calls inside the function definition
                call.setUsed(True)
                for func in functions:
                    #find the function that corresponds with the function called in functionCalls
                    if func.name == call.name.split('(')[0] and func.program == call.program and func.className == call.className:
                        #add all the calls inside the function definition
                        for c in func.calls:
                            addCall(c[CALL_NAME_FIELD], randNum(), call.name, call.ID, c[CALL_SCOPE_FIELD], c[CALL_CLASS_FIELD], typeDict[c[CALL_SCOPE_FIELD].split('.')[-1]], c[CALL_ID_FIELD])
                            added = True
        if added == False: #no more function calls were added to functionCalls list in this cycle -> finished collecting calls
            break

    try:
        with open(cgDot, "w") as dot:
            dot.write('digraph "'+title+' Call Graph" {\n') #set name for call graph
            dot.write('\tgraph [dpi=300\n') #set dpi to 300
            dot.write('\t\trankdir=LR\n') #make graph vertical
            dot.write('\t\tsize="7.5, 10"\n') #condense size to an 8.5x11 paper
            dot.write('\t\tlabel="'+title+' Call Graph"\n') #display name of call graph
            dot.write('\t];\n\n')
            for call in functionCalls:
                prepareNode(call) #add all of the Nodes and Flows for each Call in functionCalls to the dot file
            dot.write("}")
    except IOError:
        sys.exit(ERROR+"problem writing dot file "+cdDot)

    #clean up
    #os.system("rm "+cgCsv)

# use for debugging
#main("mlcsv.csv", 'mlcg.dot')
