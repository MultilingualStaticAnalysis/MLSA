from enum import Enum
import csv

AST_LINE_COUNT = 0

def Main():
	global AST_LINE_COUNT

	# Read the contents of the abstract syntax tree output produced by Clang.
	# This is generated by typing clang -cc1 -ast-dump file.cpp >> ast.txt
	txtFile = open("ast.txt", "r")
	treeLines = txtFile.readlines()
	txtFile.close()

	treeList = []

	# Parse the textual representation of the ast and extract the important lines.
	mainFound = False
	for line in treeLines:
		line = line.replace(".cpp", "line")

		if (line.find(" main") != -1):
			mainFound = True

		if (line.find("-") != -1 and line.find("line:") != -1 and mainFound == True):
			treeList.insert(len(treeList), line)

	astList = [None]
	lineNum = 0

	while (lineNum < len(treeList) - 1):
		# Parse the root ast node.
		astParent = ParseItemAtLine(treeList, lineNum)
		lineNum = lineNum + 1
		astCollection = ParseASTItem(treeList, lineNum, astParent)
		astParent = astCollection[0]
		lineNum = astCollection[1]

		# Iterate through the children of our root node.
		lineNum = ProcessChildren(treeList, astParent, astParent.lineIndex) + 1

		astList.insert(len(astList), astParent)



	resultMap = []
	resultMapReverse = []

	NUM_LINES = AST_LINE_COUNT

	#print("NUM_LINES: " + str(NUM_LINES))

    # Generate the CFG and Reverse CFG
	for i in range(NUM_LINES + 1):
		resultMap.insert(len(resultMap), [])
		resultMapReverse.insert(len(resultMapReverse), [])

	for astParent in astList:
		for i in range(1, NUM_LINES + 0):
			if (astParent == None):
				continue

			result = FindItemForLine(i, treeList, astParent)

			if (result != None):
				strResult = result.GetNextLineNumbers();

				if (i == result.lineNumEnd):
					if (result.typeString == "WhileStmt"):
						strResult = [ result.lineNum ]
					elif (result.typeString == "CompoundStmt" and result.parent != None and GetChildCountOfType(result.parent, "CompoundStmt") >= 2):
						strResult = [ result.parent.lineNumEnd+1 ]
					elif (result.typeString == "FunctionDecl" and i == result.lineNumEnd):
						strResult = [] 
					else:
						strResult = [ result.lineNumEnd+1 ]

				resultMap[i] = strResult

				if ((result.typeString == "WhileStmt") and len(strResult) > 1):
					print(str(strResult[1]))
					resultMap[strResult[1]-1] = [strResult[0]-1]

				for item in strResult:
					resultMapReverse[item-0].insert(len(resultMapReverse), i)

        # Print out the results.
	for i in range(1, NUM_LINES+1):
		if (i < len(resultMap)):
			print("Line: " + str(i) + " Destination(s): " + str(resultMap[i]))
			print("R-Line: " + str(i) + " " + str(resultMapReverse[i]))


	print(str(resultMap))
	print(str(resultMapReverse))

        # Output the reverse cfg to a csv file.
	with open('rcfg.csv', 'w') as csvFile:
		csvWriter = csv.writer(csvFile, delimiter=',',
			    quotechar='|', quoting=csv.QUOTE_MINIMAL)

		for i in range(1, len(resultMapReverse)):
			items = []
			items.insert(len(items), i);

			for line in resultMapReverse[i]:
				items.insert(len(items), line)

			csvWriter.writerow(items)

def ProcessChildren(treeList, astParent, currentLine):
	for child in astParent.children:
		if (child.lineIndex + 1 < len(treeList)):
			child = ParseASTItem(treeList, child.lineIndex + 1, child)[0]
			
			currentLine = ProcessChildren(treeList, child, currentLine)

			if (child.lineIndex > currentLine):
				currentLine = child.lineIndex

	return currentLine



def FindItemForLine(lineNum, treeList, astParent):
	if astParent.lineNum == lineNum or astParent.lineNumEnd == lineNum:
		return astParent

	if (astParent.possibleElseStmt == True and lineNum == astParent.lineNum - 1):
		return astParent

	for child in astParent.children:
		result = FindItemForLine(lineNum, treeList, child)

		if result != None:
			return result

	return None

def GetChildCountOfType(astItem, childType):
	childCount = 0

	for child in astItem.children:
		if (child.typeString == childType):
			childCount = childCount + 1

	return childCount

def ParseASTItem(treeLines, index, astParent):
	line = treeLines[index]

	while index < len(treeLines):
		astItem = ParseItemAtLine(treeLines, index)

		if (astParent.treeLevel >= astItem.treeLevel):
			break

		#if ((astParent.treeLevel + 2 == astItem.treeLevel) or (astParent.treeLevel + 1 == astItem.treeLevel)):
		if (astParent.treeLevel + 2 == astItem.treeLevel):

			if (astParent.typeString == "WhileStmt"):
				yes = 1;

			astParent.children.insert(len(astParent.children), astItem)
			astItem.parent = astParent

			line = treeLines[index]

			if (astItem.typeString == "CompoundStmt" and line.find("`") != -1 and ((astItem.parent != None and (astParent.typeString != "WhileStmt" and astParent.typeString != "FunctionDecl")))):
				astItem.possibleElseStmt = True
			else:
				astItem.possibleElseStmt = False

			if (astItem.lineNum == -1):
				astItem.lineNum = astItem.parent.lineNum
			
		index = index + 1

	return astParent, index

def ParseItemAtLine(treeLines, index):
	global AST_LINE_COUNT

	line = treeLines[index]

	line = line.replace("testline", "line")

	astItem = ASTEntry()
	astItem.typeString = line.split("0x")[0].split("-")[1].replace(" ", "")
	


	if (line.find("<line:") != -1):
		astItem.lineNum = int(line.split("line:")[1].split(":")[0])
	else:
		astItem.lineNum = -1

	astItem.lineNumEnd = -1
	astItem.possibleElseStmt = False
	
	if (astItem.typeString == "IfStmt" or astItem.typeString == "WhileStmt" or astItem.typeString == "FunctionDecl"
	or astItem.typeString == "CompoundStmt"):
		if (line.find(", line:") != -1):
			astItem.lineNumEnd = int(line.split(", line:")[1].split(":")[0])
	
	if (astItem.typeString == "CompoundStmt" and line.find("`") != -1 and ((astItem.parent != None and astItem.typeString != "WhileStmt"))):
		astItem.possibleElseStmt = True

	if (astItem.typeString == "FunctionDecl"):
		astItem.lineNum = int(line.split(":")[1].split(":")[0])
		if (astItem.lineNumEnd > AST_LINE_COUNT):
			AST_LINE_COUNT = astItem.lineNumEnd
		print(str(AST_LINE_COUNT))
	
	astItem.treeLevel = GetTreeLevel(line)
	astItem.lineIndex = index

	return astItem

def StringFind(text, items):
	
	for item in items:
		if (text.find(item) != -1):
			return True;

	return False;

def GetTreeLevel(text):
	spaceCount = 0

	for character in text:
		if (character == '-'):
			break;
		else:
			spaceCount = spaceCount + 1


		#if character == ' ':
		#	spaceCount = spaceCount + 1
		#elif character == '|':
		#	spaceCount = spaceCount - 1
		#elif character == "`":
		#	spaceCount = spaceCount - 1
		#elif character == '-':
		#	spaceCount = spaceCount + 1
		#	break

	return spaceCount

class AstType(Enum):
	Undefined = -1
	FuncDecl = 0
	CompoundStatement = 1
	DeclStatement = 2
	VarDecl = 3
	ReturnStatement = 4

class ASTEntry(object):
	def __init__(self):
		self.type = AstType.Undefined
		self.typeString = ""
		self.lineNum = -1
		self.lineNumEnd = -1
		self.treeLevel = -1
		self.lineIndex = -1
		self.children = []
		self.parent = None
		
	def GetNextLineNumbers(self):
		result = []

		if (self.typeString == "IfStmt" or self.typeString == "WhileStmt" or self.typeString == "CompoundStmt"):
			hasCompoundStatements = False
			hasElseStatements = False

			for child in self.children:
				if (child.typeString == "CompoundStmt"):
					if (child.possibleElseStmt == True):
						result.insert(len(result), child.lineNum - 1)
						hasElseStatements = True
					else:
						result.insert(len(result), child.lineNum)
					
					hasCompoundStatements = True
				
				p = 0;


			if (hasCompoundStatements == False):
				result.insert(len(result), self.lineNum+1)
			else:
				if (self.typeString == "IfStmt"):
					if (hasElseStatements == False):
						result.insert(len(result), self.lineNumEnd+1)
				elif (self.typeString == "WhileStmt"):
					result.insert(len(result), self.lineNumEnd+1);
					

			if (self.typeString == "CompoundStmt"):
				if (self.parent != None):
					print(self.parent.typeString)
					#if (self.parent.typeString == "IfStmt" or self.parent.typeString == "WhileStmt"):
						#if (self.lineNumEnd != -1):
							#result.insert(len(result), self.lineNumEnd)
			#elif (self.typeString == "WhileStmt" or (self.typeString == "IfStmt" and hasCompoundStatements == False)):
				#result.insert(len(result), self.lineNumEnd+1)

		elif (self.typeString == "UnaryOperator" or self.typeString == "CompoundStmt" or self.typeString == "BinaryOperator"):
			if (self.parent != None):
				result.insert(len(result), self.lineNum + 1)
			else:
				result.insert(len(result), self.lineNum + 1)

			p = 64;
		else:
			if (self.typeString != "FunctionDecl" or (self.typeString == "FunctionDecl" and len(self.children) > 0)):
				result.insert(len(result), self.lineNum + 1)

		return result

class Line(object):
	def __init__(self):
		self.line = -1;
		self.destLines = []

Main()
