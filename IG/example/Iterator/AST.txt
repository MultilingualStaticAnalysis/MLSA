namespace std {
    typedef unsigned long size_t;
    typedef long ptrdiff_t;
}
namespace std {
    inline namespace __cxx11 {
    }
}
namespace __gnu_cxx {
    inline namespace __cxx11 {
    }
}
namespace std {
    template <typename  = void> class allocator {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef void *pointer;
        typedef const void *const_pointer;
        typedef void value_type;
        template <typename _Tp1> struct rebind {
            typedef allocator<_Tp1> other;
        };
    }
template <typename  = char> class allocator : public __gnu_cxx::new_allocator<char> {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef char value_type;
        template <typename _Tp1 = char> struct rebind {
            typedef allocator<char> other;
        }
template <typename _Tp1> struct rebind;
        allocator() throw() : __gnu_cxx::new_allocator<char>()         {
        }


        allocator(const std::allocator<char> &__a) throw() : __gnu_cxx::new_allocator<char>(__a)         {
        }


        template <typename _Tp1 = char> allocator(const allocator<char> &) throw()template <typename _Tp1> allocator(const allocator<_Tp1> &) throw();
        ~std::allocator<char>() throw()         {
        }


    }
template <typename  = wchar_t> class allocator : public __gnu_cxx::new_allocator<wchar_t> {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef const wchar_t *const_pointer;
        typedef wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef wchar_t value_type;
        template <typename _Tp1 = wchar_t> struct rebind {
            typedef allocator<wchar_t> other;
        }
template <typename _Tp1> struct rebind;
        allocator() throw();
        allocator(const std::allocator<wchar_t> &__a) throw();
        template <typename _Tp1> allocator(const allocator<_Tp1> &) throw();
        ~std::allocator<wchar_t>() throw();
    }
template <typename  = Player> class allocator : public __gnu_cxx::new_allocator<Player> {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef Player *pointer;
        typedef const Player *const_pointer;
        typedef Player &reference;
        typedef const Player &const_reference;
        typedef Player value_type;
        template <typename _Tp1 = std::_List_node<Player>> struct rebind {
            typedef allocator<std::_List_node<Player> > other;
        }
template <typename _Tp1 = Player> struct rebind {
            typedef allocator<Player> other;
        }
template <typename _Tp1> struct rebind;
        allocator() throw();
        allocator(const std::allocator<Player> &__a) throw();
        template <typename _Tp1> allocator(const allocator<_Tp1> &) throw();
        ~std::allocator<Player>() throw();
    }
template <typename  = std::_List_node<Player>> class allocator : public __gnu_cxx::new_allocator<_List_node<Player> > {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef std::_List_node<Player> *pointer;
        typedef const std::_List_node<Player> *const_pointer;
        typedef std::_List_node<Player> &reference;
        typedef const std::_List_node<Player> &const_reference;
        typedef std::_List_node<Player> value_type;
        template <typename _Tp1> struct rebind;
        allocator() throw();
        allocator(const std::allocator<std::_List_node<Player> > &__a) throw();
        template <typename _Tp1> allocator(const allocator<_Tp1> &) throw();
        ~std::allocator<std::_List_node<Player> >() throw();
    }
template <typename > class allocator;
    class allocator;
    template <typename , typename > struct uses_allocator;
}
namespace std {
    template <class _CharT = char> struct char_traits {
        typedef char char_type;
        typedef int int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(char_type &__c1, const char_type &__c2)         {
            __c1 = __c2;
        }


        static bool eq(const char_type &__c1, const char_type &__c2)         {
            return __c1 == __c2;
        }


        static bool lt(const char_type &__c1, const char_type &__c2)         {
            return (static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2));
        }


        static int compare(const char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return 0;
            return __builtin_memcmp(__s1, __s2, __n);
        }


        static size_t length(const char_type *__s)         {
            return __builtin_strlen(__s);
        }


        static const char_type *find(const char_type *__s, size_t __n, const char_type &__a)         {
            if (__n == 0)
                return 0;
            return static_cast<const char_type *>(__builtin_memchr(__s, __a, __n));
        }


        static char_type *move(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<char_type *>(__builtin_memmove(__s1, __s2, __n));
        }


        static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }


        static char_type *assign(char_type *__s, size_t __n, char_type __a)         {
            if (__n == 0)
                return __s;
            return static_cast<char_type *>(__builtin_memset(__s, __a, __n));
        }


        static char_type to_char_type(const int_type &__c)         {
            return static_cast<char_type>(__c);
        }


        static int_type to_int_type(const char_type &__c)         {
            return static_cast<int_type>(static_cast<unsigned char>(__c));
        }


        static bool eq_int_type(const int_type &__c1, const int_type &__c2)         {
            return __c1 == __c2;
        }


        static int_type eof()         {
            return static_cast<int_type>(-1);
        }


        static int_type not_eof(const int_type &__c)         {
            return (__c == eof()) ? 0 : __c;
        }


    }
template <class _CharT = wchar_t> struct char_traits {
        typedef wchar_t char_type;
        typedef wint_t int_type;
        typedef streamoff off_type;
        typedef wstreampos pos_type;
        typedef mbstate_t state_type;
        static void assign(char_type &__c1, const char_type &__c2)         {
            __c1 = __c2;
        }


        static bool eq(const char_type &__c1, const char_type &__c2)         {
            return __c1 == __c2;
        }


        static bool lt(const char_type &__c1, const char_type &__c2)         {
            return __c1 < __c2;
        }


        static int compare(const char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return 0;
            return wmemcmp(__s1, __s2, __n);
        }


        static size_t length(const char_type *__s)         {
            return wcslen(__s);
        }


        static const char_type *find(const char_type *__s, size_t __n, const char_type &__a)         {
            if (__n == 0)
                return 0;
            return wmemchr(__s, __a, __n);
        }


        static char_type *move(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemmove(__s1, __s2, __n);
        }


        static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemcpy(__s1, __s2, __n);
        }


        static char_type *assign(char_type *__s, size_t __n, char_type __a)         {
            if (__n == 0)
                return __s;
            return wmemset(__s, __a, __n);
        }


        static char_type to_char_type(const int_type &__c)         {
            return char_type(__c);
        }


        static int_type to_int_type(const char_type &__c)         {
            return int_type(__c);
        }


        static bool eq_int_type(const int_type &__c1, const int_type &__c2)         {
            return __c1 == __c2;
        }


        static int_type eof()         {
            return static_cast<int_type>((4294967295U));
        }


        static int_type not_eof(const int_type &__c)         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }


    }
template <class _CharT> struct char_traits;
    struct char_traits;
    struct char_traits;
    inline namespace __cxx11 {
        template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> class basic_string {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char> >::rebind<char>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char> traits_type;
            typedef typename char_traits<char>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char> > iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char> > const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        private:
            typedef iterator __const_iterator;
            struct _Alloc_hider : allocator_type {
                _Alloc_hider(pointer __dat, const std::allocator<char> &__a) : allocator_type(__a), _M_p(__dat)                 {
                }


                pointer _M_p;
            };
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char)
            };
            union {
                char _M_local_buf[16];
                size_type _M_allocated_capacity;
            };
            void _M_data(pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }


            void _M_length(size_type __length)             {
                this->_M_string_length = __length;
            }


            pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }


            pointer _M_local_data()             {
                return pointer(this->_M_local_buf);
            }


            const_pointer _M_local_data() const             {
                return const_pointer(this->_M_local_buf);
            }


            void _M_capacity(size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }


            void _M_set_length(size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char());
            }


            bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }


            pointer _M_create(size_type &, size_type);
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }


            void _M_destroy(size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }


            template <typename _InIterator = char *> void _M_construct_aux(char *__beg, char *__end, std::__false_type)             {
                typedef typename iterator_traits<char *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }

template <typename _InIterator = const char *> void _M_construct_aux(const char *__beg, const char *__end, std::__false_type)             {
                typedef typename iterator_traits<const char *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }

template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template <typename _Integer = char *> void _M_construct_aux(char *__beg, char *__end, std::__true_type)template <typename _Integer = const char *> void _M_construct_aux(const char *__beg, const char *__end, std::__true_type)template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(size_type __req, char __c);
            template <typename _InIterator = char *> void _M_construct(char *__beg, char *__end)             {
                typedef typename std::__is_integer<char *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }

template <typename _InIterator = const char *> void _M_construct(const char *__beg, const char *__end)             {
                typedef typename std::__is_integer<const char *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }

template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template <typename _InIterator = char *> void _M_construct(char *__beg, char *__end, std::input_iterator_tag)template <typename _InIterator = const char *> void _M_construct(const char *__beg, const char *__end, std::input_iterator_tag)template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template <typename _FwdIterator = char *> void _M_construct(char *__beg, char *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }

template <typename _FwdIterator = const char *> void _M_construct(const char *__beg, const char *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }

template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            void _M_construct(size_type __req, char __c);
            allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }


            const allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }


        private:
            size_type _M_check(size_type __pos, const char *__s) const;
            void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            size_type _M_limit(size_type __pos, size_type __off) const;
            bool _M_disjunct(const char *__s) const;
            static void _S_copy(char *__d, const char *__s, size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }


            static void _S_move(char *__d, const char *__s, size_type __n);
            static void _S_assign(char *__d, size_type __n, char __c);
            template <class _Iterator = char *> static void _S_copy_chars(char *__p, char *__k1, char *__k2)template <class _Iterator = const char *> static void _S_copy_chars(char *__p, const char *__k1, const char *__k2)template <class _Iterator> static void _S_copy_chars(char *__p, _Iterator __k1, _Iterator __k2);
            static void _S_copy_chars(char *__p, iterator __k1, iterator __k2);
            static void _S_copy_chars(char *__p, const_iterator __k1, const_iterator __k2);
            static void _S_copy_chars(char *__p, char *__k1, char *__k2)             {
                _S_copy(__p, __k1, __k2 - __k1);
            }


            static void _S_copy_chars(char *__p, const char *__k1, const char *__k2)             {
                _S_copy(__p, __k1, __k2 - __k1);
            }


            static int _S_compare(size_type __n1, size_type __n2);
            void _M_assign(const std::__cxx11::basic_string<char> &__rcs);
            void _M_mutate(size_type __pos, size_type __len1, const char *__s, size_type __len2);
            void _M_erase(size_type __pos, size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char> &__a);
            basic_string(const std::__cxx11::basic_string<char> &__str) : _M_dataplus(this->_M_local_data(), __str._M_get_allocator())             {
                this->_M_construct(__str._M_data(), __str._M_data() + __str.length());
            }


            basic_string(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n);
            basic_string(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n, const std::allocator<char> &__a);
            basic_string(const char *__s, size_type __n, const std::allocator<char> &__a);
            basic_string(const char *__s, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__s, __s ? __s + traits_type::length(__s) : __s + npos);
            }


            basic_string(size_type __n, char __c, const std::allocator<char> &__a);
            template <typename _InputIterator> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char> &__a);
            ~std::__cxx11::basic_string<char>()             {
                this->_M_dispose();
            }


            std::__cxx11::basic_string<char> &operator=(const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &operator=(const char *__s);
            std::__cxx11::basic_string<char> &operator=(char __c);
            iterator begin();
            const_iterator begin() const;
            iterator end();
            const_iterator end() const;
            reverse_iterator rbegin();
            const_reverse_iterator rbegin() const;
            reverse_iterator rend();
            const_reverse_iterator rend() const;
        public:
            size_type size() const             {
                return this->_M_string_length;
            }


            size_type length() const             {
                return this->_M_string_length;
            }


            size_type max_size() const;
            void resize(size_type __n, char __c);
            void resize(size_type __n);
            size_type capacity() const;
            void reserve(size_type __res_arg);
            void clear();
            bool empty() const;
            const_reference operator[](size_type __pos) const;
            reference operator[](size_type __pos);
            const_reference at(size_type __n) const;
            reference at(size_type __n);
            std::__cxx11::basic_string<char> &operator+=(const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &operator+=(const char *__s);
            std::__cxx11::basic_string<char> &operator+=(char __c);
            std::__cxx11::basic_string<char> &append(const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &append(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n);
            std::__cxx11::basic_string<char> &append(const char *__s, size_type __n);
            std::__cxx11::basic_string<char> &append(const char *__s);
            std::__cxx11::basic_string<char> &append(size_type __n, char __c);
            template <class _InputIterator> std::__cxx11::basic_string<char> &append(_InputIterator __first, _InputIterator __last);
            void push_back(char __c);
            std::__cxx11::basic_string<char> &assign(const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &assign(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n);
            std::__cxx11::basic_string<char> &assign(const char *__s, size_type __n);
            std::__cxx11::basic_string<char> &assign(const char *__s);
            std::__cxx11::basic_string<char> &assign(size_type __n, char __c);
            template <class _InputIterator> std::__cxx11::basic_string<char> &assign(_InputIterator __first, _InputIterator __last);
            void insert(iterator __p, size_type __n, char __c);
            template <class _InputIterator> void insert(iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<char> &insert(size_type __pos1, const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &insert(size_type __pos1, const std::__cxx11::basic_string<char> &__str, size_type __pos2, size_type __n);
            std::__cxx11::basic_string<char> &insert(size_type __pos, const char *__s, size_type __n);
            std::__cxx11::basic_string<char> &insert(size_type __pos, const char *__s);
            std::__cxx11::basic_string<char> &insert(size_type __pos, size_type __n, char __c);
            iterator insert(__const_iterator __p, char __c);
            std::__cxx11::basic_string<char> &erase(size_type __pos, size_type __n);
            iterator erase(__const_iterator __position);
            iterator erase(__const_iterator __first, __const_iterator __last);
            std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n, const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &replace(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<char> &__str, size_type __pos2, size_type __n2);
            std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n1, const char *__s, size_type __n2);
            std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n1, const char *__s);
            std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n1, size_type __n2, char __c);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__s, size_type __n);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__s);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, char __c);
            template <class _InputIterator> std::__cxx11::basic_string<char> &replace(iterator __i1, iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, char *__k1, char *__k2);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__k1, const char *__k2);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
        private:
            template <class _Integer> std::__cxx11::basic_string<char> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<char> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<char> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, char __c);
            std::__cxx11::basic_string<char> &_M_replace(size_type __pos, size_type __len1, const char *__s, const size_type __len2);
            std::__cxx11::basic_string<char> &_M_append(const char *__s, size_type __n);
        public:
            size_type copy(char *__s, size_type __n, size_type __pos) const;
            void swap(std::__cxx11::basic_string<char> &__s);
            const char *c_str() const;
            const char *data() const             {
                return this->_M_data();
            }


            allocator_type get_allocator() const;
            size_type find(const char *__s, size_type __pos, size_type __n) const;
            size_type find(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type find(const char *__s, size_type __pos) const;
            size_type find(char __c, size_type __pos) const;
            size_type rfind(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type rfind(const char *__s, size_type __pos, size_type __n) const;
            size_type rfind(const char *__s, size_type __pos) const;
            size_type rfind(char __c, size_type __pos) const;
            size_type find_first_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type find_first_of(const char *__s, size_type __pos, size_type __n) const;
            size_type find_first_of(const char *__s, size_type __pos) const;
            size_type find_first_of(char __c, size_type __pos) const;
            size_type find_last_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type find_last_of(const char *__s, size_type __pos, size_type __n) const;
            size_type find_last_of(const char *__s, size_type __pos) const;
            size_type find_last_of(char __c, size_type __pos) const;
            size_type find_first_not_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type find_first_not_of(const char *__s, size_type __pos, size_type __n) const;
            size_type find_first_not_of(const char *__s, size_type __pos) const;
            size_type find_first_not_of(char __c, size_type __pos) const;
            size_type find_last_not_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type find_last_not_of(const char *__s, size_type __pos, size_type __n) const;
            size_type find_last_not_of(const char *__s, size_type __pos) const;
            size_type find_last_not_of(char __c, size_type __pos) const;
            std::__cxx11::basic_string<char> substr(size_type __pos, size_type __n) const;
            int compare(const std::__cxx11::basic_string<char> &__str) const;
            int compare(size_type __pos, size_type __n, const std::__cxx11::basic_string<char> &__str) const;
            int compare(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<char> &__str, size_type __pos2, size_type __n2) const;
            int compare(const char *__s) const;
            int compare(size_type __pos, size_type __n1, const char *__s) const;
            int compare(size_type __pos, size_type __n1, const char *__s, size_type __n2) const;
        }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> class basic_string {
            typedef typename __gnu_cxx::__alloc_traits<allocator<wchar_t> >::rebind<wchar_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef typename char_traits<wchar_t>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<wchar_t> > iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<wchar_t> > const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        private:
            typedef iterator __const_iterator;
            struct _Alloc_hider : allocator_type {
                _Alloc_hider(pointer __dat, const std::allocator<wchar_t> &__a);
                pointer _M_p;
            };
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::_Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(wchar_t)
            };
            union {
                wchar_t _M_local_buf[4];
                size_type _M_allocated_capacity;
            };
            void _M_data(pointer __p);
            void _M_length(size_type __length);
            pointer _M_data() const;
            pointer _M_local_data();
            const_pointer _M_local_data() const;
            void _M_capacity(size_type __capacity);
            void _M_set_length(size_type __n);
            bool _M_is_local() const;
            pointer _M_create(size_type &, size_type);
            void _M_dispose();
            void _M_destroy(size_type __size) throw();
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(size_type __req, wchar_t __c);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            void _M_construct(size_type __req, wchar_t __c);
            allocator_type &_M_get_allocator();
            const allocator_type &_M_get_allocator() const;
        private:
            size_type _M_check(size_type __pos, const char *__s) const;
            void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            size_type _M_limit(size_type __pos, size_type __off) const;
            bool _M_disjunct(const wchar_t *__s) const;
            static void _S_copy(wchar_t *__d, const wchar_t *__s, size_type __n);
            static void _S_move(wchar_t *__d, const wchar_t *__s, size_type __n);
            static void _S_assign(wchar_t *__d, size_type __n, wchar_t __c);
            template <class _Iterator> static void _S_copy_chars(wchar_t *__p, _Iterator __k1, _Iterator __k2);
            static void _S_copy_chars(wchar_t *__p, iterator __k1, iterator __k2);
            static void _S_copy_chars(wchar_t *__p, const_iterator __k1, const_iterator __k2);
            static void _S_copy_chars(wchar_t *__p, wchar_t *__k1, wchar_t *__k2);
            static void _S_copy_chars(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2);
            static int _S_compare(size_type __n1, size_type __n2);
            void _M_assign(const std::__cxx11::basic_string<wchar_t> &__rcs);
            void _M_mutate(size_type __pos, size_type __len1, const wchar_t *__s, size_type __len2);
            void _M_erase(size_type __pos, size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<wchar_t> &__a);
            basic_string(const std::__cxx11::basic_string<wchar_t> &__str);
            basic_string(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            basic_string(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n, const std::allocator<wchar_t> &__a);
            basic_string(const wchar_t *__s, size_type __n, const std::allocator<wchar_t> &__a);
            basic_string(const wchar_t *__s, const std::allocator<wchar_t> &__a);
            basic_string(size_type __n, wchar_t __c, const std::allocator<wchar_t> &__a);
            template <typename _InputIterator> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<wchar_t> &__a);
            ~std::__cxx11::basic_string<wchar_t>();
            std::__cxx11::basic_string<wchar_t> &operator=(const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &operator=(const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &operator=(wchar_t __c);
            iterator begin();
            const_iterator begin() const;
            iterator end();
            const_iterator end() const;
            reverse_iterator rbegin();
            const_reverse_iterator rbegin() const;
            reverse_iterator rend();
            const_reverse_iterator rend() const;
        public:
            size_type size() const;
            size_type length() const;
            size_type max_size() const;
            void resize(size_type __n, wchar_t __c);
            void resize(size_type __n);
            size_type capacity() const;
            void reserve(size_type __res_arg);
            void clear();
            bool empty() const;
            const_reference operator[](size_type __pos) const;
            reference operator[](size_type __pos);
            const_reference at(size_type __n) const;
            reference at(size_type __n);
            std::__cxx11::basic_string<wchar_t> &operator+=(const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &operator+=(const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &operator+=(wchar_t __c);
            std::__cxx11::basic_string<wchar_t> &append(const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &append(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            std::__cxx11::basic_string<wchar_t> &append(const wchar_t *__s, size_type __n);
            std::__cxx11::basic_string<wchar_t> &append(const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &append(size_type __n, wchar_t __c);
            template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &append(_InputIterator __first, _InputIterator __last);
            void push_back(wchar_t __c);
            std::__cxx11::basic_string<wchar_t> &assign(const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &assign(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            std::__cxx11::basic_string<wchar_t> &assign(const wchar_t *__s, size_type __n);
            std::__cxx11::basic_string<wchar_t> &assign(const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &assign(size_type __n, wchar_t __c);
            template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &assign(_InputIterator __first, _InputIterator __last);
            void insert(iterator __p, size_type __n, wchar_t __c);
            template <class _InputIterator> void insert(iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<wchar_t> &insert(size_type __pos1, const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &insert(size_type __pos1, const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos2, size_type __n);
            std::__cxx11::basic_string<wchar_t> &insert(size_type __pos, const wchar_t *__s, size_type __n);
            std::__cxx11::basic_string<wchar_t> &insert(size_type __pos, const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &insert(size_type __pos, size_type __n, wchar_t __c);
            iterator insert(__const_iterator __p, wchar_t __c);
            std::__cxx11::basic_string<wchar_t> &erase(size_type __pos, size_type __n);
            iterator erase(__const_iterator __position);
            iterator erase(__const_iterator __first, __const_iterator __last);
            std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n, const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &replace(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2);
            std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const wchar_t *__s, size_type __n2);
            std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, size_type __n2, wchar_t __c);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__s, size_type __n);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, wchar_t __c);
            template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &replace(iterator __i1, iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, wchar_t *__k1, wchar_t *__k2);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__k1, const wchar_t *__k2);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
        private:
            template <class _Integer> std::__cxx11::basic_string<wchar_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<wchar_t> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, wchar_t __c);
            std::__cxx11::basic_string<wchar_t> &_M_replace(size_type __pos, size_type __len1, const wchar_t *__s, const size_type __len2);
            std::__cxx11::basic_string<wchar_t> &_M_append(const wchar_t *__s, size_type __n);
        public:
            size_type copy(wchar_t *__s, size_type __n, size_type __pos) const;
            void swap(std::__cxx11::basic_string<wchar_t> &__s);
            const wchar_t *c_str() const;
            const wchar_t *data() const;
            allocator_type get_allocator() const;
            size_type find(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type find(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type find(const wchar_t *__s, size_type __pos) const;
            size_type find(wchar_t __c, size_type __pos) const;
            size_type rfind(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type rfind(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type rfind(const wchar_t *__s, size_type __pos) const;
            size_type rfind(wchar_t __c, size_type __pos) const;
            size_type find_first_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type find_first_of(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type find_first_of(const wchar_t *__s, size_type __pos) const;
            size_type find_first_of(wchar_t __c, size_type __pos) const;
            size_type find_last_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type find_last_of(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type find_last_of(const wchar_t *__s, size_type __pos) const;
            size_type find_last_of(wchar_t __c, size_type __pos) const;
            size_type find_first_not_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type find_first_not_of(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type find_first_not_of(const wchar_t *__s, size_type __pos) const;
            size_type find_first_not_of(wchar_t __c, size_type __pos) const;
            size_type find_last_not_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type find_last_not_of(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type find_last_not_of(const wchar_t *__s, size_type __pos) const;
            size_type find_last_not_of(wchar_t __c, size_type __pos) const;
            std::__cxx11::basic_string<wchar_t> substr(size_type __pos, size_type __n) const;
            int compare(const std::__cxx11::basic_string<wchar_t> &__str) const;
            int compare(size_type __pos, size_type __n, const std::__cxx11::basic_string<wchar_t> &__str) const;
            int compare(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2) const;
            int compare(const wchar_t *__s) const;
            int compare(size_type __pos, size_type __n1, const wchar_t *__s) const;
            int compare(size_type __pos, size_type __n1, const wchar_t *__s, size_type __n2) const;
        }
template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string;
        typedef basic_string<char> string;
        typedef basic_string<wchar_t> wstring;
    }
}
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef struct _IO_FILE __FILE;
typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned long size_t;
typedef unsigned int wint_t;
struct {
    int __count;
    union {
        unsigned int __wch;
        char __wchb[4];
    } __value;
} typedef __mbstate_t;
typedef __mbstate_t mbstate_t;
extern "C" {
    struct tm;
    extern wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __attribute__((nonnull(0, 1)));
    extern wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw() __attribute__((nonnull(0, 1)));
    extern wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __attribute__((nonnull(0, 1)));
    extern wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw() __attribute__((nonnull(0, 1)));
    extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) throw() __attribute__((nonnull(0, 1))) __attribute__((pure));
    extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw() __attribute__((nonnull(0, 1))) __attribute__((pure));
    extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) throw();
    extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw();
    struct __locale_struct {
        struct __locale_data;
        struct __locale_data *__locales[13];
        const unsigned short *__ctype_b;
        const int *__ctype_tolower;
        const int *__ctype_toupper;
        const char *__names[13];
    };
    typedef struct __locale_struct *__locale_t;
    typedef __locale_t locale_t;
    extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, __locale_t __loc) throw();
    extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, size_t __n, __locale_t __loc) throw();
    extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) throw();
    extern size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2, __locale_t __loc) throw();
    extern size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, size_t __n, __locale_t __loc) throw();
    extern wchar_t *wcsdup(const wchar_t *__s) throw() __attribute__((malloc));
    extern wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) throw() __attribute__((pure));
    extern wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) throw() __attribute__((pure));
    extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) throw() __attribute__((pure));
    extern size_t wcscspn(const wchar_t *__wcs, const wchar_t *__reject) throw() __attribute__((pure));
    extern size_t wcsspn(const wchar_t *__wcs, const wchar_t *__accept) throw() __attribute__((pure));
    extern wchar_t *wcspbrk(const wchar_t *__wcs, const wchar_t *__accept) throw() __attribute__((pure));
    extern wchar_t *wcsstr(const wchar_t *__haystack, const wchar_t *__needle) throw() __attribute__((pure));
    extern wchar_t *wcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) throw();
    extern size_t wcslen(const wchar_t *__s) throw() __attribute__((pure));
    extern wchar_t *wcswcs(const wchar_t *__haystack, const wchar_t *__needle) throw() __attribute__((pure));
    extern size_t wcsnlen(const wchar_t *__s, size_t __maxlen) throw() __attribute__((pure));
    extern wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) throw() __attribute__((pure));
    extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw() __attribute__((pure));
    extern wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, size_t __n) throw();
    extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, size_t __n) throw();
    extern wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern wint_t btowc(int __c) throw();
    extern int wctob(wint_t __c) throw();
    extern int mbsinit(const mbstate_t *__ps) throw() __attribute__((pure));
    extern size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n, mbstate_t *__restrict __p) throw();
    extern size_t wcrtomb(char *__restrict __s, wchar_t __wc, mbstate_t *__restrict __ps) throw();
    extern size_t __mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw();
    extern size_t mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw();
    extern size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) throw();
    extern int wcwidth(wchar_t __c) throw();
    extern int wcswidth(const wchar_t *__s, size_t __n) throw();
    extern double wcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern float wcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern long double wcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern long wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long long wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long long wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long long wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long long wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, __locale_t __loc) throw();
    extern unsigned long wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, __locale_t __loc) throw();
    extern long long wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, __locale_t __loc) throw();
    extern unsigned long long wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, __locale_t __loc) throw();
    extern double wcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, __locale_t __loc) throw();
    extern float wcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, __locale_t __loc) throw();
    extern long double wcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, __locale_t __loc) throw();
    extern wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
    extern wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw();
    extern __FILE *open_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) throw();
    extern int fwide(__FILE *__fp, int __mode) throw();
    extern int fwprintf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wprintf(const wchar_t *__restrict __format, ...);
    extern int swprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, ...) throw();
    extern int vfwprintf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwprintf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw();
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wscanf(const wchar_t *__restrict __format, ...);
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw();
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw();
    extern wint_t fgetwc(__FILE *__stream);
    extern wint_t getwc(__FILE *__stream);
    extern wint_t getwchar();
    extern wint_t fputwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar(wchar_t __wc);
    extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern wint_t ungetwc(wint_t __wc, __FILE *__stream);
    extern wint_t getwc_unlocked(__FILE *__stream);
    extern wint_t getwchar_unlocked();
    extern wint_t fgetwc_unlocked(__FILE *__stream);
    extern wint_t fputwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar_unlocked(wchar_t __wc);
    extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws_unlocked(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern size_t wcsftime(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp) throw();
    extern size_t wcsftime_l(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp, __locale_t __loc) throw();
}
namespace std {
    using ::mbstate_t;
}
namespace std {
    using ::wint_t;
    using ::btowc;
    using ::fgetwc;
    using ::fgetws;
    using ::fputwc;
    using ::fputws;
    using ::fwide;
    using ::fwprintf;
    using ::fwscanf;
    using ::getwc;
    using ::getwchar;
    using ::mbrlen;
    using ::mbrtowc;
    using ::mbsinit;
    using ::mbsrtowcs;
    using ::putwc;
    using ::putwchar;
    using ::swprintf;
    using ::swscanf;
    using ::ungetwc;
    using ::vfwprintf;
    using ::vfwscanf;
    using ::vswprintf;
    using ::vswscanf;
    using ::vwprintf;
    using ::vwscanf;
    using ::wcrtomb;
    using ::wcscat;
    using ::wcscmp;
    using ::wcscoll;
    using ::wcscpy;
    using ::wcscspn;
    using ::wcsftime;
    using ::wcslen;
    using ::wcsncat;
    using ::wcsncmp;
    using ::wcsncpy;
    using ::wcsrtombs;
    using ::wcsspn;
    using ::wcstod;
    using ::wcstof;
    using ::wcstok;
    using ::wcstol;
    using ::wcstoul;
    using ::wcsxfrm;
    using ::wctob;
    using ::wmemcmp;
    using ::wmemcpy;
    using ::wmemmove;
    using ::wmemset;
    using ::wprintf;
    using ::wscanf;
    using ::wcschr;
    using ::wcspbrk;
    using ::wcsrchr;
    using ::wcsstr;
    using ::wmemchr;
    inline wchar_t *wcschr(wchar_t *__p, wchar_t __c)     {
        return wcschr(const_cast<const wchar_t *>(__p), __c);
    }


    inline wchar_t *wcspbrk(wchar_t *__s1, const wchar_t *__s2)     {
        return wcspbrk(const_cast<const wchar_t *>(__s1), __s2);
    }


    inline wchar_t *wcsrchr(wchar_t *__p, wchar_t __c)     {
        return wcsrchr(const_cast<const wchar_t *>(__p), __c);
    }


    inline wchar_t *wcsstr(wchar_t *__s1, const wchar_t *__s2)     {
        return wcsstr(const_cast<const wchar_t *>(__s1), __s2);
    }


    inline wchar_t *wmemchr(wchar_t *__p, wchar_t __c, size_t __n)     {
        return wmemchr(const_cast<const wchar_t *>(__p), __c, __n);
    }


}
namespace __gnu_cxx {
    using ::wcstold;
    using ::wcstoll;
    using ::wcstoull;
}
namespace std {
    using ::__gnu_cxx::wcstold;
    using ::__gnu_cxx::wcstoll;
    using ::__gnu_cxx::wcstoull;
}
namespace std {
    typedef long streamoff;
    typedef ptrdiff_t streamsize;
    template <typename _StateT = __mbstate_t> class fpos
template <typename _StateT> class fpos {
    private:
        streamoff _M_off;
        _StateT _M_state;
    public:
        fpos<_StateT>() : _M_off(0), _M_state()         {
        }


        fpos<_StateT>(streamoff __off) : _M_off(__off), _M_state()         {
        }


        operator streamoff() const         {
            return this->_M_off;
        }


        void state(_StateT __st)         {
            this->_M_state = __st;
        }


        _StateT state() const         {
            return this->_M_state;
        }


        fpos<_StateT> &operator+=(streamoff __off)         {
            this->_M_off += __off;
            return *this;
        }


        fpos<_StateT> &operator-=(streamoff __off)         {
            this->_M_off -= __off;
            return *this;
        }


        fpos<_StateT> operator+(streamoff __off) const         {
            fpos<_StateT> __pos(*this);
            __pos += __off;
            return __pos;
        }


        fpos<_StateT> operator-(streamoff __off) const         {
            fpos<_StateT> __pos(*this);
            __pos -= __off;
            return __pos;
        }


        streamoff operator-(const fpos<_StateT> &__other) const         {
            return this->_M_off - __other._M_off;
        }


    };
    template <typename _StateT> inline bool operator==(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs)     {
        return streamoff(__lhs) == streamoff(__rhs);
    }

;
    template <typename _StateT> inline bool operator!=(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs)     {
        return streamoff(__lhs) != streamoff(__rhs);
    }

;
    typedef fpos<mbstate_t> streampos;
    typedef fpos<mbstate_t> wstreampos;
}
namespace std {
    class ios_base;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_ios : public std::ios_base {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef ctype<char> __ctype_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char> > > __num_put_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char> > > __num_get_type;
    protected:
        basic_ostream<char, std::char_traits<char> > *_M_tie;
        mutable char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<char, std::char_traits<char> > *_M_streambuf;
        const __ctype_type *_M_ctype;
        const __num_put_type *_M_num_put;
        const __num_get_type *_M_num_get;
    public:
        operator void *() const;
        bool operator!() const;
        iostate rdstate() const         {
            return this->_M_streambuf_state;
        }


        void clear(iostate __state);
        void setstate(iostate __state)         {
            this->clear(this->rdstate() | __state);
        }


        void _M_setstate(iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        iostate exceptions() const;
        void exceptions(iostate __except);
        explicit basic_ios(basic_streambuf<char, std::char_traits<char> > *__sb);
        virtual ~std::basic_ios<char>();
        basic_ostream<char, std::char_traits<char> > *tie() const;
        basic_ostream<char, std::char_traits<char> > *tie(basic_ostream<char, std::char_traits<char> > *__tiestr);
        basic_streambuf<char, std::char_traits<char> > *rdbuf() const;
        basic_streambuf<char, std::char_traits<char> > *rdbuf(basic_streambuf<char, std::char_traits<char> > *__sb);
        std::basic_ios<char> &copyfmt(const std::basic_ios<char> &__rhs);
        char_type fill() const;
        char_type fill(char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(char_type __c, char __dfault) const;
        char_type widen(char __c) const         {
            return __check_facet(this->_M_ctype).widen(__c);
        }


    protected:
        basic_ios();
        void init(basic_streambuf<char, std::char_traits<char> > *__sb);
        void _M_cache_locale(const std::locale &__loc);
    }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_ios : public std::ios_base {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef ctype<wchar_t> __ctype_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_put_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_get_type;
    protected:
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *_M_tie;
        mutable char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *_M_streambuf;
        const __ctype_type *_M_ctype;
        const __num_put_type *_M_num_put;
        const __num_get_type *_M_num_get;
    public:
        operator void *() const;
        bool operator!() const;
        iostate rdstate() const;
        void clear(iostate __state);
        void setstate(iostate __state);
        void _M_setstate(iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        iostate exceptions() const;
        void exceptions(iostate __except);
        explicit basic_ios(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        virtual ~std::basic_ios<wchar_t>();
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *tie() const;
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *tie(basic_ostream<wchar_t, std::char_traits<wchar_t> > *__tiestr);
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *rdbuf() const;
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *rdbuf(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        std::basic_ios<wchar_t> &copyfmt(const std::basic_ios<wchar_t> &__rhs);
        char_type fill() const;
        char_type fill(char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(char_type __c, char __dfault) const;
        char_type widen(char __c) const;
    protected:
        basic_ios();
        void init(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        void _M_cache_locale(const std::locale &__loc);
    }
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_streambuf {
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<char_type, traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend streamsize __copy_streambufs_eof(std::basic_streambuf<char> *, std::basic_streambuf<char> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>> basic_istream<char> &operator>>(basic_istream<char> &__in, char *__s)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, wchar_t *__s)template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &operator>>(basic_istream<char> &__is, basic_string<char> &__str)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > &__str)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &getline(basic_istream<char> &__in, basic_string<char> &__str, char __delim)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t> &getline(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        char_type *_M_in_beg;
        char_type *_M_in_cur;
        char_type *_M_in_end;
        char_type *_M_out_beg;
        char_type *_M_out_cur;
        char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~std::basic_streambuf<char>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<char> *pubsetbuf(char_type *__s, streamsize __n);
        pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        pos_type pubseekpos(pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        streamsize in_avail();
        int_type snextc();
        int_type sbumpc();
        int_type sgetc();
        streamsize sgetn(char_type *__s, streamsize __n);
        int_type sputbackc(char_type __c);
        int_type sungetc();
        int_type sputc(char_type __c);
        streamsize sputn(const char_type *__s, streamsize __n);
    protected:
        basic_streambuf();
        char_type *eback() const;
        char_type *gptr() const;
        char_type *egptr() const;
        void gbump(int __n);
        void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend);
        char_type *pbase() const;
        char_type *pptr() const;
        char_type *epptr() const;
        void pbump(int __n);
        void setp(char_type *__pbeg, char_type *__pend);
        virtual void imbue(const std::locale &__loc);
        virtual basic_streambuf<char_type, std::char_traits<char> > *setbuf(char_type *, streamsize);
        virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode);
        virtual pos_type seekpos(pos_type, ios_base::openmode);
        virtual int sync();
        virtual streamsize showmanyc();
        virtual streamsize xsgetn(char_type *__s, streamsize __n);
        virtual int_type underflow();
        virtual int_type uflow();
        virtual int_type pbackfail(int_type __c);
        virtual streamsize xsputn(const char_type *__s, streamsize __n);
        virtual int_type overflow(int_type __c);
    public:
        void stossc();
        void __safe_gbump(streamsize __n);
        void __safe_pbump(streamsize __n);
    private:
        basic_streambuf(const std::basic_streambuf<char> &);
        std::basic_streambuf<char> &operator=(const std::basic_streambuf<char> &);
    }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_streambuf {
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<char_type, traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend streamsize __copy_streambufs_eof(std::basic_streambuf<wchar_t> *, std::basic_streambuf<wchar_t> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>> basic_istream<char> &operator>>(basic_istream<char> &__in, char *__s)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, wchar_t *__s)template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &operator>>(basic_istream<char> &__is, basic_string<char> &__str)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > &__str)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &getline(basic_istream<char> &__in, basic_string<char> &__str, char __delim)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t> &getline(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        char_type *_M_in_beg;
        char_type *_M_in_cur;
        char_type *_M_in_end;
        char_type *_M_out_beg;
        char_type *_M_out_cur;
        char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~std::basic_streambuf<wchar_t>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<wchar_t> *pubsetbuf(char_type *__s, streamsize __n);
        pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        pos_type pubseekpos(pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        streamsize in_avail();
        int_type snextc();
        int_type sbumpc();
        int_type sgetc();
        streamsize sgetn(char_type *__s, streamsize __n);
        int_type sputbackc(char_type __c);
        int_type sungetc();
        int_type sputc(char_type __c);
        streamsize sputn(const char_type *__s, streamsize __n);
    protected:
        basic_streambuf();
        char_type *eback() const;
        char_type *gptr() const;
        char_type *egptr() const;
        void gbump(int __n);
        void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend);
        char_type *pbase() const;
        char_type *pptr() const;
        char_type *epptr() const;
        void pbump(int __n);
        void setp(char_type *__pbeg, char_type *__pend);
        virtual void imbue(const std::locale &__loc);
        virtual basic_streambuf<char_type, std::char_traits<wchar_t> > *setbuf(char_type *, streamsize);
        virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode);
        virtual pos_type seekpos(pos_type, ios_base::openmode);
        virtual int sync();
        virtual streamsize showmanyc();
        virtual streamsize xsgetn(char_type *__s, streamsize __n);
        virtual int_type underflow();
        virtual int_type uflow();
        virtual int_type pbackfail(int_type __c);
        virtual streamsize xsputn(const char_type *__s, streamsize __n);
        virtual int_type overflow(int_type __c);
    public:
        void stossc();
        void __safe_gbump(streamsize __n);
        void __safe_pbump(streamsize __n);
    private:
        basic_streambuf(const std::basic_streambuf<wchar_t> &);
        std::basic_streambuf<wchar_t> &operator=(const std::basic_streambuf<wchar_t> &);
    }
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_istream : virtual public basic_ios<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
        typedef basic_ios<char, std::char_traits<char> > __ios_type;
        typedef basic_istream<char, std::char_traits<char> > __istream_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char> > > __num_get_type;
        typedef ctype<char> __ctype_type;
    protected:
        streamsize _M_gcount;
    public:
        explicit basic_istream(__streambuf_type *__sb);
        virtual ~std::basic_istream<char>();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<char> traits_type;
            typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
            typedef basic_istream<char, std::char_traits<char> > __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<char>::int_type __int_type;
            explicit sentry(basic_istream<char, std::char_traits<char> > &__is, bool __noskipws);
            operator bool() const;
        };
        friend  class sentry;
        __istream_type &operator>>(__istream_type &(*__pf)(__istream_type &));
        __istream_type &operator>>(__ios_type &(*__pf)(__ios_type &));
        __istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        __istream_type &operator>>(bool &__n);
        __istream_type &operator>>(short &__n);
        __istream_type &operator>>(unsigned short &__n);
        __istream_type &operator>>(int &__n);
        __istream_type &operator>>(unsigned int &__n);
        __istream_type &operator>>(long &__n);
        __istream_type &operator>>(unsigned long &__n);
        __istream_type &operator>>(long long &__n);
        __istream_type &operator>>(unsigned long long &__n);
        __istream_type &operator>>(float &__f);
        __istream_type &operator>>(double &__f);
        __istream_type &operator>>(long double &__f);
        __istream_type &operator>>(void *&__p);
        __istream_type &operator>>(__streambuf_type *__sb);
        streamsize gcount() const;
        int_type get();
        __istream_type &get(char_type &__c);
        __istream_type &get(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &get(char_type *__s, streamsize __n);
        __istream_type &get(__streambuf_type &__sb, char_type __delim);
        __istream_type &get(__streambuf_type &__sb);
        __istream_type &getline(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &getline(char_type *__s, streamsize __n);
        __istream_type &ignore(streamsize __n, int_type __delim);
        __istream_type &ignore(streamsize __n);
        __istream_type &ignore();
        int_type peek();
        __istream_type &read(char_type *__s, streamsize __n);
        streamsize readsome(char_type *__s, streamsize __n);
        __istream_type &putback(char_type __c);
        __istream_type &unget();
        int sync();
        pos_type tellg();
        __istream_type &seekg(pos_type);
        __istream_type &seekg(off_type, ios_base::seekdir);
    protected:
        basic_istream();
        template <typename _ValueT = unsigned short> __istream_type &_M_extract(unsigned short &__v)template <typename _ValueT = unsigned int> __istream_type &_M_extract(unsigned int &__v)template <typename _ValueT = long> __istream_type &_M_extract(long &__v)template <typename _ValueT = unsigned long> __istream_type &_M_extract(unsigned long &__v)template <typename _ValueT = bool> __istream_type &_M_extract(bool &__v)template <typename _ValueT = long long> __istream_type &_M_extract(long long &__v)template <typename _ValueT = unsigned long long> __istream_type &_M_extract(unsigned long long &__v)template <typename _ValueT = float> __istream_type &_M_extract(float &__v)template <typename _ValueT = double> __istream_type &_M_extract(double &__v)template <typename _ValueT = long double> __istream_type &_M_extract(long double &__v)template <typename _ValueT = void *> __istream_type &_M_extract(void *&__v)template <typename _ValueT> __istream_type &_M_extract(_ValueT &__v);
    }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_istream : virtual public basic_ios<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t> > __ios_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_get_type;
        typedef ctype<wchar_t> __ctype_type;
    protected:
        streamsize _M_gcount;
    public:
        explicit basic_istream(__streambuf_type *__sb);
        virtual ~std::basic_istream<wchar_t>();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
            typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<wchar_t>::int_type __int_type;
            explicit sentry(basic_istream<wchar_t, std::char_traits<wchar_t> > &__is, bool __noskipws);
            operator bool() const;
        };
        friend  class sentry;
        __istream_type &operator>>(__istream_type &(*__pf)(__istream_type &));
        __istream_type &operator>>(__ios_type &(*__pf)(__ios_type &));
        __istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        __istream_type &operator>>(bool &__n);
        __istream_type &operator>>(short &__n);
        __istream_type &operator>>(unsigned short &__n);
        __istream_type &operator>>(int &__n);
        __istream_type &operator>>(unsigned int &__n);
        __istream_type &operator>>(long &__n);
        __istream_type &operator>>(unsigned long &__n);
        __istream_type &operator>>(long long &__n);
        __istream_type &operator>>(unsigned long long &__n);
        __istream_type &operator>>(float &__f);
        __istream_type &operator>>(double &__f);
        __istream_type &operator>>(long double &__f);
        __istream_type &operator>>(void *&__p);
        __istream_type &operator>>(__streambuf_type *__sb);
        streamsize gcount() const;
        int_type get();
        __istream_type &get(char_type &__c);
        __istream_type &get(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &get(char_type *__s, streamsize __n);
        __istream_type &get(__streambuf_type &__sb, char_type __delim);
        __istream_type &get(__streambuf_type &__sb);
        __istream_type &getline(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &getline(char_type *__s, streamsize __n);
        __istream_type &ignore(streamsize __n, int_type __delim);
        __istream_type &ignore(streamsize __n);
        __istream_type &ignore();
        int_type peek();
        __istream_type &read(char_type *__s, streamsize __n);
        streamsize readsome(char_type *__s, streamsize __n);
        __istream_type &putback(char_type __c);
        __istream_type &unget();
        int sync();
        pos_type tellg();
        __istream_type &seekg(pos_type);
        __istream_type &seekg(off_type, ios_base::seekdir);
    protected:
        basic_istream();
        template <typename _ValueT = unsigned short> __istream_type &_M_extract(unsigned short &__v)template <typename _ValueT = unsigned int> __istream_type &_M_extract(unsigned int &__v)template <typename _ValueT = long> __istream_type &_M_extract(long &__v)template <typename _ValueT = unsigned long> __istream_type &_M_extract(unsigned long &__v)template <typename _ValueT = bool> __istream_type &_M_extract(bool &__v)template <typename _ValueT = long long> __istream_type &_M_extract(long long &__v)template <typename _ValueT = unsigned long long> __istream_type &_M_extract(unsigned long long &__v)template <typename _ValueT = float> __istream_type &_M_extract(float &__v)template <typename _ValueT = double> __istream_type &_M_extract(double &__v)template <typename _ValueT = long double> __istream_type &_M_extract(long double &__v)template <typename _ValueT = void *> __istream_type &_M_extract(void *&__v)template <typename _ValueT> __istream_type &_M_extract(_ValueT &__v);
    }
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_ostream : virtual public basic_ios<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
        typedef basic_ios<char, std::char_traits<char> > __ios_type;
        typedef basic_ostream<char, std::char_traits<char> > __ostream_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char> > > __num_put_type;
        typedef ctype<char> __ctype_type;
        explicit basic_ostream(__streambuf_type *__sb);
        virtual ~std::basic_ostream<char>();
        class sentry {
            bool _M_ok;
            basic_ostream<char, std::char_traits<char> > &_M_os;
        public:
            explicit sentry(basic_ostream<char, std::char_traits<char> > &__os);
            ~std::basic_ostream<char, std::char_traits<char> >::sentry();
            operator bool() const;
        };
        friend  class sentry;
        __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &))         {
            return __pf(*this);
        }


        __ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &));
        __ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        __ostream_type &operator<<(long __n);
        __ostream_type &operator<<(unsigned long __n);
        __ostream_type &operator<<(bool __n);
        __ostream_type &operator<<(short __n);
        __ostream_type &operator<<(unsigned short __n);
        __ostream_type &operator<<(int __n);
        __ostream_type &operator<<(unsigned int __n);
        __ostream_type &operator<<(long long __n);
        __ostream_type &operator<<(unsigned long long __n);
        __ostream_type &operator<<(double __f);
        __ostream_type &operator<<(float __f);
        __ostream_type &operator<<(long double __f);
        __ostream_type &operator<<(const void *__p);
        __ostream_type &operator<<(__streambuf_type *__sb);
        __ostream_type &put(char_type __c);
        void _M_write(const char_type *__s, streamsize __n);
        __ostream_type &write(const char_type *__s, streamsize __n);
        __ostream_type &flush();
        pos_type tellp();
        __ostream_type &seekp(pos_type);
        __ostream_type &seekp(off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        template <typename _ValueT = long> __ostream_type &_M_insert(long __v)template <typename _ValueT = unsigned long> __ostream_type &_M_insert(unsigned long __v)template <typename _ValueT = bool> __ostream_type &_M_insert(bool __v)template <typename _ValueT = long long> __ostream_type &_M_insert(long long __v)template <typename _ValueT = unsigned long long> __ostream_type &_M_insert(unsigned long long __v)template <typename _ValueT = double> __ostream_type &_M_insert(double __v)template <typename _ValueT = long double> __ostream_type &_M_insert(long double __v)template <typename _ValueT = const void *> __ostream_type &_M_insert(const void *__v)template <typename _ValueT> __ostream_type &_M_insert(_ValueT __v);
    }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_ostream : virtual public basic_ios<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t> > __ios_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t> > __ostream_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_put_type;
        typedef ctype<wchar_t> __ctype_type;
        explicit basic_ostream(__streambuf_type *__sb);
        virtual ~std::basic_ostream<wchar_t>();
        class sentry {
            bool _M_ok;
            basic_ostream<wchar_t, std::char_traits<wchar_t> > &_M_os;
        public:
            explicit sentry(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__os);
            ~std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::sentry();
            operator bool() const;
        };
        friend  class sentry;
        __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &));
        __ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &));
        __ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        __ostream_type &operator<<(long __n);
        __ostream_type &operator<<(unsigned long __n);
        __ostream_type &operator<<(bool __n);
        __ostream_type &operator<<(short __n);
        __ostream_type &operator<<(unsigned short __n);
        __ostream_type &operator<<(int __n);
        __ostream_type &operator<<(unsigned int __n);
        __ostream_type &operator<<(long long __n);
        __ostream_type &operator<<(unsigned long long __n);
        __ostream_type &operator<<(double __f);
        __ostream_type &operator<<(float __f);
        __ostream_type &operator<<(long double __f);
        __ostream_type &operator<<(const void *__p);
        __ostream_type &operator<<(__streambuf_type *__sb);
        __ostream_type &put(char_type __c);
        void _M_write(const char_type *__s, streamsize __n);
        __ostream_type &write(const char_type *__s, streamsize __n);
        __ostream_type &flush();
        pos_type tellp();
        __ostream_type &seekp(pos_type);
        __ostream_type &seekp(off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        template <typename _ValueT = long> __ostream_type &_M_insert(long __v)template <typename _ValueT = unsigned long> __ostream_type &_M_insert(unsigned long __v)template <typename _ValueT = bool> __ostream_type &_M_insert(bool __v)template <typename _ValueT = long long> __ostream_type &_M_insert(long long __v)template <typename _ValueT = unsigned long long> __ostream_type &_M_insert(unsigned long long __v)template <typename _ValueT = double> __ostream_type &_M_insert(double __v)template <typename _ValueT = long double> __ostream_type &_M_insert(long double __v)template <typename _ValueT = const void *> __ostream_type &_M_insert(const void *__v)template <typename _ValueT> __ostream_type &_M_insert(_ValueT __v);
    }
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_iostream : public basic_istream<char, std::char_traits<char> >, public basic_ostream<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_istream<char, std::char_traits<char> > __istream_type;
        typedef basic_ostream<char, std::char_traits<char> > __ostream_type;
        explicit basic_iostream(basic_streambuf<char, std::char_traits<char> > *__sb);
        virtual ~std::basic_iostream<char>();
    protected:
        basic_iostream();
    }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_iostream : public basic_istream<wchar_t, std::char_traits<wchar_t> >, public basic_ostream<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t> > __ostream_type;
        explicit basic_iostream(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        virtual ~std::basic_iostream<wchar_t>();
    protected:
        basic_iostream();
    }
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream;
    inline namespace __cxx11 {
        template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> class basic_stringbuf
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> class basic_stringbuf
template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringbuf;
        template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> class basic_istringstream
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> class basic_istringstream
template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_istringstream;
        template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> class basic_ostringstream
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> class basic_ostringstream
template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_ostringstream;
        template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> class basic_stringstream
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> class basic_stringstream
template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringstream;
    }
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_filebuf
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_filebuf
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_filebuf;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_ifstream
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_ifstream
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ifstream;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_ofstream
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_ofstream
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ofstream;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_fstream
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_fstream
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_fstream;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class istreambuf_iterator
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class istreambuf_iterator
template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class ostreambuf_iterator
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class ostreambuf_iterator
template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    typedef basic_ios<char> ios;
    typedef basic_streambuf<char> streambuf;
    typedef basic_istream<char> istream;
    typedef basic_ostream<char> ostream;
    typedef basic_iostream<char> iostream;
    typedef basic_stringbuf<char> stringbuf;
    typedef basic_istringstream<char> istringstream;
    typedef basic_ostringstream<char> ostringstream;
    typedef basic_stringstream<char> stringstream;
    typedef basic_filebuf<char> filebuf;
    typedef basic_ifstream<char> ifstream;
    typedef basic_ofstream<char> ofstream;
    typedef basic_fstream<char> fstream;
    typedef basic_ios<wchar_t> wios;
    typedef basic_streambuf<wchar_t> wstreambuf;
    typedef basic_istream<wchar_t> wistream;
    typedef basic_ostream<wchar_t> wostream;
    typedef basic_iostream<wchar_t> wiostream;
    typedef basic_stringbuf<wchar_t> wstringbuf;
    typedef basic_istringstream<wchar_t> wistringstream;
    typedef basic_ostringstream<wchar_t> wostringstream;
    typedef basic_stringstream<wchar_t> wstringstream;
    typedef basic_filebuf<wchar_t> wfilebuf;
    typedef basic_ifstream<wchar_t> wifstream;
    typedef basic_ofstream<wchar_t> wofstream;
    typedef basic_fstream<wchar_t> wfstream;
}
extern "C++" {
    namespace std {
        class __attribute__((visibility("default"))) exception {
        public:
            exception() throw()             {
            }


            virtual ~std::exception() throw();
            virtual const char *what() const throw();
        };
        class __attribute__((visibility("default"))) bad_exception : public std::exception {
        public:
            bad_exception() throw() : std::exception()             {
            }


            virtual ~std::bad_exception() throw();
            virtual const char *what() const throw();
        };
        typedef void (*terminate_handler)();
        typedef void (*unexpected_handler)();
        terminate_handler set_terminate(terminate_handler) throw() __attribute__((visibility("default")));
        void terminate() throw() __attribute__((visibility("default")));
        unexpected_handler set_unexpected(unexpected_handler) throw() __attribute__((visibility("default")));
        void unexpected() __attribute__((visibility("default")));
        bool uncaught_exception() throw() __attribute__((pure)) __attribute__((visibility("default")));
    }
    namespace __gnu_cxx {
        void __verbose_terminate_handler() __attribute__((visibility("default")));
    }
}
namespace std {
    void __throw_bad_exception();
    void __throw_bad_alloc();
    void __throw_bad_cast();
    void __throw_bad_typeid();
    void __throw_logic_error(const char *);
    void __throw_domain_error(const char *);
    void __throw_invalid_argument(const char *);
    void __throw_length_error(const char *);
    void __throw_out_of_range(const char *);
    void __throw_out_of_range_fmt(const char *, ...);
    void __throw_runtime_error(const char *);
    void __throw_range_error(const char *);
    void __throw_overflow_error(const char *);
    void __throw_underflow_error(const char *);
    void __throw_ios_failure(const char *);
    void __throw_system_error(int);
    void __throw_future_error(int);
    void __throw_bad_function_call();
}
namespace __gnu_cxx {
    template <typename _Iterator = char *, typename _Container = std::__cxx11::basic_string<char>> class __normal_iterator {
    protected:
        char *_M_current;
        typedef iterator_traits<char *> __traits_type;
    public:
        typedef char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        __normal_iterator();
        explicit __normal_iterator(char *const &__i);
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char>::pointer>::__value), basic_string<char> >::__type> &__i);
        reference operator*() const;
        pointer operator->() const;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator++();
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator++(int);
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator--();
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator--(int);
        reference operator[](difference_type __n) const;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator+=(difference_type __n);
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator+(difference_type __n) const;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator-=(difference_type __n);
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator-(difference_type __n) const;
        char *const &base() const;
    }
template <typename _Iterator = const char *, typename _Container = std::__cxx11::basic_string<char>> class __normal_iterator {
    protected:
        const char *_M_current;
        typedef iterator_traits<const char *> __traits_type;
    public:
        typedef const char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        __normal_iterator();
        explicit __normal_iterator(const char *const &__i);
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char>::pointer>::__value), basic_string<char> >::__type> &__i);
        reference operator*() const;
        pointer operator->() const;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator++();
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator++(int);
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator--();
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator--(int);
        reference operator[](difference_type __n) const;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator+=(difference_type __n);
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator+(difference_type __n) const;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator-=(difference_type __n);
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator-(difference_type __n) const;
        const char *const &base() const;
    }
template <typename _Iterator = wchar_t *, typename _Container = std::__cxx11::basic_string<wchar_t>> class __normal_iterator
template <typename _Iterator = const wchar_t *, typename _Container = std::__cxx11::basic_string<wchar_t>> class __normal_iterator
template <typename _Iterator, typename _Container> class __normal_iterator;
}
namespace std {
    struct __true_type {
    };
    struct __false_type {
    };
    template <bool = true> struct __truth_type {
        typedef std::__true_type __type;
    }
template <bool> struct __truth_type {
        typedef std::__false_type __type;
    };
    struct __truth_type {
        typedef std::__true_type __type;
    };
    template <class _Sp, class _Tp> struct __traitor {
        enum  {
            __value = bool(_Sp::__value) || bool(_Tp::__value)
        };
        typedef typename __truth_type<__value>::__type __type;
    };
    template <typename , typename > struct __are_same {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    };
    struct __are_same {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Tp = void> struct __is_void {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp> struct __is_void {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    };
    struct __is_void {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Tp = bool> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = char> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = signed char> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = unsigned char> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = wchar_t> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = short> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = unsigned short> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = int> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = unsigned int> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = long> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = unsigned long> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = long long> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = unsigned long long> struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = long double> struct __is_integer {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    }
template <typename _Tp = double> struct __is_integer {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    }
template <typename _Tp = float> struct __is_integer {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    }
template <typename _Tp = char *> struct __is_integer {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    }
template <typename _Tp = const char *> struct __is_integer {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    }
template <typename _Tp> struct __is_integer {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_integer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Tp = float> struct __is_floating {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = double> struct __is_floating {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = long double> struct __is_floating {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp> struct __is_floating {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    };
    struct __is_floating {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_floating {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_floating {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Tp> struct __is_pointer {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    };
    struct __is_pointer {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Tp> struct __is_normal_iterator {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    };
    struct __is_normal_iterator {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Tp> struct __is_arithmetic : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> > {
    };
    template <typename _Tp> struct __is_scalar : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> > {
    };
    template <typename _Tp = char> struct __is_char {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = wchar_t> struct __is_char {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp> struct __is_char {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    };
    struct __is_char {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_char {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Tp = char> struct __is_byte {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = signed char> struct __is_byte {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp = unsigned char> struct __is_byte {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    }
template <typename _Tp> struct __is_byte {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    };
    struct __is_byte {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_byte {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    struct __is_byte {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Tp> struct __is_move_iterator {
        enum  {
            __value = 0
        };
        typedef std::__false_type __type;
    };
}
namespace __gnu_cxx {
    template <bool, typename > struct __enable_if {
    };
    struct __enable_if {
        typedef _Tp __type;
    };
    template <bool _Cond = true, typename _Iftrue = __gnu_cxx::__numeric_traits_integer<int>, typename _Iffalse = __gnu_cxx::__numeric_traits_floating<int>> struct __conditional_type {
        typedef __gnu_cxx::__numeric_traits_integer<int> __type;
    }
template <bool _Cond = true, typename _Iftrue = __gnu_cxx::__numeric_traits_integer<unsigned long>, typename _Iffalse = __gnu_cxx::__numeric_traits_floating<unsigned long>> struct __conditional_type {
        typedef __gnu_cxx::__numeric_traits_integer<unsigned long> __type;
    }
template <bool _Cond = true, typename _Iftrue = __gnu_cxx::__numeric_traits_integer<char>, typename _Iffalse = __gnu_cxx::__numeric_traits_floating<char>> struct __conditional_type {
        typedef __gnu_cxx::__numeric_traits_integer<char> __type;
    }
template <bool _Cond = true, typename _Iftrue = unsigned long, typename _Iffalse = unsigned long long> struct __conditional_type {
        typedef unsigned long __type;
    }
template <bool _Cond = true, typename _Iftrue = __gnu_cxx::__numeric_traits_integer<short>, typename _Iffalse = __gnu_cxx::__numeric_traits_floating<short>> struct __conditional_type {
        typedef __gnu_cxx::__numeric_traits_integer<short> __type;
    }
template <bool _Cond = true, typename _Iftrue = __gnu_cxx::__numeric_traits_integer<long>, typename _Iffalse = __gnu_cxx::__numeric_traits_floating<long>> struct __conditional_type {
        typedef __gnu_cxx::__numeric_traits_integer<long> __type;
    }
template <bool _Cond, typename _Iftrue, typename _Iffalse> struct __conditional_type {
        typedef _Iftrue __type;
    };
    struct __conditional_type {
        typedef _Iffalse __type;
    };
    template <typename _Tp = char> struct __add_unsigned {
        typedef unsigned char __type;
    }
template <typename _Tp = signed char> struct __add_unsigned {
        typedef unsigned char __type;
    }
template <typename _Tp = short> struct __add_unsigned {
        typedef unsigned short __type;
    }
template <typename _Tp = int> struct __add_unsigned {
        typedef unsigned int __type;
    }
template <typename _Tp = long> struct __add_unsigned {
        typedef unsigned long __type;
    }
template <typename _Tp = long long> struct __add_unsigned {
        typedef unsigned long long __type;
    }
template <typename _Tp = bool> struct __add_unsigned
template <typename _Tp = wchar_t> struct __add_unsigned
template <typename _Tp> struct __add_unsigned {
    private:
        typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
        typedef typename __if_type::__type __type;
    };
    struct __add_unsigned {
        typedef unsigned char __type;
    };
    struct __add_unsigned {
        typedef unsigned char __type;
    };
    struct __add_unsigned {
        typedef unsigned short __type;
    };
    struct __add_unsigned {
        typedef unsigned int __type;
    };
    struct __add_unsigned {
        typedef unsigned long __type;
    };
    struct __add_unsigned {
        typedef unsigned long long __type;
    };
    struct __add_unsigned;
    struct __add_unsigned;
    template <typename _Tp = char> struct __remove_unsigned {
        typedef signed char __type;
    }
template <typename _Tp = unsigned char> struct __remove_unsigned {
        typedef signed char __type;
    }
template <typename _Tp = unsigned short> struct __remove_unsigned {
        typedef short __type;
    }
template <typename _Tp = unsigned int> struct __remove_unsigned {
        typedef int __type;
    }
template <typename _Tp = unsigned long> struct __remove_unsigned {
        typedef long __type;
    }
template <typename _Tp = unsigned long long> struct __remove_unsigned {
        typedef long long __type;
    }
template <typename _Tp = bool> struct __remove_unsigned
template <typename _Tp = wchar_t> struct __remove_unsigned
template <typename _Tp> struct __remove_unsigned {
    private:
        typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
        typedef typename __if_type::__type __type;
    };
    struct __remove_unsigned {
        typedef signed char __type;
    };
    struct __remove_unsigned {
        typedef signed char __type;
    };
    struct __remove_unsigned {
        typedef short __type;
    };
    struct __remove_unsigned {
        typedef int __type;
    };
    struct __remove_unsigned {
        typedef long __type;
    };
    struct __remove_unsigned {
        typedef long long __type;
    };
    struct __remove_unsigned;
    struct __remove_unsigned;
    template <typename _Type = char> inline bool __is_null_pointer(char *__ptr)     {
        return __ptr == 0;
    }

template <typename _Type = const char> inline bool __is_null_pointer(const char *__ptr)     {
        return __ptr == 0;
    }

template <typename _Type> inline bool __is_null_pointer(_Type *__ptr)     {
        return __ptr == 0;
    }

;
    template <typename _Type = char *> inline bool __is_null_pointer(char *)template <typename _Type = const char *> inline bool __is_null_pointer(const char *)template <typename _Type> inline bool __is_null_pointer(_Type)     {
        return false;
    }

;
    template <typename _Tp = long double, bool = false> struct __promote {
        typedef long double __type;
    }
template <typename _Tp = double, bool = false> struct __promote {
        typedef double __type;
    }
template <typename _Tp = float, bool = false> struct __promote {
        typedef float __type;
    }
template <typename _Tp, bool = std::__is_integer<_Tp>::__value> struct __promote {
        typedef double __type;
    };
    struct __promote {
    };
    struct __promote {
        typedef long double __type;
    };
    struct __promote {
        typedef double __type;
    };
    struct __promote {
        typedef float __type;
    };
    template <typename _Tp, typename _Up, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type> struct __promote_2 {
        typedef typeof (_Tp2() + _Up2()) __type;
    };
    template <typename _Tp, typename _Up, typename _Vp, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type, typename _Vp2 = typename __promote<_Vp>::__type> struct __promote_3 {
        typedef typeof (_Tp2() + _Up2() + _Vp2()) __type;
    };
    template <typename _Tp, typename _Up, typename _Vp, typename _Wp, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type, typename _Vp2 = typename __promote<_Vp>::__type, typename _Wp2 = typename __promote<_Wp>::__type> struct __promote_4 {
        typedef typeof (_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };
}
namespace __gnu_cxx {
    template <typename _Value = int> struct __numeric_traits_integer {
        static const int __min = (((int)(-1) < 0) ? (int)1 << (sizeof(int) * 8 - ((int)(-1) < 0)) : (int)0);
        static const int __max = (((int)(-1) < 0) ? (((((int)1 << ((sizeof(int) * 8 - ((int)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(int)0);
        static const bool __is_signed = ((int)(-1) < 0);
        static const int __digits = (sizeof(int) * 8 - ((int)(-1) < 0));
    }
template <typename _Value = unsigned long> struct __numeric_traits_integer {
        static const unsigned long __min = (((unsigned long)(-1) < 0) ? (unsigned long)1 << (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) : (unsigned long)0);
        static const unsigned long __max = (((unsigned long)(-1) < 0) ? (((((unsigned long)1 << ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned long)0);
        static const bool __is_signed = ((unsigned long)(-1) < 0);
        static const int __digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
    }
template <typename _Value = char> struct __numeric_traits_integer {
        static const char __min = (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0);
        static const char __max = (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0);
        static const bool __is_signed = ((char)(-1) < 0);
        static const int __digits = (sizeof(char) * 8 - ((char)(-1) < 0));
    }
template <typename _Value = short> struct __numeric_traits_integer {
        static const short __min = (((short)(-1) < 0) ? (short)1 << (sizeof(short) * 8 - ((short)(-1) < 0)) : (short)0);
        static const short __max = (((short)(-1) < 0) ? (((((short)1 << ((sizeof(short) * 8 - ((short)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(short)0);
        static const bool __is_signed = ((short)(-1) < 0);
        static const int __digits = (sizeof(short) * 8 - ((short)(-1) < 0));
    }
template <typename _Value = long> struct __numeric_traits_integer {
        static const long __min = (((long)(-1) < 0) ? (long)1 << (sizeof(long) * 8 - ((long)(-1) < 0)) : (long)0);
        static const long __max = (((long)(-1) < 0) ? (((((long)1 << ((sizeof(long) * 8 - ((long)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(long)0);
        static const bool __is_signed = ((long)(-1) < 0);
        static const int __digits = (sizeof(long) * 8 - ((long)(-1) < 0));
    }
template <typename _Value> struct __numeric_traits_integer {
        static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
        static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);
        static const bool __is_signed = ((_Value)(-1) < 0);
        static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };
    const _Value __min;
    const _Value __max;
    const bool __is_signed;
    const int __digits;
    template <typename _Value = int> struct __numeric_traits_floating
template <typename _Value = unsigned long> struct __numeric_traits_floating
template <typename _Value = char> struct __numeric_traits_floating
template <typename _Value = short> struct __numeric_traits_floating
template <typename _Value = long> struct __numeric_traits_floating
template <typename _Value> struct __numeric_traits_floating {
        static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };
    const int __max_digits10;
    const bool __is_signed;
    const int __digits10;
    const int __max_exponent10;
    template <typename _Value = int> struct __numeric_traits : public typename __conditional_type<std::__is_integer<int>::__value, __numeric_traits_integer<int>, __numeric_traits_floating<int> >::__type {
    }
template <typename _Value = unsigned long> struct __numeric_traits : public typename __conditional_type<std::__is_integer<unsigned long>::__value, __numeric_traits_integer<unsigned long>, __numeric_traits_floating<unsigned long> >::__type {
    }
template <typename _Value = char> struct __numeric_traits : public typename __conditional_type<std::__is_integer<char>::__value, __numeric_traits_integer<char>, __numeric_traits_floating<char> >::__type {
    }
template <typename _Value = short> struct __numeric_traits : public typename __conditional_type<std::__is_integer<short>::__value, __numeric_traits_integer<short>, __numeric_traits_floating<short> >::__type {
    }
template <typename _Value = long> struct __numeric_traits : public typename __conditional_type<std::__is_integer<long>::__value, __numeric_traits_integer<long>, __numeric_traits_floating<long> >::__type {
    }
template <typename _Value> struct __numeric_traits : public __conditional_type<std::__is_integer<_Value>::__value, __numeric_traits_integer<_Value>, __numeric_traits_floating<_Value> >::__type {
    };
    const int __max;
    const int __min;
    const int __digits;
    const char __max;
    const short __min;
    const short __max;
    const long __max;
    const long __min;
}
namespace std {
    template <typename _Tp = Player> inline Player *__addressof(Player &__r)     {
        return reinterpret_cast<Player *>(&const_cast<char &>(reinterpret_cast<const volatile char &>(__r)));
    }

template <typename _Tp> inline _Tp *__addressof(_Tp &__r)     {
        return reinterpret_cast<_Tp *>(&const_cast<char &>(reinterpret_cast<const volatile char &>(__r)));
    }

;
}
namespace std {
    template <typename _Tp> inline void swap(_Tp &__a, _Tp &__b)     {
        _Tp __tmp = (__a);
        __a = (__b);
        __b = (__tmp);
    }

;
    template <typename _Tp, size_t _Nm> inline void swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])     {
        for (size_t __n = 0; __n < _Nm; ++__n) 
            swap(__a[__n], __b[__n]);
    }

;
}
namespace std {
    template <class _T1, class _T2> struct pair {
        typedef _T1 first_type;
        typedef _T2 second_type;
        _T1 first;
        _T2 second;
        pair<_T1, _T2>() : first(), second()         {
        }


        pair<_T1, _T2>(const _T1 &__a, const _T2 &__b) : first(__a), second(__b)         {
        }


        template <class _U1, class _U2> pair<_T1, _T2>(const pair<_U1, _U2> &__p) : first(__p.first), second(__p.second)         {
        }

;
    };
    template <class _T1, class _T2> inline bool operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return __x.first == __y.first && __x.second == __y.second;
    }

;
    template <class _T1, class _T2> inline bool operator<(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
    }

;
    template <class _T1, class _T2> inline bool operator!=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return !(__x == __y);
    }

;
    template <class _T1, class _T2> inline bool operator>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return __y < __x;
    }

;
    template <class _T1, class _T2> inline bool operator<=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return !(__y < __x);
    }

;
    template <class _T1, class _T2> inline bool operator>=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return !(__x < __y);
    }

;
    template <class _T1, class _T2> inline pair<_T1, _T2> make_pair(_T1 __x, _T2 __y)     {
        return pair<_T1, _T2>(__x, __y);
    }

;
}
namespace std {
    struct input_iterator_tag {
    };
    struct output_iterator_tag {
    };
    struct forward_iterator_tag : public std::input_iterator_tag {
    };
    struct bidirectional_iterator_tag : public std::forward_iterator_tag {
    };
    struct random_access_iterator_tag : public std::bidirectional_iterator_tag {
    };
    template <typename _Category = std::output_iterator_tag, typename _Tp = void, typename _Distance = void, typename _Pointer = void, typename _Reference = void> struct iterator {
        typedef std::output_iterator_tag iterator_category;
        typedef void value_type;
        typedef void difference_type;
        typedef void pointer;
        typedef void reference;
    }
template <typename _Category = std::bidirectional_iterator_tag, typename _Tp = Player, typename _Distance = long, typename _Pointer = Player *, typename _Reference = Player &> struct iterator {
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef Player value_type;
        typedef long difference_type;
        typedef Player *pointer;
        typedef Player &reference;
    }
template <typename _Category, typename _Tp, typename _Distance = ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp &> struct iterator {
        typedef _Category iterator_category;
        typedef _Tp value_type;
        typedef _Distance difference_type;
        typedef _Pointer pointer;
        typedef _Reference reference;
    };
    template <typename _Iterator = std::_List_iterator<Player>> struct iterator_traits {
        typedef typename _List_iterator<Player>::iterator_category iterator_category;
        typedef typename _List_iterator<Player>::value_type value_type;
        typedef typename _List_iterator<Player>::difference_type difference_type;
        typedef typename _List_iterator<Player>::pointer pointer;
        typedef typename _List_iterator<Player>::reference reference;
    }
template <typename _Iterator = char *> struct iterator_traits {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef ptrdiff_t difference_type;
        typedef char *pointer;
        typedef char &reference;
    }
template <typename _Iterator = const char *> struct iterator_traits {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef ptrdiff_t difference_type;
        typedef const char *pointer;
        typedef const char &reference;
    }
template <typename _Iterator> struct iterator_traits {
        typedef typename _Iterator::iterator_category iterator_category;
        typedef typename _Iterator::value_type value_type;
        typedef typename _Iterator::difference_type difference_type;
        typedef typename _Iterator::pointer pointer;
        typedef typename _Iterator::reference reference;
    };
    struct iterator_traits {
        typedef std::random_access_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef _Tp &reference;
    };
    struct iterator_traits {
        typedef std::random_access_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef ptrdiff_t difference_type;
        typedef const _Tp *pointer;
        typedef const _Tp &reference;
    };
    template <typename _Iter = char *> inline typename iterator_traits<char *>::iterator_category __iterator_category(char *const &)     {
        return typename iterator_traits<char *>::iterator_category();
    }

template <typename _Iter = const char *> inline typename iterator_traits<const char *>::iterator_category __iterator_category(const char *const &)     {
        return typename iterator_traits<const char *>::iterator_category();
    }

template <typename _Iter> inline typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &)     {
        return typename iterator_traits<_Iter>::iterator_category();
    }

;
    template <typename _Iterator, bool _HasBase> struct _Iter_base {
        typedef _Iterator iterator_type;
        static iterator_type _S_base(_Iterator __it)         {
            return __it;
        }


    };
    struct _Iter_base {
        typedef typename _Iterator::iterator_type iterator_type;
        static iterator_type _S_base(_Iterator __it)         {
            return __it.base();
        }


    };
}
namespace std {
    namespace __debug {
    }
}
namespace __gnu_debug {
    using namespace std::__debug;
}
namespace std {
    template <typename _InputIterator = char *> inline typename iterator_traits<char *>::difference_type __distance(char *__first, char *__last, std::input_iterator_tag)template <typename _InputIterator = const char *> inline typename iterator_traits<const char *>::difference_type __distance(const char *__first, const char *__last, std::input_iterator_tag)template <typename _InputIterator> inline typename iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, std::input_iterator_tag)     {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        while (__first != __last)
            {
                ++__first;
                ++__n;
            }
        return __n;
    }

;
    template <typename _RandomAccessIterator = char *> inline typename iterator_traits<char *>::difference_type __distance(char *__first, char *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }

template <typename _RandomAccessIterator = const char *> inline typename iterator_traits<const char *>::difference_type __distance(const char *__first, const char *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }

template <typename _RandomAccessIterator> inline typename iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, std::random_access_iterator_tag)     {
        return __last - __first;
    }

;
    template <typename _InputIterator = char *> inline typename iterator_traits<char *>::difference_type distance(char *__first, char *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }

template <typename _InputIterator = const char *> inline typename iterator_traits<const char *>::difference_type distance(const char *__first, const char *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }

template <typename _InputIterator> inline typename iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }

;
    template <typename _InputIterator, typename _Distance> inline void __advance(_InputIterator &__i, _Distance __n, std::input_iterator_tag)     {
        ;
        while (__n--)
            ++__i;
    }

;
    template <typename _BidirectionalIterator, typename _Distance> inline void __advance(_BidirectionalIterator &__i, _Distance __n, std::bidirectional_iterator_tag)     {
        if (__n > 0)
            while (__n--)
                ++__i;
        else
            while (__n++)
                --__i;
    }

;
    template <typename _RandomAccessIterator, typename _Distance> inline void __advance(_RandomAccessIterator &__i, _Distance __n, std::random_access_iterator_tag)     {
        __i += __n;
    }

;
    template <typename _InputIterator, typename _Distance> inline void advance(_InputIterator &__i, _Distance __n)     {
        typename iterator_traits<_InputIterator>::difference_type __d = __n;
        std::__advance(__i, __d, std::__iterator_category(__i));
    }

;
}
namespace std {
    template <typename _Iterator = __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> >> class reverse_iterator
template <typename _Iterator = __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> >> class reverse_iterator
template <typename _Iterator = __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> >> class reverse_iterator
template <typename _Iterator = __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> >> class reverse_iterator
template <typename _Iterator = std::_List_const_iterator<Player>> class reverse_iterator
template <typename _Iterator = std::_List_iterator<Player>> class reverse_iterator : public iterator<typename iterator_traits<_List_iterator<Player> >::iterator_category, typename iterator_traits<_List_iterator<Player> >::value_type, typename iterator_traits<_List_iterator<Player> >::difference_type, typename iterator_traits<_List_iterator<Player> >::pointer, typename iterator_traits<_List_iterator<Player> >::reference> {
    protected:
        std::_List_iterator<Player> current;
        typedef iterator_traits<std::_List_iterator<Player> > __traits_type;
    public:
        typedef std::_List_iterator<Player> iterator_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::pointer pointer;
        typedef typename __traits_type::reference reference;
        reverse_iterator() : iterator<typename iterator_traits<_List_iterator<Player> >::iterator_category, typename iterator_traits<_List_iterator<Player> >::value_type, typename iterator_traits<_List_iterator<Player> >::difference_type, typename iterator_traits<_List_iterator<Player> >::pointer, typename iterator_traits<_List_iterator<Player> >::reference>(), current()         {
        }


        explicit reverse_iterator(iterator_type __x);
        reverse_iterator(const std::reverse_iterator<std::_List_iterator<Player> > &__x) : iterator<typename iterator_traits<_List_iterator<Player> >::iterator_category, typename iterator_traits<_List_iterator<Player> >::value_type, typename iterator_traits<_List_iterator<Player> >::difference_type, typename iterator_traits<_List_iterator<Player> >::pointer, typename iterator_traits<_List_iterator<Player> >::reference>(), current(__x.current)         {
        }


        template <typename _Iter = std::_List_iterator<Player>> reverse_iterator(const reverse_iterator<std::_List_iterator<Player> > &__x)template <typename _Iter> reverse_iterator(const reverse_iterator<_Iter> &__x);
        iterator_type base() const;
        reference operator*() const         {
            std::_List_iterator<Player> __tmp = this->current;
            return * -- __tmp;
        }


        pointer operator->() const         {
            return &(this->operator*());
        }


        std::reverse_iterator<std::_List_iterator<Player> > &operator++();
        std::reverse_iterator<std::_List_iterator<Player> > operator++(int)         {
            std::reverse_iterator<std::_List_iterator<Player> > __tmp = *this;
            -- this->current;
            return __tmp;
        }


        std::reverse_iterator<std::_List_iterator<Player> > &operator--();
        std::reverse_iterator<std::_List_iterator<Player> > operator--(int);
        std::reverse_iterator<std::_List_iterator<Player> > operator+(difference_type __n) const;
        std::reverse_iterator<std::_List_iterator<Player> > &operator+=(difference_type __n);
        std::reverse_iterator<std::_List_iterator<Player> > operator-(difference_type __n) const;
        std::reverse_iterator<std::_List_iterator<Player> > &operator-=(difference_type __n);
        reference operator[](difference_type __n) const;
    }
template <typename _Iterator> class reverse_iterator : public iterator<typename iterator_traits<_Iterator>::iterator_category, typename iterator_traits<_Iterator>::value_type, typename iterator_traits<_Iterator>::difference_type, typename iterator_traits<_Iterator>::pointer, typename iterator_traits<_Iterator>::reference> {
    protected:
        _Iterator current;
        typedef iterator_traits<_Iterator> __traits_type;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::pointer pointer;
        typedef typename __traits_type::reference reference;
        reverse_iterator<_Iterator>() : current()         {
        }


        explicit reverse_iterator<_Iterator>(iterator_type __x) : current(__x)         {
        }


        reverse_iterator<_Iterator>(const reverse_iterator<_Iterator> &__x) : current(__x.current)         {
        }


        template <typename _Iter> reverse_iterator<_Iterator>(const reverse_iterator<_Iter> &__x) : current(__x.base())         {
        }

;
        iterator_type base() const         {
            return this->current;
        }


        reference operator*() const         {
            _Iterator __tmp = this->current;
            return *--__tmp;
        }


        pointer operator->() const         {
            return &(this->operator*());
        }


        reverse_iterator<_Iterator> &operator++()         {
            --this->current;
            return *this;
        }


        reverse_iterator<_Iterator> operator++(int)         {
            reverse_iterator<_Iterator> __tmp = *this;
            --this->current;
            return __tmp;
        }


        reverse_iterator<_Iterator> &operator--()         {
            ++this->current;
            return *this;
        }


        reverse_iterator<_Iterator> operator--(int)         {
            reverse_iterator<_Iterator> __tmp = *this;
            ++this->current;
            return __tmp;
        }


        reverse_iterator<_Iterator> operator+(difference_type __n) const         {
            return reverse_iterator<_Iterator>(this->current - __n);
        }


        reverse_iterator<_Iterator> &operator+=(difference_type __n)         {
            this->current -= __n;
            return *this;
        }


        reverse_iterator<_Iterator> operator-(difference_type __n) const         {
            return reverse_iterator<_Iterator>(this->current + __n);
        }


        reverse_iterator<_Iterator> &operator-=(difference_type __n)         {
            this->current += __n;
            return *this;
        }


        reference operator[](difference_type __n) const         {
            return *(*this + __n);
        }


    };
    template <typename _Iterator> inline bool operator==(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return __x.base() == __y.base();
    }

;
    template <typename _Iterator> inline bool operator<(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return __y.base() < __x.base();
    }

;
    template <typename _Iterator> inline bool operator!=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return !(__x == __y);
    }

;
    template <typename _Iterator> inline bool operator>(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return __y < __x;
    }

;
    template <typename _Iterator> inline bool operator<=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return !(__y < __x);
    }

;
    template <typename _Iterator> inline bool operator>=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return !(__x < __y);
    }

;
    template <typename _Iterator> inline typename reverse_iterator<_Iterator>::difference_type operator-(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return __y.base() - __x.base();
    }

;
    template <typename _Iterator> inline reverse_iterator<_Iterator> operator+(typename reverse_iterator<_Iterator>::difference_type __n, const reverse_iterator<_Iterator> &__x)     {
        return reverse_iterator<_Iterator>(__x.base() - __n);
    }

;
    template <typename _IteratorL, typename _IteratorR> inline bool operator==(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return __x.base() == __y.base();
    }

;
    template <typename _IteratorL, typename _IteratorR> inline bool operator<(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return __y.base() < __x.base();
    }

;
    template <typename _IteratorL, typename _IteratorR> inline bool operator!=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return !(__x == __y);
    }

;
    template <typename _IteratorL, typename _IteratorR> inline bool operator>(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return __y < __x;
    }

;
    template <typename _IteratorL, typename _IteratorR> inline bool operator<=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return !(__y < __x);
    }

;
    template <typename _IteratorL, typename _IteratorR> inline bool operator>=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return !(__x < __y);
    }

;
    template <typename _IteratorL, typename _IteratorR> inline typename reverse_iterator<_IteratorL>::difference_type operator-(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return __y.base() - __x.base();
    }

;
    template <typename _Container> class back_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        explicit back_insert_iterator<_Container>(_Container &__x) : container(&__x)         {
        }


        back_insert_iterator<_Container> &operator=(typename _Container::const_reference __value)         {
            this->container->push_back(__value);
            return *this;
        }


        back_insert_iterator<_Container> &operator*()         {
            return *this;
        }


        back_insert_iterator<_Container> &operator++()         {
            return *this;
        }


        back_insert_iterator<_Container> operator++(int)         {
            return *this;
        }


    };
    template <typename _Container> inline back_insert_iterator<_Container> back_inserter(_Container &__x)     {
        return back_insert_iterator<_Container>(__x);
    }

;
    template <typename _Container> class front_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        explicit front_insert_iterator<_Container>(_Container &__x) : container(&__x)         {
        }


        front_insert_iterator<_Container> &operator=(typename _Container::const_reference __value)         {
            this->container->push_front(__value);
            return *this;
        }


        front_insert_iterator<_Container> &operator*()         {
            return *this;
        }


        front_insert_iterator<_Container> &operator++()         {
            return *this;
        }


        front_insert_iterator<_Container> operator++(int)         {
            return *this;
        }


    };
    template <typename _Container> inline front_insert_iterator<_Container> front_inserter(_Container &__x)     {
        return front_insert_iterator<_Container>(__x);
    }

;
    template <typename _Container> class insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
        typename _Container::iterator iter;
    public:
        typedef _Container container_type;
        insert_iterator<_Container>(_Container &__x, typename _Container::iterator __i) : container(&__x), iter(__i)         {
        }


        insert_iterator<_Container> &operator=(typename _Container::const_reference __value)         {
            this->iter = this->container->insert(this->iter, __value);
            ++this->iter;
            return *this;
        }


        insert_iterator<_Container> &operator*()         {
            return *this;
        }


        insert_iterator<_Container> &operator++()         {
            return *this;
        }


        insert_iterator<_Container> &operator++(int)         {
            return *this;
        }


    };
    template <typename _Container, typename _Iterator> inline insert_iterator<_Container> inserter(_Container &__x, _Iterator __i)     {
        return insert_iterator<_Container>(__x, typename _Container::iterator(__i));
    }

;
}
namespace __gnu_cxx {
    using std::iterator_traits;
    using std::iterator;
    template <typename _Iterator = char *, typename _Container = std::__cxx11::basic_string<char>> class __normal_iterator {
    protected:
        char *_M_current;
        typedef iterator_traits<char *> __traits_type;
    public:
        typedef char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        __normal_iterator();
        explicit __normal_iterator(char *const &__i);
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char>::pointer>::__value), basic_string<char> >::__type> &__i);
        reference operator*() const;
        pointer operator->() const;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator++();
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator++(int);
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator--();
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator--(int);
        reference operator[](difference_type __n) const;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator+=(difference_type __n);
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator+(difference_type __n) const;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator-=(difference_type __n);
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator-(difference_type __n) const;
        char *const &base() const;
    }
template <typename _Iterator = const char *, typename _Container = std::__cxx11::basic_string<char>> class __normal_iterator {
    protected:
        const char *_M_current;
        typedef iterator_traits<const char *> __traits_type;
    public:
        typedef const char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        __normal_iterator();
        explicit __normal_iterator(const char *const &__i);
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char>::pointer>::__value), basic_string<char> >::__type> &__i);
        reference operator*() const;
        pointer operator->() const;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator++();
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator++(int);
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator--();
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator--(int);
        reference operator[](difference_type __n) const;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator+=(difference_type __n);
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator+(difference_type __n) const;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator-=(difference_type __n);
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator-(difference_type __n) const;
        const char *const &base() const;
    }
template <typename _Iterator = wchar_t *, typename _Container = std::__cxx11::basic_string<wchar_t>> class __normal_iterator
template <typename _Iterator = const wchar_t *, typename _Container = std::__cxx11::basic_string<wchar_t>> class __normal_iterator
template <typename _Iterator, typename _Container> class __normal_iterator {
    protected:
        _Iterator _M_current;
        typedef iterator_traits<_Iterator> __traits_type;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        __normal_iterator<_Iterator, _Container>() : _M_current(_Iterator())         {
        }


        explicit __normal_iterator<_Iterator, _Container>(const _Iterator &__i) : _M_current(__i)         {
        }


        template <typename _Iter> __normal_iterator<_Iterator, _Container>(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename _Container::pointer>::__value), _Container>::__type> &__i) : _M_current(__i.base())         {
        }

;
        reference operator*() const         {
            return *this->_M_current;
        }


        pointer operator->() const         {
            return this->_M_current;
        }


        __normal_iterator<_Iterator, _Container> &operator++()         {
            ++this->_M_current;
            return *this;
        }


        __normal_iterator<_Iterator, _Container> operator++(int)         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current++);
        }


        __normal_iterator<_Iterator, _Container> &operator--()         {
            --this->_M_current;
            return *this;
        }


        __normal_iterator<_Iterator, _Container> operator--(int)         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current--);
        }


        reference operator[](difference_type __n) const         {
            return this->_M_current[__n];
        }


        __normal_iterator<_Iterator, _Container> &operator+=(difference_type __n)         {
            this->_M_current += __n;
            return *this;
        }


        __normal_iterator<_Iterator, _Container> operator+(difference_type __n) const         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current + __n);
        }


        __normal_iterator<_Iterator, _Container> &operator-=(difference_type __n)         {
            this->_M_current -= __n;
            return *this;
        }


        __normal_iterator<_Iterator, _Container> operator-(difference_type __n) const         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current - __n);
        }


        const _Iterator &base() const         {
            return this->_M_current;
        }


    };
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator==(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs)     {
        return __lhs.base() == __rhs.base();
    }

;
    template <typename _Iterator, typename _Container> inline bool operator==(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs)     {
        return __lhs.base() == __rhs.base();
    }

;
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator!=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs)     {
        return __lhs.base() != __rhs.base();
    }

;
    template <typename _Iterator, typename _Container> inline bool operator!=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs)     {
        return __lhs.base() != __rhs.base();
    }

;
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator<(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs)     {
        return __lhs.base() < __rhs.base();
    }

;
    template <typename _Iterator, typename _Container> inline bool operator<(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs)     {
        return __lhs.base() < __rhs.base();
    }

;
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator>(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs)     {
        return __lhs.base() > __rhs.base();
    }

;
    template <typename _Iterator, typename _Container> inline bool operator>(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs)     {
        return __lhs.base() > __rhs.base();
    }

;
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator<=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs)     {
        return __lhs.base() <= __rhs.base();
    }

;
    template <typename _Iterator, typename _Container> inline bool operator<=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs)     {
        return __lhs.base() <= __rhs.base();
    }

;
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator>=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs)     {
        return __lhs.base() >= __rhs.base();
    }

;
    template <typename _Iterator, typename _Container> inline bool operator>=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs)     {
        return __lhs.base() >= __rhs.base();
    }

;
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline typename __normal_iterator<_IteratorL, _Container>::difference_type operator-(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs)     {
        return __lhs.base() - __rhs.base();
    }

;
    template <typename _Iterator, typename _Container> inline typename __normal_iterator<_Iterator, _Container>::difference_type operator-(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs)     {
        return __lhs.base() - __rhs.base();
    }

;
    template <typename _Iterator, typename _Container> inline __normal_iterator<_Iterator, _Container> operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n, const __normal_iterator<_Iterator, _Container> &__i)     {
        return __normal_iterator<_Iterator, _Container>(__i.base() + __n);
    }

;
}
namespace __gnu_cxx {
    namespace __ops {
        struct _Iter_less_iter {
            template <typename _Iterator1, typename _Iterator2> bool operator()(_Iterator1 __it1, _Iterator2 __it2) const             {
                return *__it1 < *__it2;
            }

;
        };
        inline __gnu_cxx::__ops::_Iter_less_iter __iter_less_iter()         {
            return __gnu_cxx::__ops::_Iter_less_iter();
        }


        struct _Iter_less_val {
            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val) const             {
                return *__it < __val;
            }

;
        };
        inline __gnu_cxx::__ops::_Iter_less_val __iter_less_val()         {
            return __gnu_cxx::__ops::_Iter_less_val();
        }


        inline __gnu_cxx::__ops::_Iter_less_val __iter_comp_val(__gnu_cxx::__ops::_Iter_less_iter)         {
            return __gnu_cxx::__ops::_Iter_less_val();
        }


        struct _Val_less_iter {
            template <typename _Value, typename _Iterator> bool operator()(_Value &__val, _Iterator __it) const             {
                return __val < *__it;
            }

;
        };
        inline __gnu_cxx::__ops::_Val_less_iter __val_less_iter()         {
            return __gnu_cxx::__ops::_Val_less_iter();
        }


        inline __gnu_cxx::__ops::_Val_less_iter __val_comp_iter(__gnu_cxx::__ops::_Iter_less_iter)         {
            return __gnu_cxx::__ops::_Val_less_iter();
        }


        struct _Iter_equal_to_iter {
            template <typename _Iterator1, typename _Iterator2> bool operator()(_Iterator1 __it1, _Iterator2 __it2) const             {
                return *__it1 == *__it2;
            }

;
        };
        inline __gnu_cxx::__ops::_Iter_equal_to_iter __iter_equal_to_iter()         {
            return __gnu_cxx::__ops::_Iter_equal_to_iter();
        }


        struct _Iter_equal_to_val {
            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val) const             {
                return *__it == __val;
            }

;
        };
        inline __gnu_cxx::__ops::_Iter_equal_to_val __iter_equal_to_val()         {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }


        inline __gnu_cxx::__ops::_Iter_equal_to_val __iter_comp_val(__gnu_cxx::__ops::_Iter_equal_to_iter)         {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }


        template <typename _Compare> struct _Iter_comp_iter {
            _Compare _M_comp;
            _Iter_comp_iter<_Compare>(_Compare __comp) : _M_comp(__comp)             {
            }


            template <typename _Iterator1, typename _Iterator2> bool operator()(_Iterator1 __it1, _Iterator2 __it2)             {
                return bool(this->_M_comp(*__it1, *__it2));
            }

;
        };
        template <typename _Compare> inline _Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp)         {
            return _Iter_comp_iter<_Compare>(__comp);
        }

;
        template <typename _Compare> struct _Iter_comp_val {
            _Compare _M_comp;
            _Iter_comp_val<_Compare>(_Compare __comp) : _M_comp(__comp)             {
            }


            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val)             {
                return bool(this->_M_comp(*__it, __val));
            }

;
        };
        template <typename _Compare> inline _Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp)         {
            return _Iter_comp_val<_Compare>(__comp);
        }

;
        template <typename _Compare> inline _Iter_comp_val<_Compare> __iter_comp_val(_Iter_comp_iter<_Compare> __comp)         {
            return _Iter_comp_val<_Compare>(__comp._M_comp);
        }

;
        template <typename _Compare> struct _Val_comp_iter {
            _Compare _M_comp;
            _Val_comp_iter<_Compare>(_Compare __comp) : _M_comp(__comp)             {
            }


            template <typename _Value, typename _Iterator> bool operator()(_Value &__val, _Iterator __it)             {
                return bool(this->_M_comp(__val, *__it));
            }

;
        };
        template <typename _Compare> inline _Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp)         {
            return _Val_comp_iter<_Compare>(__comp);
        }

;
        template <typename _Compare> inline _Val_comp_iter<_Compare> __val_comp_iter(_Iter_comp_iter<_Compare> __comp)         {
            return _Val_comp_iter<_Compare>(__comp._M_comp);
        }

;
        template <typename _Value> struct _Iter_equals_val {
            _Value &_M_value;
            _Iter_equals_val<_Value>(_Value &__value) : _M_value(__value)             {
            }


            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return *__it == this->_M_value;
            }

;
        };
        template <typename _Value> inline _Iter_equals_val<_Value> __iter_equals_val(_Value &__val)         {
            return _Iter_equals_val<_Value>(__val);
        }

;
        template <typename _Iterator1> struct _Iter_equals_iter {
            typename std::iterator_traits<_Iterator1>::reference _M_ref;
            _Iter_equals_iter<_Iterator1>(_Iterator1 __it1) : _M_ref(*__it1)             {
            }


            template <typename _Iterator2> bool operator()(_Iterator2 __it2)             {
                return *__it2 == this->_M_ref;
            }

;
        };
        template <typename _Iterator> inline _Iter_equals_iter<_Iterator> __iter_comp_iter(__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator __it)         {
            return _Iter_equals_iter<_Iterator>(__it);
        }

;
        template <typename _Predicate> struct _Iter_pred {
            _Predicate _M_pred;
            _Iter_pred<_Predicate>(_Predicate __pred) : _M_pred(__pred)             {
            }


            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return bool(this->_M_pred(*__it));
            }

;
        };
        template <typename _Predicate> inline _Iter_pred<_Predicate> __pred_iter(_Predicate __pred)         {
            return _Iter_pred<_Predicate>(__pred);
        }

;
        template <typename _Compare, typename _Value> struct _Iter_comp_to_val {
            _Compare _M_comp;
            _Value &_M_value;
            _Iter_comp_to_val<_Compare, _Value>(_Compare __comp, _Value &__value) : _M_comp(__comp), _M_value(__value)             {
            }


            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return bool(this->_M_comp(*__it, this->_M_value));
            }

;
        };
        template <typename _Compare, typename _Value> _Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp, _Value &__val)         {
            return _Iter_comp_to_val<_Compare, _Value>(__comp, __val);
        }

;
        template <typename _Compare, typename _Iterator1> struct _Iter_comp_to_iter {
            _Compare _M_comp;
            typename std::iterator_traits<_Iterator1>::reference _M_ref;
            _Iter_comp_to_iter<_Compare, _Iterator1>(_Compare __comp, _Iterator1 __it1) : _M_comp(__comp), _M_ref(*__it1)             {
            }


            template <typename _Iterator2> bool operator()(_Iterator2 __it2)             {
                return bool(this->_M_comp(*__it2, this->_M_ref));
            }

;
        };
        template <typename _Compare, typename _Iterator> inline _Iter_comp_to_iter<_Compare, _Iterator> __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)         {
            return _Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it);
        }

;
        template <typename _Predicate> struct _Iter_negate {
            _Predicate _M_pred;
            _Iter_negate<_Predicate>(_Predicate __pred) : _M_pred(__pred)             {
            }


            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return !bool(this->_M_pred(*__it));
            }

;
        };
        template <typename _Predicate> inline _Iter_negate<_Predicate> __negate(_Iter_pred<_Predicate> __pred)         {
            return _Iter_negate<_Predicate>(__pred._M_pred);
        }

;
    }
}
namespace std {
    template <bool _BoolType = true> struct __iter_swap {
        template <typename _ForwardIterator1, typename _ForwardIterator2> static void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)         {
            swap(*__a, *__b);
        }

;
    }
template <bool _BoolType> struct __iter_swap {
        template <typename _ForwardIterator1, typename _ForwardIterator2> static void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)         {
            typedef typename iterator_traits<_ForwardIterator1>::value_type _ValueType1;
            _ValueType1 __tmp = (*__a);
            *__a = (*__b);
            *__b = (__tmp);
        }

;
    };
    struct __iter_swap {
        template <typename _ForwardIterator1, typename _ForwardIterator2> static void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)         {
            swap(*__a, *__b);
        }

;
    };
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)     {
        typedef typename iterator_traits<_ForwardIterator1>::value_type _ValueType1;
        typedef typename iterator_traits<_ForwardIterator2>::value_type _ValueType2;
        typedef typename iterator_traits<_ForwardIterator1>::reference _ReferenceType1;
        typedef typename iterator_traits<_ForwardIterator2>::reference _ReferenceType2;
        std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value && __are_same<_ValueType1 &, _ReferenceType1>::__value && __are_same<_ValueType2 &, _ReferenceType2>::__value>::iter_swap(__a, __b);
    }

;
    template <typename _ForwardIterator1, typename _ForwardIterator2> _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)     {
        ;
        for (; __first1 != __last1; ++__first1 , ++__first2) 
            std::iter_swap(__first1, __first2);
        return __first2;
    }

;
    template <typename _Tp = unsigned long> inline const unsigned long &min(const unsigned long &__a, const unsigned long &__b)template <typename _Tp = long> inline const long &min(const long &__a, const long &__b)template <typename _Tp> inline const _Tp &min(const _Tp &__a, const _Tp &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }

;
    template <typename _Tp> inline const _Tp &max(const _Tp &__a, const _Tp &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }

;
    template <typename _Tp, typename _Compare> inline const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp)     {
        if (__comp(__b, __a))
            return __b;
        return __a;
    }

;
    template <typename _Tp, typename _Compare> inline const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp)     {
        if (__comp(__a, __b))
            return __b;
        return __a;
    }

;
    template <typename _Iterator> struct _Niter_base : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value> {
    };
    template <typename _Iterator> inline typename _Niter_base<_Iterator>::iterator_type __niter_base(_Iterator __it)     {
        return std::_Niter_base<_Iterator>::_S_base(__it);
    }

;
    template <typename _Iterator> struct _Miter_base : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value> {
    };
    template <typename _Iterator> inline typename _Miter_base<_Iterator>::iterator_type __miter_base(_Iterator __it)     {
        return std::_Miter_base<_Iterator>::_S_base(__it);
    }

;
    template <bool = false, bool = false, typename  = std::random_access_iterator_tag> struct __copy_move {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result)         {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }

;
    }
template <bool, bool, typename > struct __copy_move {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result)         {
            for (; __first != __last; ++__result , ++__first) 
                *__result = *__first;
            return __result;
        }

;
    };
    struct __copy_move {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result)         {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }

;
    };
    struct __copy_move {
        template <typename _Tp> static _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result)         {
            const ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
            return __result + _Num;
        }

;
    };
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_a(_II __first, _II __last, _OI __result)     {
        typedef typename iterator_traits<_II>::value_type _ValueTypeI;
        typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
        typedef typename iterator_traits<_II>::iterator_category _Category;
        const bool __simple = (__is_trivial(_ValueTypeI) && __is_pointer<_II>::__value && __is_pointer<_OI>::__value && __are_same<_ValueTypeI, _ValueTypeO>::__value);
        return std::__copy_move<_IsMove, __simple, _Category>::__copy_m(__first, __last, __result);
    }

;
    template <typename _CharT = char> struct char_traits {
        typedef char char_type;
        typedef int int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(char_type &__c1, const char_type &__c2)         {
            __c1 = __c2;
        }


        static bool eq(const char_type &__c1, const char_type &__c2)         {
            return __c1 == __c2;
        }


        static bool lt(const char_type &__c1, const char_type &__c2)         {
            return (static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2));
        }


        static int compare(const char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return 0;
            return __builtin_memcmp(__s1, __s2, __n);
        }


        static size_t length(const char_type *__s)         {
            return __builtin_strlen(__s);
        }


        static const char_type *find(const char_type *__s, size_t __n, const char_type &__a)         {
            if (__n == 0)
                return 0;
            return static_cast<const char_type *>(__builtin_memchr(__s, __a, __n));
        }


        static char_type *move(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<char_type *>(__builtin_memmove(__s1, __s2, __n));
        }


        static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }


        static char_type *assign(char_type *__s, size_t __n, char_type __a)         {
            if (__n == 0)
                return __s;
            return static_cast<char_type *>(__builtin_memset(__s, __a, __n));
        }


        static char_type to_char_type(const int_type &__c)         {
            return static_cast<char_type>(__c);
        }


        static int_type to_int_type(const char_type &__c)         {
            return static_cast<int_type>(static_cast<unsigned char>(__c));
        }


        static bool eq_int_type(const int_type &__c1, const int_type &__c2)         {
            return __c1 == __c2;
        }


        static int_type eof()         {
            return static_cast<int_type>(-1);
        }


        static int_type not_eof(const int_type &__c)         {
            return (__c == eof()) ? 0 : __c;
        }


    }
template <typename _CharT = wchar_t> struct char_traits {
        typedef wchar_t char_type;
        typedef wint_t int_type;
        typedef streamoff off_type;
        typedef wstreampos pos_type;
        typedef mbstate_t state_type;
        static void assign(char_type &__c1, const char_type &__c2)         {
            __c1 = __c2;
        }


        static bool eq(const char_type &__c1, const char_type &__c2)         {
            return __c1 == __c2;
        }


        static bool lt(const char_type &__c1, const char_type &__c2)         {
            return __c1 < __c2;
        }


        static int compare(const char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return 0;
            return wmemcmp(__s1, __s2, __n);
        }


        static size_t length(const char_type *__s)         {
            return wcslen(__s);
        }


        static const char_type *find(const char_type *__s, size_t __n, const char_type &__a)         {
            if (__n == 0)
                return 0;
            return wmemchr(__s, __a, __n);
        }


        static char_type *move(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemmove(__s1, __s2, __n);
        }


        static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemcpy(__s1, __s2, __n);
        }


        static char_type *assign(char_type *__s, size_t __n, char_type __a)         {
            if (__n == 0)
                return __s;
            return wmemset(__s, __a, __n);
        }


        static char_type to_char_type(const int_type &__c)         {
            return char_type(__c);
        }


        static int_type to_int_type(const char_type &__c)         {
            return int_type(__c);
        }


        static bool eq_int_type(const int_type &__c1, const int_type &__c2)         {
            return __c1 == __c2;
        }


        static int_type eof()         {
            return static_cast<int_type>((4294967295U));
        }


        static int_type not_eof(const int_type &__c)         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }


    }
template <typename _CharT> struct char_traits;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class istreambuf_iterator
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class istreambuf_iterator
template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class ostreambuf_iterator
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class ostreambuf_iterator
template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type __copy_move_a2(_CharT *, _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT> >);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type __copy_move_a2(const _CharT *, const _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT> >);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >, istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT *);
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_a2(_II __first, _II __last, _OI __result)     {
        return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }

;
    template <typename _II, typename _OI> inline _OI copy(_II __first, _II __last, _OI __result)     {
        ;
        return (std::__copy_move_a2<__is_move_iterator<_II>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result));
    }

;
    template <bool = false, bool = false, typename  = std::random_access_iterator_tag> struct __copy_move_backward {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            typename iterator_traits<_BI1>::difference_type __n;
            for (__n = __last - __first; __n > 0; --__n) 
                *--__result = *--__last;
            return __result;
        }

;
    }
template <bool, bool, typename > struct __copy_move_backward {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            while (__first != __last)
                *--__result = *--__last;
            return __result;
        }

;
    };
    struct __copy_move_backward {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            typename iterator_traits<_BI1>::difference_type __n;
            for (__n = __last - __first; __n > 0; --__n) 
                *--__result = *--__last;
            return __result;
        }

;
    };
    struct __copy_move_backward {
        template <typename _Tp> static _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result)         {
            const ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
            return __result - _Num;
        }

;
    };
    template <bool _IsMove, typename _BI1, typename _BI2> inline _BI2 __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)     {
        typedef typename iterator_traits<_BI1>::value_type _ValueType1;
        typedef typename iterator_traits<_BI2>::value_type _ValueType2;
        typedef typename iterator_traits<_BI1>::iterator_category _Category;
        const bool __simple = (__is_trivial(_ValueType1) && __is_pointer<_BI1>::__value && __is_pointer<_BI2>::__value && __are_same<_ValueType1, _ValueType2>::__value);
        return std::__copy_move_backward<_IsMove, __simple, _Category>::__copy_move_b(__first, __last, __result);
    }

;
    template <bool _IsMove, typename _BI1, typename _BI2> inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)     {
        return _BI2(std::__copy_move_backward_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }

;
    template <typename _BI1, typename _BI2> inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)     {
        ;
        return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result));
    }

;
    template <typename _ForwardIterator, typename _Tp> inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        for (; __first != __last; ++__first) 
            *__first = __value;
    }

;
    template <typename _ForwardIterator, typename _Tp> inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        const _Tp __tmp = __value;
        for (; __first != __last; ++__first) 
            *__first = __tmp;
    }

;
    template <typename _Tp> inline typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a(_Tp *__first, _Tp *__last, const _Tp &__c)     {
        const _Tp __tmp = __c;
        if (const size_t __len = __last - __first)
            __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

;
    template <typename _ForwardIterator, typename _Tp> inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        ;
        std::__fill_a(std::__niter_base(__first), std::__niter_base(__last), __value);
    }

;
    template <typename _OutputIterator, typename _Size, typename _Tp> inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)     {
        for (decltype(__n + 0) __niter = __n; __niter > 0; --__niter , ++__first) 
            *__first = __value;
        return __first;
    }

;
    template <typename _OutputIterator, typename _Size, typename _Tp> inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)     {
        const _Tp __tmp = __value;
        for (decltype(__n + 0) __niter = __n; __niter > 0; --__niter , ++__first) 
            *__first = __tmp;
        return __first;
    }

;
    template <typename _Size, typename _Tp> inline typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp *>::__type __fill_n_a(_Tp *__first, _Size __n, const _Tp &__c)     {
        std::__fill_a(__first, __first + __n, __c);
        return __first + __n;
    }

;
    template <typename _OI, typename _Size, typename _Tp> inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value)     {
        return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

;
    template <bool _BoolType = true> struct __equal {
        template <typename _Tp> static bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2)         {
            if (const size_t __len = (__last1 - __first1))
                return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
            return true;
        }

;
    }
template <bool _BoolType> struct __equal {
        template <typename _II1, typename _II2> static bool equal(_II1 __first1, _II1 __last1, _II2 __first2)         {
            for (; __first1 != __last1; ++__first1 , ++__first2) 
                if (!(*__first1 == *__first2))
                    return false;
            return true;
        }

;
    };
    struct __equal {
        template <typename _Tp> static bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2)         {
            if (const size_t __len = (__last1 - __first1))
                return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
            return true;
        }

;
    };
    template <typename _II1, typename _II2> inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)     {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        typedef typename iterator_traits<_II2>::value_type _ValueType2;
        const bool __simple = ((__is_integer<_ValueType1>::__value || __is_pointer<_ValueType1>::__value) && __is_pointer<_II1>::__value && __is_pointer<_II2>::__value && __are_same<_ValueType1, _ValueType2>::__value);
        return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

;
    template <typename  = std::random_access_iterator_tag, typename  = std::random_access_iterator_tag> struct __lc_rai {
        template <typename _RAI1, typename _RAI2> static _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2)         {
            const typename iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
            const typename iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
            return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
        }

;
        template <typename _RAI> static bool __cnd2(_RAI, _RAI)         {
            return true;
        }

;
    }
template <typename , typename > struct __lc_rai {
        template <typename _II1, typename _II2> static _II1 __newlast1(_II1, _II1 __last1, _II2, _II2)         {
            return __last1;
        }

;
        template <typename _II> static bool __cnd2(_II __first, _II __last)         {
            return __first != __last;
        }

;
    };
    struct __lc_rai {
        template <typename _RAI1, typename _RAI2> static _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2)         {
            const typename iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
            const typename iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
            return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
        }

;
        template <typename _RAI> static bool __cnd2(_RAI, _RAI)         {
            return true;
        }

;
    };
    template <typename _II1, typename _II2, typename _Compare> bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)     {
        typedef typename iterator_traits<_II1>::iterator_category _Category1;
        typedef typename iterator_traits<_II2>::iterator_category _Category2;
        typedef std::__lc_rai<_Category1, _Category2> __rai_type;
        __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
        for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); ++__first1 , ++__first2) {
            if (__comp(__first1, __first2))
                return true;
            if (__comp(__first2, __first1))
                return false;
        }
        return __first1 == __last1 && __first2 != __last2;
    }

;
    template <bool _BoolType = true> struct __lexicographical_compare {
        template <typename _Tp, typename _Up> static bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2)         {
            const size_t __len1 = __last1 - __first1;
            const size_t __len2 = __last2 - __first2;
            if (const size_t __len = std::min(__len1, __len2))
                if (int __result = __builtin_memcmp(__first1, __first2, __len))
                    return __result < 0;
            return __len1 < __len2;
        }

;
    }
template <bool _BoolType> struct __lexicographical_compare {
        template <typename _II1, typename _II2> static bool __lc(_II1, _II1, _II2, _II2);
    };
    template <typename _II1, typename _II2> bool __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    struct __lexicographical_compare {
        template <typename _Tp, typename _Up> static bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2)         {
            const size_t __len1 = __last1 - __first1;
            const size_t __len2 = __last2 - __first2;
            if (const size_t __len = std::min(__len1, __len2))
                if (int __result = __builtin_memcmp(__first1, __first2, __len))
                    return __result < 0;
            return __len1 < __len2;
        }

;
    };
    template <typename _II1, typename _II2> inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        typedef typename iterator_traits<_II2>::value_type _ValueType2;
        const bool __simple = (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed && __is_pointer<_II1>::__value && __is_pointer<_II2>::__value);
        return std::__lexicographical_compare<__simple>::__lc(__first1, __last1, __first2, __last2);
    }

;
    template <typename _ForwardIterator, typename _Tp, typename _Compare> _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)     {
        typedef typename iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        _DistanceType __len = std::distance(__first, __last);
        while (__len > 0)
            {
                _DistanceType __half = __len >> 1;
                _ForwardIterator __middle = __first;
                std::advance(__middle, __half);
                if (__comp(__middle, __val)) {
                    __first = __middle;
                    ++__first;
                    __len = __len - __half - 1;
                } else
                    __len = __half;
            }
        return __first;
    }

;
    template <typename _ForwardIterator, typename _Tp> inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)     {
        ;
        return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
    }

;
    inline int __lg(int __n)     {
        return sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }


    inline unsigned int __lg(unsigned int __n)     {
        return sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }


    inline long __lg(long __n)     {
        return sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }


    inline unsigned long __lg(unsigned long __n)     {
        return sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }


    inline long long __lg(long long __n)     {
        return sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }


    inline unsigned long long __lg(unsigned long long __n)     {
        return sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }


    template <typename _II1, typename _II2> inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)     {
        ;
        return std::__equal_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2));
    }

;
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)     {
        ;
        for (; __first1 != __last1; ++__first1 , ++__first2) 
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return true;
    }

;
    template <typename _II1, typename _II2> inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        ;
        ;
        return std::__lexicographical_compare_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2));
    }

;
    template <typename _II1, typename _II2, typename _Compare> inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)     {
        ;
        ;
        return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)     {
        while (__first1 != __last1 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }

;
    template <typename _InputIterator1, typename _InputIterator2> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)     {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)     {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }

;
}
namespace __gnu_cxx {
    template <typename _CharT> struct _Char_types {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template <typename _CharT> struct char_traits {
        typedef _CharT char_type;
        typedef typename _Char_types<_CharT>::int_type int_type;
        typedef typename _Char_types<_CharT>::pos_type pos_type;
        typedef typename _Char_types<_CharT>::off_type off_type;
        typedef typename _Char_types<_CharT>::state_type state_type;
        static void assign(char_type &__c1, const char_type &__c2)         {
            __c1 = __c2;
        }


        static bool eq(const char_type &__c1, const char_type &__c2)         {
            return __c1 == __c2;
        }


        static bool lt(const char_type &__c1, const char_type &__c2)         {
            return __c1 < __c2;
        }


        static int compare(const char_type *__s1, const char_type *__s2, std::size_t __n);
        static std::size_t length(const char_type *__s);
        static const char_type *find(const char_type *__s, std::size_t __n, const char_type &__a);
        static char_type *move(char_type *__s1, const char_type *__s2, std::size_t __n);
        static char_type *copy(char_type *__s1, const char_type *__s2, std::size_t __n);
        static char_type *assign(char_type *__s, std::size_t __n, char_type __a);
        static char_type to_char_type(const int_type &__c)         {
            return static_cast<char_type>(__c);
        }


        static int_type to_int_type(const char_type &__c)         {
            return static_cast<int_type>(__c);
        }


        static bool eq_int_type(const int_type &__c1, const int_type &__c2)         {
            return __c1 == __c2;
        }


        static int_type eof()         {
            return static_cast<int_type>(-1);
        }


        static int_type not_eof(const int_type &__c)         {
            return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type());
        }


    };
    int compare(const char_type *__s1, const char_type *__s2, std::size_t __n)     {
        for (std::size_t __i = 0; __i < __n; ++__i) 
            if (lt(__s1[__i], __s2[__i]))
                return -1;
            else if (lt(__s2[__i], __s1[__i]))
                return 1;
        return 0;
    }


    std::size_t length(const char_type *__p)     {
        std::size_t __i = 0;
        while (!eq(__p[__i], char_type()))
            ++__i;
        return __i;
    }


    const typename char_traits<_CharT>::char_type *find(const char_type *__s, std::size_t __n, const char_type &__a)     {
        for (std::size_t __i = 0; __i < __n; ++__i) 
            if (eq(__s[__i], __a))
                return __s + __i;
        return 0;
    }


    typename char_traits<_CharT>::char_type *move(char_type *__s1, const char_type *__s2, std::size_t __n)     {
        return static_cast<_CharT *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type)));
    }


    typename char_traits<_CharT>::char_type *copy(char_type *__s1, const char_type *__s2, std::size_t __n)     {
        std::copy(__s2, __s2 + __n, __s1);
        return __s1;
    }


    typename char_traits<_CharT>::char_type *assign(char_type *__s, std::size_t __n, char_type __a)     {
        std::fill_n(__s, __n, __a);
        return __s;
    }


}
namespace std {
    template <class _CharT = char> struct char_traits {
        typedef char char_type;
        typedef int int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(char_type &__c1, const char_type &__c2)         {
            __c1 = __c2;
        }


        static bool eq(const char_type &__c1, const char_type &__c2)         {
            return __c1 == __c2;
        }


        static bool lt(const char_type &__c1, const char_type &__c2)         {
            return (static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2));
        }


        static int compare(const char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return 0;
            return __builtin_memcmp(__s1, __s2, __n);
        }


        static size_t length(const char_type *__s)         {
            return __builtin_strlen(__s);
        }


        static const char_type *find(const char_type *__s, size_t __n, const char_type &__a)         {
            if (__n == 0)
                return 0;
            return static_cast<const char_type *>(__builtin_memchr(__s, __a, __n));
        }


        static char_type *move(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<char_type *>(__builtin_memmove(__s1, __s2, __n));
        }


        static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }


        static char_type *assign(char_type *__s, size_t __n, char_type __a)         {
            if (__n == 0)
                return __s;
            return static_cast<char_type *>(__builtin_memset(__s, __a, __n));
        }


        static char_type to_char_type(const int_type &__c)         {
            return static_cast<char_type>(__c);
        }


        static int_type to_int_type(const char_type &__c)         {
            return static_cast<int_type>(static_cast<unsigned char>(__c));
        }


        static bool eq_int_type(const int_type &__c1, const int_type &__c2)         {
            return __c1 == __c2;
        }


        static int_type eof()         {
            return static_cast<int_type>(-1);
        }


        static int_type not_eof(const int_type &__c)         {
            return (__c == eof()) ? 0 : __c;
        }


    }
template <class _CharT = wchar_t> struct char_traits {
        typedef wchar_t char_type;
        typedef wint_t int_type;
        typedef streamoff off_type;
        typedef wstreampos pos_type;
        typedef mbstate_t state_type;
        static void assign(char_type &__c1, const char_type &__c2)         {
            __c1 = __c2;
        }


        static bool eq(const char_type &__c1, const char_type &__c2)         {
            return __c1 == __c2;
        }


        static bool lt(const char_type &__c1, const char_type &__c2)         {
            return __c1 < __c2;
        }


        static int compare(const char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return 0;
            return wmemcmp(__s1, __s2, __n);
        }


        static size_t length(const char_type *__s)         {
            return wcslen(__s);
        }


        static const char_type *find(const char_type *__s, size_t __n, const char_type &__a)         {
            if (__n == 0)
                return 0;
            return wmemchr(__s, __a, __n);
        }


        static char_type *move(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemmove(__s1, __s2, __n);
        }


        static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemcpy(__s1, __s2, __n);
        }


        static char_type *assign(char_type *__s, size_t __n, char_type __a)         {
            if (__n == 0)
                return __s;
            return wmemset(__s, __a, __n);
        }


        static char_type to_char_type(const int_type &__c)         {
            return char_type(__c);
        }


        static int_type to_int_type(const char_type &__c)         {
            return int_type(__c);
        }


        static bool eq_int_type(const int_type &__c1, const int_type &__c2)         {
            return __c1 == __c2;
        }


        static int_type eof()         {
            return static_cast<int_type>((4294967295U));
        }


        static int_type not_eof(const int_type &__c)         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }


    }
template <class _CharT> struct char_traits : public __gnu_cxx::char_traits<_CharT> {
    };
    struct char_traits {
        typedef char char_type;
        typedef int int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(char_type &__c1, const char_type &__c2)         {
            __c1 = __c2;
        }


        static bool eq(const char_type &__c1, const char_type &__c2)         {
            return __c1 == __c2;
        }


        static bool lt(const char_type &__c1, const char_type &__c2)         {
            return (static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2));
        }


        static int compare(const char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return 0;
            return __builtin_memcmp(__s1, __s2, __n);
        }


        static size_t length(const char_type *__s)         {
            return __builtin_strlen(__s);
        }


        static const char_type *find(const char_type *__s, size_t __n, const char_type &__a)         {
            if (__n == 0)
                return 0;
            return static_cast<const char_type *>(__builtin_memchr(__s, __a, __n));
        }


        static char_type *move(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<char_type *>(__builtin_memmove(__s1, __s2, __n));
        }


        static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }


        static char_type *assign(char_type *__s, size_t __n, char_type __a)         {
            if (__n == 0)
                return __s;
            return static_cast<char_type *>(__builtin_memset(__s, __a, __n));
        }


        static char_type to_char_type(const int_type &__c)         {
            return static_cast<char_type>(__c);
        }


        static int_type to_int_type(const char_type &__c)         {
            return static_cast<int_type>(static_cast<unsigned char>(__c));
        }


        static bool eq_int_type(const int_type &__c1, const int_type &__c2)         {
            return __c1 == __c2;
        }


        static int_type eof()         {
            return static_cast<int_type>(-1);
        }


        static int_type not_eof(const int_type &__c)         {
            return (__c == eof()) ? 0 : __c;
        }


    };
    struct char_traits {
        typedef wchar_t char_type;
        typedef wint_t int_type;
        typedef streamoff off_type;
        typedef wstreampos pos_type;
        typedef mbstate_t state_type;
        static void assign(char_type &__c1, const char_type &__c2)         {
            __c1 = __c2;
        }


        static bool eq(const char_type &__c1, const char_type &__c2)         {
            return __c1 == __c2;
        }


        static bool lt(const char_type &__c1, const char_type &__c2)         {
            return __c1 < __c2;
        }


        static int compare(const char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return 0;
            return wmemcmp(__s1, __s2, __n);
        }


        static size_t length(const char_type *__s)         {
            return wcslen(__s);
        }


        static const char_type *find(const char_type *__s, size_t __n, const char_type &__a)         {
            if (__n == 0)
                return 0;
            return wmemchr(__s, __a, __n);
        }


        static char_type *move(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemmove(__s1, __s2, __n);
        }


        static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemcpy(__s1, __s2, __n);
        }


        static char_type *assign(char_type *__s, size_t __n, char_type __a)         {
            if (__n == 0)
                return __s;
            return wmemset(__s, __a, __n);
        }


        static char_type to_char_type(const int_type &__c)         {
            return char_type(__c);
        }


        static int_type to_int_type(const char_type &__c)         {
            return int_type(__c);
        }


        static bool eq_int_type(const int_type &__c1, const int_type &__c2)         {
            return __c1 == __c2;
        }


        static int_type eof()         {
            return static_cast<int_type>((4294967295U));
        }


        static int_type not_eof(const int_type &__c)         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }


    };
}
extern "C" {
    struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        char int_p_cs_precedes;
        char int_p_sep_by_space;
        char int_n_cs_precedes;
        char int_n_sep_by_space;
        char int_p_sign_posn;
        char int_n_sign_posn;
    };
    extern char *setlocale(int __category, const char *__locale) throw();
    extern struct lconv *localeconv() throw();
    extern __locale_t newlocale(int __category_mask, const char *__locale, __locale_t __base) throw();
    extern __locale_t duplocale(__locale_t __dataset) throw();
    extern void freelocale(__locale_t __dataset) throw();
    extern __locale_t uselocale(__locale_t __dataset) throw();
}
namespace std {
    using ::lconv;
    using ::setlocale;
    using ::localeconv;
}
namespace __gnu_cxx {
    extern "C" __locale_t __uselocale(__locale_t) throw()
}
namespace std {
    typedef __locale_t __c_locale;
    inline int __convert_from_v(const __c_locale &__cloc __attribute__((unused)), char *__out, const int __size __attribute__((unused)), const char *__fmt, ...)     {
        __c_locale __old = __gnu_cxx::__uselocale(__cloc);
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
        __builtin_va_end(__args);
        __gnu_cxx::__uselocale(__old);
        return __ret;
    }


}
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef long __quad_t;
typedef unsigned long __u_quad_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
struct {
    int __val[2];
} typedef __fsid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef unsigned long __rlim64_t;
typedef unsigned int __id_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt_t;
typedef unsigned long __fsfilcnt64_t;
typedef long __fsword_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned long __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;
typedef long __intptr_t;
typedef unsigned int __socklen_t;
extern "C" {
    enum  {
        _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
        _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
        _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
        _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
        _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
        _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
        _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
        _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
        _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
        _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
        _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
        _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
    };
    extern const unsigned short **__ctype_b_loc() throw() __attribute__((const));
    extern const __int32_t **__ctype_tolower_loc() throw() __attribute__((const));
    extern const __int32_t **__ctype_toupper_loc() throw() __attribute__((const));
    extern int isalnum(int) throw();
    extern int isalpha(int) throw();
    extern int iscntrl(int) throw();
    extern int isdigit(int) throw();
    extern int islower(int) throw();
    extern int isgraph(int) throw();
    extern int isprint(int) throw();
    extern int ispunct(int) throw();
    extern int isspace(int) throw();
    extern int isupper(int) throw();
    extern int isxdigit(int) throw();
    extern int tolower(int __c) throw();
    extern int toupper(int __c) throw();
    extern int isblank(int) throw();
    extern int isctype(int __c, int __mask) throw();
    extern int isascii(int __c) throw();
    extern int toascii(int __c) throw();
    extern int _toupper(int) throw();
    extern int _tolower(int) throw();
    extern int isalnum_l(int, __locale_t) throw();
    extern int isalpha_l(int, __locale_t) throw();
    extern int iscntrl_l(int, __locale_t) throw();
    extern int isdigit_l(int, __locale_t) throw();
    extern int islower_l(int, __locale_t) throw();
    extern int isgraph_l(int, __locale_t) throw();
    extern int isprint_l(int, __locale_t) throw();
    extern int ispunct_l(int, __locale_t) throw();
    extern int isspace_l(int, __locale_t) throw();
    extern int isupper_l(int, __locale_t) throw();
    extern int isxdigit_l(int, __locale_t) throw();
    extern int isblank_l(int, __locale_t) throw();
    extern int __tolower_l(int __c, __locale_t __l) throw();
    extern int tolower_l(int __c, __locale_t __l) throw();
    extern int __toupper_l(int __c, __locale_t __l) throw();
    extern int toupper_l(int __c, __locale_t __l) throw();
}
namespace std {
    using ::isalnum;
    using ::isalpha;
    using ::iscntrl;
    using ::isdigit;
    using ::isgraph;
    using ::islower;
    using ::isprint;
    using ::ispunct;
    using ::isspace;
    using ::isupper;
    using ::isxdigit;
    using ::tolower;
    using ::toupper;
}
namespace std {
    class locale;
    template <typename _Facet = std::__cxx11::collate<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::collate<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::ctype<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::numpunct<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_put<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_get<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::ctype<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::numpunct<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_put<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_get<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet> bool has_facet(const std::locale &) throw();
    template <typename _Facet = std::__cxx11::collate<char>> const std::__cxx11::collate<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::collate<wchar_t>> const std::__cxx11::collate<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::ctype<char>> const std::ctype<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::numpunct<char>> const std::__cxx11::numpunct<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_put<char>> const std::num_put<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_get<char>> const std::num_get<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::ctype<wchar_t>> const std::ctype<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::numpunct<wchar_t>> const std::__cxx11::numpunct<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_put<wchar_t>> const std::num_put<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_get<wchar_t>> const std::num_get<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet> const _Facet &use_facet(const std::locale &);
    template <typename _CharT> bool isspace(_CharT, const std::locale &);
    template <typename _CharT> bool isprint(_CharT, const std::locale &);
    template <typename _CharT> bool iscntrl(_CharT, const std::locale &);
    template <typename _CharT> bool isupper(_CharT, const std::locale &);
    template <typename _CharT> bool islower(_CharT, const std::locale &);
    template <typename _CharT> bool isalpha(_CharT, const std::locale &);
    template <typename _CharT> bool isdigit(_CharT, const std::locale &);
    template <typename _CharT> bool ispunct(_CharT, const std::locale &);
    template <typename _CharT> bool isxdigit(_CharT, const std::locale &);
    template <typename _CharT> bool isalnum(_CharT, const std::locale &);
    template <typename _CharT> bool isgraph(_CharT, const std::locale &);
    template <typename _CharT> _CharT toupper(_CharT, const std::locale &);
    template <typename _CharT> _CharT tolower(_CharT, const std::locale &);
    class ctype_base;
    template <typename _CharT = char> class ctype : public locale::facet, public std::ctype_base {
    public:
        typedef char char_type;
    protected:
        __c_locale _M_c_locale_ctype;
        bool _M_del;
        __to_type _M_toupper;
        __to_type _M_tolower;
        const mask *_M_table;
        mutable char _M_widen_ok;
        mutable char _M_widen[256];
        mutable char _M_narrow[256];
        mutable char _M_narrow_ok;
    public:
        static locale::id id;
        static const size_t table_size = 1 + static_cast<unsigned char>(-1);
        explicit ctype(const mask *__table = 0, bool __del = false, size_t __refs = 0);
        explicit ctype(__c_locale __cloc, const mask *__table = 0, bool __del = false, size_t __refs = 0);
        inline bool is(mask __m, char __c) const;
        inline const char *is(const char *__lo, const char *__hi, mask *__vec) const;
        inline const char *scan_is(mask __m, const char *__lo, const char *__hi) const;
        inline const char *scan_not(mask __m, const char *__lo, const char *__hi) const;
        char_type toupper(char_type __c) const         {
            return this->do_toupper(__c);
        }


        const char_type *toupper(char_type *__lo, const char_type *__hi) const         {
            return this->do_toupper(__lo, __hi);
        }


        char_type tolower(char_type __c) const         {
            return this->do_tolower(__c);
        }


        const char_type *tolower(char_type *__lo, const char_type *__hi) const         {
            return this->do_tolower(__lo, __hi);
        }


        char_type widen(char __c) const         {
            if (this->_M_widen_ok)
                return this->_M_widen[static_cast<unsigned char>(__c)];
            this->_M_widen_init();
            return this->do_widen(__c);
        }


        const char *widen(const char *__lo, const char *__hi, char_type *__to) const         {
            if (this->_M_widen_ok == 1) {
                __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_widen_ok)
                this->_M_widen_init();
            return this->do_widen(__lo, __hi, __to);
        }


        char narrow(char_type __c, char __dfault) const         {
            if (this->_M_narrow[static_cast<unsigned char>(__c)])
                return this->_M_narrow[static_cast<unsigned char>(__c)];
            const char __t = this->do_narrow(__c, __dfault);
            if (__t != __dfault)
                this->_M_narrow[static_cast<unsigned char>(__c)] = __t;
            return __t;
        }


        const char_type *narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const         {
            if (__builtin_expect(this->_M_narrow_ok == 1, true)) {
                __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_narrow_ok)
                this->_M_narrow_init();
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }


        const mask *table() const throw()         {
            return this->_M_table;
        }


        static const mask *classic_table() throw();
    protected:
        virtual ~std::ctype<char>();
        virtual char_type do_toupper(char_type __c) const;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_tolower(char_type __c) const;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_widen(char __c) const         {
            return __c;
        }


        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const         {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }


        virtual char do_narrow(char_type __c, char __dfault) const         {
            return __c;
        }


        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const         {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }


    private:
        void _M_narrow_init() const;
        void _M_widen_init() const;
    }
template <typename _CharT = wchar_t> class ctype : public __ctype_abstract_base<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef wctype_t __wmask_type;
    protected:
        __c_locale _M_c_locale_ctype;
        bool _M_narrow_ok;
        char _M_narrow[128];
        wint_t _M_widen[256];
        mask _M_bit[16];
        __wmask_type _M_wmask[16];
    public:
        static locale::id id;
        explicit ctype(size_t __refs = 0);
        explicit ctype(__c_locale __cloc, size_t __refs = 0);
    protected:
        __wmask_type _M_convert_to_wmask(const mask __m) const throw();
        virtual ~std::ctype<wchar_t>();
        virtual bool do_is(mask __m, char_type __c) const;
        virtual const char_type *do_is(const char_type *__lo, const char_type *__hi, mask *__vec) const;
        virtual const char_type *do_scan_is(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual const char_type *do_scan_not(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual char_type do_toupper(char_type __c) const;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_tolower(char_type __c) const;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const;
        virtual char do_narrow(char_type __c, char __dfault) const;
        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const;
        void _M_initialize_ctype() throw();
    }
template <typename _CharT> class ctype;
    class ctype;
    class ctype;
    template <typename _CharT = char> class ctype_byname
template <typename _CharT = wchar_t> class ctype_byname
template <typename _CharT> class ctype_byname;
    class codecvt_base;
    template <typename _InternT = char, typename _ExternT = char, typename _StateT = __mbstate_t> class codecvt
template <typename _InternT = wchar_t, typename _ExternT = char, typename _StateT = __mbstate_t> class codecvt
template <typename _InternT, typename _ExternT, typename _StateT> class codecvt;
    class codecvt;
    class codecvt;
    template <typename _InternT, typename _ExternT, typename _StateT> class codecvt_byname;
    template <typename _CharT = char, typename _InIter = std::istreambuf_iterator<char, std::char_traits<char> >> class num_get : public locale::facet {
    public:
        typedef char char_type;
        typedef std::istreambuf_iterator<char, std::char_traits<char> > iter_type;
        static locale::id id;
        explicit num_get(size_t __refs);
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~std::num_get<char>();
        iter_type _M_extract_float(iter_type, iter_type, std::ios_base &, ios_base::iostate &, string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> iter_type _M_extract_int(iter_type, iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    }
template <typename _CharT = wchar_t, typename _InIter = std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> >> class num_get : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > iter_type;
        static locale::id id;
        explicit num_get(size_t __refs);
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~std::num_get<wchar_t>();
        iter_type _M_extract_float(iter_type, iter_type, std::ios_base &, ios_base::iostate &, string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> iter_type _M_extract_int(iter_type, iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    }
template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get;
    template <typename _CharT = char, typename _OutIter = std::ostreambuf_iterator<char, std::char_traits<char> >> class num_put : public locale::facet {
    public:
        typedef char char_type;
        typedef std::ostreambuf_iterator<char, std::char_traits<char> > iter_type;
        static locale::id id;
        explicit num_put(size_t __refs);
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> iter_type _M_insert_float(iter_type, std::ios_base &__io, char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, size_t __grouping_size, char_type __sep, const char_type *__p, char_type *__new, char_type *__cs, int &__len) const;
        template <typename _ValueT> iter_type _M_insert_int(iter_type, std::ios_base &__io, char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, size_t __grouping_size, char_type __sep, std::ios_base &__io, char_type *__new, char_type *__cs, int &__len) const;
        void _M_pad(char_type __fill, streamsize __w, std::ios_base &__io, char_type *__new, const char_type *__cs, int &__len) const;
        virtual ~std::num_put<char>();
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, long double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, const void *) const;
    }
template <typename _CharT = wchar_t, typename _OutIter = std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> >> class num_put : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > iter_type;
        static locale::id id;
        explicit num_put(size_t __refs);
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> iter_type _M_insert_float(iter_type, std::ios_base &__io, char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, size_t __grouping_size, char_type __sep, const char_type *__p, char_type *__new, char_type *__cs, int &__len) const;
        template <typename _ValueT> iter_type _M_insert_int(iter_type, std::ios_base &__io, char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, size_t __grouping_size, char_type __sep, std::ios_base &__io, char_type *__new, char_type *__cs, int &__len) const;
        void _M_pad(char_type __fill, streamsize __w, std::ios_base &__io, char_type *__new, const char_type *__cs, int &__len) const;
        virtual ~std::num_put<wchar_t>();
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, long double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, const void *) const;
    }
template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put;
    inline namespace __cxx11 {
        template <typename _CharT = char> class numpunct : public locale::facet {
        public:
            typedef char char_type;
            typedef basic_string<char> string_type;
            typedef __numpunct_cache<char> __cache_type;
        protected:
            __cache_type *_M_data;
        public:
            static locale::id id;
            explicit numpunct(size_t __refs);
            explicit numpunct(__cache_type *__cache, size_t __refs);
            explicit numpunct(__c_locale __cloc, size_t __refs);
            char_type decimal_point() const;
            char_type thousands_sep() const;
            string grouping() const;
            string_type truename() const;
            string_type falsename() const;
        protected:
            virtual ~std::__cxx11::numpunct<char>();
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_truename() const;
            virtual string_type do_falsename() const;
            void _M_initialize_numpunct(__c_locale __cloc);
        }
template <typename _CharT = wchar_t> class numpunct : public locale::facet {
        public:
            typedef wchar_t char_type;
            typedef basic_string<wchar_t> string_type;
            typedef __numpunct_cache<wchar_t> __cache_type;
        protected:
            __cache_type *_M_data;
        public:
            static locale::id id;
            explicit numpunct(size_t __refs);
            explicit numpunct(__cache_type *__cache, size_t __refs);
            explicit numpunct(__c_locale __cloc, size_t __refs);
            char_type decimal_point() const;
            char_type thousands_sep() const;
            string grouping() const;
            string_type truename() const;
            string_type falsename() const;
        protected:
            virtual ~std::__cxx11::numpunct<wchar_t>();
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_truename() const;
            virtual string_type do_falsename() const;
            void _M_initialize_numpunct(__c_locale __cloc);
        }
template <typename _CharT> class numpunct;
        template <typename _CharT = char> class numpunct_byname : public numpunct<char> {
        public:
            typedef char char_type;
            typedef basic_string<char> string_type;
            explicit numpunct_byname(const char *__s, size_t __refs);
        protected:
            virtual ~std::__cxx11::numpunct_byname<char>();
        }
template <typename _CharT = wchar_t> class numpunct_byname : public numpunct<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef basic_string<wchar_t> string_type;
            explicit numpunct_byname(const char *__s, size_t __refs);
        protected:
            virtual ~std::__cxx11::numpunct_byname<wchar_t>();
        }
template <typename _CharT> class numpunct_byname;
    }
    inline namespace __cxx11 {
        template <typename _CharT = char> class collate : public locale::facet {
        public:
            typedef char char_type;
            typedef basic_string<char> string_type;
        protected:
            __c_locale _M_c_locale_collate;
        public:
            static locale::id id;
            explicit collate(size_t __refs);
            explicit collate(__c_locale __cloc, size_t __refs);
            int compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
            string_type transform(const char *__lo, const char *__hi) const;
            long hash(const char *__lo, const char *__hi) const;
            int _M_compare(const char *, const char *) const throw();
            size_t _M_transform(char *, const char *, size_t) const throw();
        protected:
            virtual ~std::__cxx11::collate<char>();
            virtual int do_compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
            virtual string_type do_transform(const char *__lo, const char *__hi) const;
            virtual long do_hash(const char *__lo, const char *__hi) const;
        }
template <typename _CharT = wchar_t> class collate : public locale::facet {
        public:
            typedef wchar_t char_type;
            typedef basic_string<wchar_t> string_type;
        protected:
            __c_locale _M_c_locale_collate;
        public:
            static locale::id id;
            explicit collate(size_t __refs);
            explicit collate(__c_locale __cloc, size_t __refs);
            int compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
            string_type transform(const wchar_t *__lo, const wchar_t *__hi) const;
            long hash(const wchar_t *__lo, const wchar_t *__hi) const;
            int _M_compare(const wchar_t *, const wchar_t *) const throw();
            size_t _M_transform(wchar_t *, const wchar_t *, size_t) const throw();
        protected:
            virtual ~std::__cxx11::collate<wchar_t>();
            virtual int do_compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
            virtual string_type do_transform(const wchar_t *__lo, const wchar_t *__hi) const;
            virtual long do_hash(const wchar_t *__lo, const wchar_t *__hi) const;
        }
template <typename _CharT> class collate;
        template <typename _CharT = char> class collate_byname : public collate<char> {
        public:
            typedef char char_type;
            typedef basic_string<char> string_type;
            explicit collate_byname(const char *__s, size_t __refs);
        protected:
            virtual ~std::__cxx11::collate_byname<char>();
        }
template <typename _CharT = wchar_t> class collate_byname : public collate<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef basic_string<wchar_t> string_type;
            explicit collate_byname(const char *__s, size_t __refs);
        protected:
            virtual ~std::__cxx11::collate_byname<wchar_t>();
        }
template <typename _CharT> class collate_byname;
    }
    class time_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get;
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get_byname;
    }
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put_byname;
    class money_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class money_get;
        template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class money_put;
    }
    inline namespace __cxx11 {
        template <typename _CharT, bool _Intl = false> class moneypunct;
        template <typename _CharT, bool _Intl = false> class moneypunct_byname;
    }
    class messages_base;
    inline namespace __cxx11 {
        template <typename _CharT> class messages;
        template <typename _CharT> class messages_byname;
    }
}
typedef __time_t time_t;
struct __attribute__((visibility("default"))) timespec {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
};
typedef __pid_t pid_t;
struct __attribute__((visibility("default"))) sched_param {
    int __sched_priority;
};
extern "C" {
    extern int clone(int (*__fn)(void *), void *__child_stack, int __flags, void *__arg, ...) throw() __attribute__((visibility("default")));
    extern int unshare(int __flags) throw() __attribute__((visibility("default")));
    extern int sched_getcpu() throw() __attribute__((visibility("default")));
    extern int setns(int __fd, int __nstype) throw() __attribute__((visibility("default")));
}
struct __attribute__((visibility("default"))) __sched_param {
    int __sched_priority;
};
typedef unsigned long __cpu_mask;
struct __attribute__((visibility("default"))) {
    __cpu_mask __bits[16];
} typedef cpu_set_t;
extern "C" {
    extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp) throw() __attribute__((visibility("default")));
    extern cpu_set_t *__sched_cpualloc(size_t __count) throw() __attribute__((visibility("default")));
    extern void __sched_cpufree(cpu_set_t *__set) throw() __attribute__((visibility("default")));
}
extern "C" {
    extern int sched_setparam(__pid_t __pid, const struct sched_param *__param) throw() __attribute__((visibility("default")));
    extern int sched_getparam(__pid_t __pid, struct sched_param *__param) throw() __attribute__((visibility("default")));
    extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param) throw() __attribute__((visibility("default")));
    extern int sched_getscheduler(__pid_t __pid) throw() __attribute__((visibility("default")));
    extern int sched_yield() throw() __attribute__((visibility("default")));
    extern int sched_get_priority_max(int __algorithm) throw() __attribute__((visibility("default")));
    extern int sched_get_priority_min(int __algorithm) throw() __attribute__((visibility("default")));
    extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t) throw() __attribute__((visibility("default")));
    extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize, const cpu_set_t *__cpuset) throw() __attribute__((visibility("default")));
    extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize, cpu_set_t *__cpuset) throw() __attribute__((visibility("default")));
}
extern "C" {
    struct __attribute__((visibility("default"))) timeval {
        __time_t tv_sec;
        __suseconds_t tv_usec;
    };
    struct __attribute__((visibility("default"))) timex {
        unsigned int modes;
        __syscall_slong_t offset;
        __syscall_slong_t freq;
        __syscall_slong_t maxerror;
        __syscall_slong_t esterror;
        int status;
        __syscall_slong_t constant;
        __syscall_slong_t precision;
        __syscall_slong_t tolerance;
        struct timeval time;
        __syscall_slong_t tick;
        __syscall_slong_t ppsfreq;
        __syscall_slong_t jitter;
        int shift;
        __syscall_slong_t stabil;
        __syscall_slong_t jitcnt;
        __syscall_slong_t calcnt;
        __syscall_slong_t errcnt;
        __syscall_slong_t stbcnt;
        int tai;
        int : 32;
        int : 32;
        int : 32;
        int : 32;
        int : 32;
        int : 32;
        int : 32;
        int : 32;
        int : 32;
        int : 32;
        int : 32;
    };
    extern "C" {
        extern int clock_adjtime(__clockid_t __clock_id, struct timex *__utx) throw() __attribute__((visibility("default")));
    }
    typedef __clock_t clock_t;
    typedef __clockid_t clockid_t;
    typedef __timer_t timer_t;
    struct __attribute__((visibility("default"))) tm {
        int tm_sec;
        int tm_min;
        int tm_hour;
        int tm_mday;
        int tm_mon;
        int tm_year;
        int tm_wday;
        int tm_yday;
        int tm_isdst;
        long tm_gmtoff;
        const char *tm_zone;
    };
    struct __attribute__((visibility("default"))) itimerspec {
        struct timespec it_interval;
        struct timespec it_value;
    };
    struct __attribute__((visibility("default"))) sigevent;
    extern clock_t clock() throw() __attribute__((visibility("default")));
    extern time_t time(time_t *__timer) throw() __attribute__((visibility("default")));
    extern double difftime(time_t __time1, time_t __time0) throw() __attribute__((const)) __attribute__((visibility("default")));
    extern time_t mktime(struct tm *__tp) throw() __attribute__((visibility("default")));
    extern size_t strftime(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp) throw() __attribute__((visibility("default")));
    extern char *strptime(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp) throw() __attribute__((visibility("default")));
    extern size_t strftime_l(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp, __locale_t __loc) throw() __attribute__((visibility("default")));
    extern char *strptime_l(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp, __locale_t __loc) throw() __attribute__((visibility("default")));
    extern struct tm *gmtime(const time_t *__timer) throw() __attribute__((visibility("default")));
    extern struct tm *localtime(const time_t *__timer) throw() __attribute__((visibility("default")));
    extern struct tm *gmtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) throw() __attribute__((visibility("default")));
    extern struct tm *localtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) throw() __attribute__((visibility("default")));
    extern char *asctime(const struct tm *__tp) throw() __attribute__((visibility("default")));
    extern char *ctime(const time_t *__timer) throw() __attribute__((visibility("default")));
    extern char *asctime_r(const struct tm *__restrict __tp, char *__restrict __buf) throw() __attribute__((visibility("default")));
    extern char *ctime_r(const time_t *__restrict __timer, char *__restrict __buf) throw() __attribute__((visibility("default")));
    extern char *__tzname[2] __attribute__((visibility("default")));
    extern int __daylight __attribute__((visibility("default")));
    extern long __timezone __attribute__((visibility("default")));
    extern char *tzname[2] __attribute__((visibility("default")));
    extern void tzset() throw() __attribute__((visibility("default")));
    extern int daylight __attribute__((visibility("default")));
    extern long timezone __attribute__((visibility("default")));
    extern int stime(const time_t *__when) throw() __attribute__((visibility("default")));
    extern time_t timegm(struct tm *__tp) throw() __attribute__((visibility("default")));
    extern time_t timelocal(struct tm *__tp) throw() __attribute__((visibility("default")));
    extern int dysize(int __year) throw() __attribute__((const)) __attribute__((visibility("default")));
    extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining) __attribute__((visibility("default")));
    extern int clock_getres(clockid_t __clock_id, struct timespec *__res) throw() __attribute__((visibility("default")));
    extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp) throw() __attribute__((visibility("default")));
    extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp) throw() __attribute__((visibility("default")));
    extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem) __attribute__((visibility("default")));
    extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id) throw() __attribute__((visibility("default")));
    extern int timer_create(clockid_t __clock_id, struct sigevent *__restrict __evp, timer_t *__restrict __timerid) throw() __attribute__((visibility("default")));
    extern int timer_delete(timer_t __timerid) throw() __attribute__((visibility("default")));
    extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *__restrict __value, struct itimerspec *__restrict __ovalue) throw() __attribute__((visibility("default")));
    extern int timer_gettime(timer_t __timerid, struct itimerspec *__value) throw() __attribute__((visibility("default")));
    extern int timer_getoverrun(timer_t __timerid) throw() __attribute__((visibility("default")));
    extern int timespec_get(struct timespec *__ts, int __base) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int getdate_err __attribute__((visibility("default")));
    extern struct tm *getdate(const char *__string) __attribute__((visibility("default")));
    extern int getdate_r(const char *__restrict __string, struct tm *__restrict __resbufp) __attribute__((visibility("default")));
}
typedef unsigned long pthread_t;
union __attribute__((visibility("default"))) pthread_attr_t {
    char __size[56];
    long __align;
};
typedef union pthread_attr_t pthread_attr_t;
struct __attribute__((visibility("default"))) __pthread_internal_list {
    struct __pthread_internal_list *__prev;
    struct __pthread_internal_list *__next;
};
typedef struct __pthread_internal_list __pthread_list_t;
union __attribute__((visibility("default"))) {
    struct __attribute__((visibility("default"))) __pthread_mutex_s {
        int __lock;
        unsigned int __count;
        int __owner;
        unsigned int __nusers;
        int __kind;
        short __spins;
        short __elision;
        __pthread_list_t __list;
    };
    struct __pthread_mutex_s __data;
    char __size[40];
    long __align;
} typedef pthread_mutex_t;
union __attribute__((visibility("default"))) {
    char __size[4];
    int __align;
} typedef pthread_mutexattr_t;
union __attribute__((visibility("default"))) {
    struct __attribute__((visibility("default"))) {
        int __lock;
        unsigned int __futex;
        unsigned long long __total_seq;
        unsigned long long __wakeup_seq;
        unsigned long long __woken_seq;
        void *__mutex;
        unsigned int __nwaiters;
        unsigned int __broadcast_seq;
    } __data;
    char __size[48];
    long long __align;
} typedef pthread_cond_t;
union __attribute__((visibility("default"))) {
    char __size[4];
    int __align;
} typedef pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union __attribute__((visibility("default"))) {
    struct __attribute__((visibility("default"))) {
        int __lock;
        unsigned int __nr_readers;
        unsigned int __readers_wakeup;
        unsigned int __writer_wakeup;
        unsigned int __nr_readers_queued;
        unsigned int __nr_writers_queued;
        int __writer;
        int __shared;
        signed char __rwelision;
        unsigned char __pad1[7];
        unsigned long __pad2;
        unsigned int __flags;
    } __data;
    char __size[56];
    long __align;
} typedef pthread_rwlock_t;
union __attribute__((visibility("default"))) {
    char __size[8];
    long __align;
} typedef pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
union __attribute__((visibility("default"))) {
    char __size[32];
    long __align;
} typedef pthread_barrier_t;
union __attribute__((visibility("default"))) {
    char __size[4];
    int __align;
} typedef pthread_barrierattr_t;
typedef long __jmp_buf[8];
enum  {
    PTHREAD_CREATE_JOINABLE,
    PTHREAD_CREATE_DETACHED
} __attribute__((visibility("default")));
enum  {
    PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_ADAPTIVE_NP,
    PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL,
    PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
} __attribute__((visibility("default")));
enum  {
    PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_ROBUST,
    PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
} __attribute__((visibility("default")));
enum  {
    PTHREAD_PRIO_NONE,
    PTHREAD_PRIO_INHERIT,
    PTHREAD_PRIO_PROTECT
} __attribute__((visibility("default")));
enum  {
    PTHREAD_RWLOCK_PREFER_READER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
    PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
} __attribute__((visibility("default")));
enum  {
    PTHREAD_INHERIT_SCHED,
    PTHREAD_EXPLICIT_SCHED
} __attribute__((visibility("default")));
enum  {
    PTHREAD_SCOPE_SYSTEM,
    PTHREAD_SCOPE_PROCESS
} __attribute__((visibility("default")));
enum  {
    PTHREAD_PROCESS_PRIVATE,
    PTHREAD_PROCESS_SHARED
} __attribute__((visibility("default")));
struct __attribute__((visibility("default"))) _pthread_cleanup_buffer {
    void (*__routine)(void *);
    void *__arg;
    int __canceltype;
    struct _pthread_cleanup_buffer *__prev;
};
enum  {
    PTHREAD_CANCEL_ENABLE,
    PTHREAD_CANCEL_DISABLE
} __attribute__((visibility("default")));
enum  {
    PTHREAD_CANCEL_DEFERRED,
    PTHREAD_CANCEL_ASYNCHRONOUS
} __attribute__((visibility("default")));
extern "C" {
    extern int pthread_create(pthread_t *__restrict __newthread, const pthread_attr_t *__restrict __attr, void *(*__start_routine)(void *), void *__restrict __arg) throw() __attribute__((nonnull(0, 2))) __attribute__((visibility("default")));
    extern void pthread_exit(void *__retval) __attribute__((visibility("default")));
    extern int pthread_join(pthread_t __th, void **__thread_return) __attribute__((visibility("default")));
    extern int pthread_tryjoin_np(pthread_t __th, void **__thread_return) throw() __attribute__((visibility("default")));
    extern int pthread_timedjoin_np(pthread_t __th, void **__thread_return, const struct timespec *__abstime) __attribute__((visibility("default")));
    extern int pthread_detach(pthread_t __th) throw() __attribute__((visibility("default")));
    extern pthread_t pthread_self() throw() __attribute__((const)) __attribute__((visibility("default")));
    extern int pthread_equal(pthread_t __thread1, pthread_t __thread2) throw() __attribute__((const)) __attribute__((visibility("default")));
    extern int pthread_attr_init(pthread_attr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_attr_destroy(pthread_attr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_attr_getschedparam(const pthread_attr_t *__restrict __attr, struct sched_param *__restrict __param) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_attr_setschedparam(pthread_attr_t *__restrict __attr, const struct sched_param *__restrict __param) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict __attr, int *__restrict __policy) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_attr_getinheritsched(const pthread_attr_t *__restrict __attr, int *__restrict __inherit) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_attr_getscope(const pthread_attr_t *__restrict __attr, int *__restrict __scope) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_attr_getstackaddr(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr) throw() __attribute__((deprecated(""))) __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr) throw() __attribute__((deprecated(""))) __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_attr_getstacksize(const pthread_attr_t *__restrict __attr, size_t *__restrict __stacksize) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_attr_getstack(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr, size_t *__restrict __stacksize) throw() __attribute__((nonnull(0, 1, 2))) __attribute__((visibility("default")));
    extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_attr_setaffinity_np(pthread_attr_t *__attr, size_t __cpusetsize, const cpu_set_t *__cpuset) throw() __attribute__((nonnull(0, 2))) __attribute__((visibility("default")));
    extern int pthread_attr_getaffinity_np(const pthread_attr_t *__attr, size_t __cpusetsize, cpu_set_t *__cpuset) throw() __attribute__((nonnull(0, 2))) __attribute__((visibility("default")));
    extern int pthread_getattr_default_np(pthread_attr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_setattr_default_np(const pthread_attr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_getattr_np(pthread_t __th, pthread_attr_t *__attr) throw() __attribute__((nonnull(1))) __attribute__((visibility("default")));
    extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param) throw() __attribute__((nonnull(2))) __attribute__((visibility("default")));
    extern int pthread_getschedparam(pthread_t __target_thread, int *__restrict __policy, struct sched_param *__restrict __param) throw() __attribute__((nonnull(1, 2))) __attribute__((visibility("default")));
    extern int pthread_setschedprio(pthread_t __target_thread, int __prio) throw() __attribute__((visibility("default")));
    extern int pthread_getname_np(pthread_t __target_thread, char *__buf, size_t __buflen) throw() __attribute__((nonnull(1))) __attribute__((visibility("default")));
    extern int pthread_setname_np(pthread_t __target_thread, const char *__name) throw() __attribute__((nonnull(1))) __attribute__((visibility("default")));
    extern int pthread_getconcurrency() throw() __attribute__((visibility("default")));
    extern int pthread_setconcurrency(int __level) throw() __attribute__((visibility("default")));
    extern int pthread_yield() throw() __attribute__((visibility("default")));
    extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize, const cpu_set_t *__cpuset) throw() __attribute__((nonnull(2))) __attribute__((visibility("default")));
    extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize, cpu_set_t *__cpuset) throw() __attribute__((nonnull(2))) __attribute__((visibility("default")));
    extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)()) __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_setcancelstate(int __state, int *__oldstate) __attribute__((visibility("default")));
    extern int pthread_setcanceltype(int __type, int *__oldtype) __attribute__((visibility("default")));
    extern int pthread_cancel(pthread_t __th) __attribute__((visibility("default")));
    extern void pthread_testcancel() __attribute__((visibility("default")));
    struct __attribute__((visibility("default"))) {
        struct __attribute__((visibility("default"))) {
            __jmp_buf __cancel_jmp_buf;
            int __mask_was_saved;
        } __cancel_jmp_buf[1];
        void *__pad[4];
    } typedef __pthread_unwind_buf_t __attribute__((aligned()));
    struct __attribute__((visibility("default"))) __pthread_cleanup_frame {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    };
    class __attribute__((visibility("default"))) __pthread_cleanup_class {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    public:
        __pthread_cleanup_class(void (*__fct)(void *), void *__arg) : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1)         {
        }


        ~__pthread_cleanup_class()         {
            if (this->__do_it)
                this->__cancel_routine(this->__cancel_arg);
        }


        void __setdoit(int __newval)         {
            this->__do_it = __newval;
        }


        void __defer()         {
            pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &this->__cancel_type);
        }


        void __restore() const         {
            pthread_setcanceltype(this->__cancel_type, 0);
        }


    };
    struct __attribute__((visibility("default"))) __jmp_buf_tag;
    extern int __sigsetjmp(struct __jmp_buf_tag *__env, int __savemask) throw() __attribute__((returns_twice)) __attribute__((visibility("default")));
    extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutex_destroy(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutex_trylock(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutex_lock(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutex_timedlock(pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_mutex_unlock(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) throw() __attribute__((nonnull(0, 2))) __attribute__((visibility("default")));
    extern int pthread_mutex_consistent(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutex_consistent_np(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_rwlock_init(pthread_rwlock_t *__restrict __rwlock, const pthread_rwlockattr_t *__restrict __attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr, int __pshared) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr, int __pref) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_cond_init(pthread_cond_t *__restrict __cond, const pthread_condattr_t *__restrict __cond_attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_cond_destroy(pthread_cond_t *__cond) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_cond_signal(pthread_cond_t *__cond) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_cond_broadcast(pthread_cond_t *__cond) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_cond_wait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex) __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_cond_timedwait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) __attribute__((nonnull(0, 1, 2))) __attribute__((visibility("default")));
    extern int pthread_condattr_init(pthread_condattr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_condattr_destroy(pthread_condattr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_condattr_getpshared(const pthread_condattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_condattr_setpshared(pthread_condattr_t *__attr, int __pshared) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_condattr_getclock(const pthread_condattr_t *__restrict __attr, __clockid_t *__restrict __clock_id) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_condattr_setclock(pthread_condattr_t *__attr, __clockid_t __clock_id) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_spin_init(pthread_spinlock_t *__lock, int __pshared) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_spin_destroy(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_spin_lock(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_spin_trylock(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_spin_unlock(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_barrier_init(pthread_barrier_t *__restrict __barrier, const pthread_barrierattr_t *__restrict __attr, unsigned int __count) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_barrier_destroy(pthread_barrier_t *__barrier) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_barrier_wait(pthread_barrier_t *__barrier) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_barrierattr_init(pthread_barrierattr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(0, 1))) __attribute__((visibility("default")));
    extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr, int __pshared) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_key_create(pthread_key_t *__key, void (*__destr_function)(void *)) throw() __attribute__((nonnull(0))) __attribute__((visibility("default")));
    extern int pthread_key_delete(pthread_key_t __key) throw() __attribute__((visibility("default")));
    extern void *pthread_getspecific(pthread_key_t __key) throw() __attribute__((visibility("default")));
    extern int pthread_setspecific(pthread_key_t __key, const void *__pointer) throw() __attribute__((visibility("default")));
    extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t *__clock_id) throw() __attribute__((nonnull(1))) __attribute__((visibility("default")));
    extern int pthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)()) throw() __attribute__((visibility("default")));
}
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
static int __gthrw_pthread_once(pthread_once_t *, void (*)()) __attribute__((alias("pthread_once"))) __attribute__((weakref("")));
static void *__gthrw_pthread_getspecific(pthread_key_t) throw() __attribute__((alias("pthread_getspecific"))) __attribute__((weakref("")));
static int __gthrw_pthread_setspecific(pthread_key_t, const void *) throw() __attribute__((alias("pthread_setspecific"))) __attribute__((weakref("")));
static int __gthrw_pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void *(*)(void *), void *__restrict) throw() __attribute__((alias("pthread_create"))) __attribute__((weakref("")));
static int __gthrw_pthread_join(pthread_t, void **) __attribute__((alias("pthread_join"))) __attribute__((weakref("")));
static int __gthrw_pthread_equal(pthread_t, pthread_t) throw() __attribute__((alias("pthread_equal"))) __attribute__((weakref("")));
static pthread_t __gthrw_pthread_self() throw() __attribute__((alias("pthread_self"))) __attribute__((weakref("")));
static int __gthrw_pthread_detach(pthread_t) throw() __attribute__((alias("pthread_detach"))) __attribute__((weakref("")));
static int __gthrw_pthread_cancel(pthread_t) __attribute__((alias("pthread_cancel"))) __attribute__((weakref("")));
static int __gthrw_sched_yield() throw() __attribute__((alias("sched_yield"))) __attribute__((weakref("")));
static int __gthrw_pthread_mutex_lock(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_lock"))) __attribute__((weakref("")));
static int __gthrw_pthread_mutex_trylock(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_trylock"))) __attribute__((weakref("")));
static int __gthrw_pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict) throw() __attribute__((alias("pthread_mutex_timedlock"))) __attribute__((weakref("")));
static int __gthrw_pthread_mutex_unlock(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_unlock"))) __attribute__((weakref("")));
static int __gthrw_pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *) throw() __attribute__((alias("pthread_mutex_init"))) __attribute__((weakref("")));
static int __gthrw_pthread_mutex_destroy(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_destroy"))) __attribute__((weakref("")));
static int __gthrw_pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict) throw() __attribute__((alias("pthread_cond_init"))) __attribute__((weakref("")));
static int __gthrw_pthread_cond_broadcast(pthread_cond_t *) throw() __attribute__((alias("pthread_cond_broadcast"))) __attribute__((weakref("")));
static int __gthrw_pthread_cond_signal(pthread_cond_t *) throw() __attribute__((alias("pthread_cond_signal"))) __attribute__((weakref("")));
static int __gthrw_pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict) __attribute__((alias("pthread_cond_wait"))) __attribute__((weakref("")));
static int __gthrw_pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict) __attribute__((alias("pthread_cond_timedwait"))) __attribute__((weakref("")));
static int __gthrw_pthread_cond_destroy(pthread_cond_t *) throw() __attribute__((alias("pthread_cond_destroy"))) __attribute__((weakref("")));
static int __gthrw_pthread_key_create(pthread_key_t *, void (*)(void *)) throw() __attribute__((alias("pthread_key_create"))) __attribute__((weakref("")));
static int __gthrw_pthread_key_delete(pthread_key_t) throw() __attribute__((alias("pthread_key_delete"))) __attribute__((weakref("")));
static int __gthrw_pthread_mutexattr_init(pthread_mutexattr_t *) throw() __attribute__((alias("pthread_mutexattr_init"))) __attribute__((weakref("")));
static int __gthrw_pthread_mutexattr_settype(pthread_mutexattr_t *, int) throw() __attribute__((alias("pthread_mutexattr_settype"))) __attribute__((weakref("")));
static int __gthrw_pthread_mutexattr_destroy(pthread_mutexattr_t *) throw() __attribute__((alias("pthread_mutexattr_destroy"))) __attribute__((weakref("")));
static int __gthrw___pthread_key_create(pthread_key_t *, void (*)(void *)) throw() __attribute__((alias("__pthread_key_create"))) __attribute__((weakref("")));
static inline int __gthread_active_p() {
    static void *const __gthread_active_ptr = __extension__ (void *)&__gthrw___pthread_key_create;
    return __gthread_active_ptr != 0;
}


static inline int __gthread_create(__gthread_t *__threadid, void *(*__func)(void *), void *__args) {
    return __gthrw_pthread_create(__threadid, __null, __func, __args);
}


static inline int __gthread_join(__gthread_t __threadid, void **__value_ptr) {
    return __gthrw_pthread_join(__threadid, __value_ptr);
}


static inline int __gthread_detach(__gthread_t __threadid) {
    return __gthrw_pthread_detach(__threadid);
}


static inline int __gthread_equal(__gthread_t __t1, __gthread_t __t2) {
    return __gthrw_pthread_equal(__t1, __t2);
}


static inline __gthread_t __gthread_self() {
    return __gthrw_pthread_self();
}


static inline int __gthread_yield() {
    return __gthrw_sched_yield();
}


static inline int __gthread_once(__gthread_once_t *__once, void (*__func)()) {
    if (__gthread_active_p())
        return __gthrw_pthread_once(__once, __func);
    else
        return -1;
}


static inline int __gthread_key_create(__gthread_key_t *__key, void (*__dtor)(void *)) {
    return __gthrw_pthread_key_create(__key, __dtor);
}


static inline int __gthread_key_delete(__gthread_key_t __key) {
    return __gthrw_pthread_key_delete(__key);
}


static inline void *__gthread_getspecific(__gthread_key_t __key) {
    return __gthrw_pthread_getspecific(__key);
}


static inline int __gthread_setspecific(__gthread_key_t __key, const void *__ptr) {
    return __gthrw_pthread_setspecific(__key, __ptr);
}


static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        __gthrw_pthread_mutex_init(__mutex, __null);
}


static inline int __gthread_mutex_destroy(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_destroy(__mutex);
    else
        return 0;
}


static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_lock(__mutex);
    else
        return 0;
}


static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_trylock(__mutex);
    else
        return 0;
}


static inline int __gthread_mutex_timedlock(__gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_timedlock(__mutex, __abs_timeout);
    else
        return 0;
}


static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_unlock(__mutex);
    else
        return 0;
}


static inline int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_lock(__mutex);
}


static inline int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_trylock(__mutex);
}


static inline int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return __gthread_mutex_timedlock(__mutex, __abs_timeout);
}


static inline int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_unlock(__mutex);
}


static inline int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_destroy(__mutex);
}


static inline int __gthread_cond_broadcast(__gthread_cond_t *__cond) {
    return __gthrw_pthread_cond_broadcast(__cond);
}


static inline int __gthread_cond_signal(__gthread_cond_t *__cond) {
    return __gthrw_pthread_cond_signal(__cond);
}


static inline int __gthread_cond_wait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex) {
    return __gthrw_pthread_cond_wait(__cond, __mutex);
}


static inline int __gthread_cond_timedwait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return __gthrw_pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}


static inline int __gthread_cond_wait_recursive(__gthread_cond_t *__cond, __gthread_recursive_mutex_t *__mutex) {
    return __gthread_cond_wait(__cond, __mutex);
}


static inline int __gthread_cond_destroy(__gthread_cond_t *__cond) {
    return __gthrw_pthread_cond_destroy(__cond);
}


typedef int _Atomic_word;
namespace __gnu_cxx {
    static inline _Atomic_word __exchange_and_add(volatile _Atomic_word *__mem, int __val)     {
        return __atomic_fetch_add(__mem, __val, 4);
    }


    static inline void __atomic_add(volatile _Atomic_word *__mem, int __val)     {
        __atomic_fetch_add(__mem, __val, 4);
    }


    static inline _Atomic_word __exchange_and_add_single(_Atomic_word *__mem, int __val)     {
        _Atomic_word __result = *__mem;
        *__mem += __val;
        return __result;
    }


    static inline void __atomic_add_single(_Atomic_word *__mem, int __val)     {
        *__mem += __val;
    }


    static inline _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((unused))     {
        if (__gthread_active_p())
            return __exchange_and_add(__mem, __val);
        else
            return __exchange_and_add_single(__mem, __val);
    }


    static inline void __atomic_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((unused))     {
        if (__gthread_active_p())
            __atomic_add(__mem, __val);
        else
            __atomic_add_single(__mem, __val);
    }


}
extern "C++" {
    namespace std {
        class __attribute__((visibility("default"))) bad_alloc : public std::exception {
        public:
            bad_alloc() throw() : std::exception()             {
            }


            virtual ~std::bad_alloc() throw();
            virtual const char *what() const throw();
        };
        struct __attribute__((visibility("default"))) nothrow_t {
        };
        extern const std::nothrow_t nothrow __attribute__((visibility("default")));
        typedef void (*new_handler)();
        new_handler set_new_handler(new_handler) throw() __attribute__((visibility("default")));
    }
    void *operator new(std::size_t) throw(std::bad_alloc) __attribute__((visibility("default"))) __attribute__((malloc));
    void *operator new[](std::size_t) throw(std::bad_alloc) __attribute__((visibility("default"))) __attribute__((malloc));
    void operator delete(void *) throw() __attribute__((visibility("default")));
    void operator delete[](void *) throw() __attribute__((visibility("default")));
    void *operator new(std::size_t, const std::nothrow_t &) throw() __attribute__((visibility("default")));
    void *operator new[](std::size_t, const std::nothrow_t &) throw() __attribute__((visibility("default")));
    void operator delete(void *, const std::nothrow_t &) throw() __attribute__((visibility("default")));
    void operator delete[](void *, const std::nothrow_t &) throw() __attribute__((visibility("default")));
    inline void *operator new(std::size_t, void *__p) throw() __attribute__((visibility("default")))     {
        return __p;
    }


    inline void *operator new[](std::size_t, void *__p) throw() __attribute__((visibility("default")))     {
        return __p;
    }


    inline void operator delete(void *, void *) throw() __attribute__((visibility("default")))     {
    }


    inline void operator delete[](void *, void *) throw() __attribute__((visibility("default")))     {
    }


}
namespace __gnu_cxx {
    using std::size_t;
    using std::ptrdiff_t;
    template <typename _Tp = char> class new_allocator {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef char value_type;
        template <typename _Tp1> struct rebind;
        new_allocator() throw()         {
        }


        new_allocator(const __gnu_cxx::new_allocator<char> &) throw()         {
        }


        template <typename _Tp1 = char> new_allocator(const new_allocator<char> &) throw()template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) throw();
        ~__gnu_cxx::new_allocator<char>() throw()         {
        }


        pointer address(reference __x) const;
        const_pointer address(const_reference __x) const;
        pointer allocate(size_type __n, const void *);
        void deallocate(pointer __p, size_type)         {
            ::operator delete(__p);
        }


        size_type max_size() const throw();
        void construct(pointer __p, const char &__val);
        void destroy(pointer __p);
    }
template <typename _Tp = wchar_t> class new_allocator {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef const wchar_t *const_pointer;
        typedef wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef wchar_t value_type;
        template <typename _Tp1> struct rebind;
        new_allocator() throw();
        new_allocator(const __gnu_cxx::new_allocator<wchar_t> &) throw();
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) throw();
        ~__gnu_cxx::new_allocator<wchar_t>() throw();
        pointer address(reference __x) const;
        const_pointer address(const_reference __x) const;
        pointer allocate(size_type __n, const void *);
        void deallocate(pointer __p, size_type);
        size_type max_size() const throw();
        void construct(pointer __p, const wchar_t &__val);
        void destroy(pointer __p);
    }
template <typename _Tp = Player> class new_allocator {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef Player *pointer;
        typedef const Player *const_pointer;
        typedef Player &reference;
        typedef const Player &const_reference;
        typedef Player value_type;
        template <typename _Tp1> struct rebind;
        new_allocator() throw();
        new_allocator(const __gnu_cxx::new_allocator<Player> &) throw();
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) throw();
        ~__gnu_cxx::new_allocator<Player>() throw();
        pointer address(reference __x) const;
        const_pointer address(const_reference __x) const;
        pointer allocate(size_type __n, const void *);
        void deallocate(pointer __p, size_type);
        size_type max_size() const throw();
        void construct(pointer __p, const Player &__val);
        void destroy(pointer __p);
    }
template <typename _Tp = std::_List_node<Player>> class new_allocator {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef std::_List_node<Player> *pointer;
        typedef const std::_List_node<Player> *const_pointer;
        typedef std::_List_node<Player> &reference;
        typedef const std::_List_node<Player> &const_reference;
        typedef std::_List_node<Player> value_type;
        template <typename _Tp1> struct rebind;
        new_allocator() throw();
        new_allocator(const __gnu_cxx::new_allocator<std::_List_node<Player> > &) throw();
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) throw();
        ~__gnu_cxx::new_allocator<std::_List_node<Player> >() throw();
        pointer address(reference __x) const;
        const_pointer address(const_reference __x) const;
        pointer allocate(size_type __n, const void *);
        void deallocate(pointer __p, size_type);
        size_type max_size() const throw();
        void construct(pointer __p, const std::_List_node<Player> &__val);
        void destroy(pointer __p);
    }
template <typename _Tp> class new_allocator {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef const _Tp *const_pointer;
        typedef _Tp &reference;
        typedef const _Tp &const_reference;
        typedef _Tp value_type;
        template <typename _Tp1> struct rebind {
            typedef new_allocator<_Tp1> other;
        };
        new_allocator<_Tp>() throw()         {
        }


        new_allocator<_Tp>(const new_allocator<_Tp> &) throw()         {
        }


        template <typename _Tp1> new_allocator<_Tp>(const new_allocator<_Tp1> &) throw()         {
        }

;
        ~new_allocator<_Tp>() throw()         {
        }


        pointer address(reference __x) const         {
            return std::__addressof(__x);
        }


        const_pointer address(const_reference __x) const         {
            return std::__addressof(__x);
        }


        pointer allocate(size_type __n, const void * = 0)         {
            if (__n > this->max_size())
                std::__throw_bad_alloc();
            return static_cast<_Tp *>(::operator new(__n * sizeof(_Tp)));
        }


        void deallocate(pointer __p, size_type)         {
            ::operator delete(__p);
        }


        size_type max_size() const throw()         {
            return size_t(-1) / sizeof(_Tp);
        }


        void construct(pointer __p, const _Tp &__val)         {
            ::new ((void *)__p) _Tp((__val));
        }


        void destroy(pointer __p)         {
            __p->~_Tp();
        }


    };
    template <typename _Tp> inline bool operator==(const new_allocator<_Tp> &, const new_allocator<_Tp> &)     {
        return true;
    }

;
    template <typename _Tp> inline bool operator!=(const new_allocator<_Tp> &, const new_allocator<_Tp> &)     {
        return false;
    }

;
}
namespace std {
    class allocator {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef void *pointer;
        typedef const void *const_pointer;
        typedef void value_type;
        template <typename _Tp1> struct rebind {
            typedef allocator<_Tp1> other;
        };
    };
    template <typename _Tp = void> class allocator {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef void *pointer;
        typedef const void *const_pointer;
        typedef void value_type;
        template <typename _Tp1> struct rebind {
            typedef allocator<_Tp1> other;
        };
    }
template <typename _Tp = char> class allocator : public __gnu_cxx::new_allocator<char> {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef char value_type;
        template <typename _Tp1 = char> struct rebind {
            typedef allocator<char> other;
        }
template <typename _Tp1> struct rebind;
        allocator() throw() : __gnu_cxx::new_allocator<char>()         {
        }


        allocator(const std::allocator<char> &__a) throw() : __gnu_cxx::new_allocator<char>(__a)         {
        }


        template <typename _Tp1 = char> allocator(const allocator<char> &) throw()template <typename _Tp1> allocator(const allocator<_Tp1> &) throw();
        ~std::allocator<char>() throw()         {
        }


    }
template <typename _Tp = wchar_t> class allocator : public __gnu_cxx::new_allocator<wchar_t> {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef const wchar_t *const_pointer;
        typedef wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef wchar_t value_type;
        template <typename _Tp1 = wchar_t> struct rebind {
            typedef allocator<wchar_t> other;
        }
template <typename _Tp1> struct rebind;
        allocator() throw();
        allocator(const std::allocator<wchar_t> &__a) throw();
        template <typename _Tp1> allocator(const allocator<_Tp1> &) throw();
        ~std::allocator<wchar_t>() throw();
    }
template <typename _Tp = Player> class allocator : public __gnu_cxx::new_allocator<Player> {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef Player *pointer;
        typedef const Player *const_pointer;
        typedef Player &reference;
        typedef const Player &const_reference;
        typedef Player value_type;
        template <typename _Tp1 = std::_List_node<Player>> struct rebind {
            typedef allocator<std::_List_node<Player> > other;
        }
template <typename _Tp1 = Player> struct rebind {
            typedef allocator<Player> other;
        }
template <typename _Tp1> struct rebind;
        allocator() throw();
        allocator(const std::allocator<Player> &__a) throw();
        template <typename _Tp1> allocator(const allocator<_Tp1> &) throw();
        ~std::allocator<Player>() throw();
    }
template <typename _Tp = std::_List_node<Player>> class allocator : public __gnu_cxx::new_allocator<_List_node<Player> > {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef std::_List_node<Player> *pointer;
        typedef const std::_List_node<Player> *const_pointer;
        typedef std::_List_node<Player> &reference;
        typedef const std::_List_node<Player> &const_reference;
        typedef std::_List_node<Player> value_type;
        template <typename _Tp1> struct rebind;
        allocator() throw();
        allocator(const std::allocator<std::_List_node<Player> > &__a) throw();
        template <typename _Tp1> allocator(const allocator<_Tp1> &) throw();
        ~std::allocator<std::_List_node<Player> >() throw();
    }
template <typename _Tp> class allocator : public __gnu_cxx::new_allocator<_Tp> {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef const _Tp *const_pointer;
        typedef _Tp &reference;
        typedef const _Tp &const_reference;
        typedef _Tp value_type;
        template <typename _Tp1> struct rebind {
            typedef allocator<_Tp1> other;
        };
        allocator<type-parameter-0-0>() throw()         {
        }


        allocator<type-parameter-0-0>(const allocator<type-parameter-0-0> &__a) throw() : __gnu_cxx::new_allocator<_Tp>(__a)         {
        }


        template <typename _Tp1> allocator<type-parameter-0-0>(const allocator<_Tp1> &) throw()         {
        }

;
        ~allocator<type-parameter-0-0>() throw()         {
        }


    };
    template <typename _T1, typename _T2> inline bool operator==(const allocator<_T1> &, const allocator<_T2> &) throw()     {
        return true;
    }

;
    template <typename _Tp> inline bool operator==(const allocator<_Tp> &, const allocator<_Tp> &) throw()     {
        return true;
    }

;
    template <typename _T1, typename _T2> inline bool operator!=(const allocator<_T1> &, const allocator<_T2> &) throw()     {
        return false;
    }

;
    template <typename _Tp> inline bool operator!=(const allocator<_Tp> &, const allocator<_Tp> &) throw()     {
        return false;
    }

;
    class allocator : public __gnu_cxx::new_allocator<char> {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef char value_type;
        template <typename _Tp1 = char> struct rebind {
            typedef allocator<char> other;
        }
template <typename _Tp1> struct rebind;
        allocator() throw() : __gnu_cxx::new_allocator<char>()         {
        }


        allocator(const std::allocator<char> &__a) throw() : __gnu_cxx::new_allocator<char>(__a)         {
        }


        template <typename _Tp1 = char> allocator(const allocator<char> &) throw()template <typename _Tp1> allocator(const allocator<_Tp1> &) throw();
        ~std::allocator<char>() throw()         {
        }


    };
    class allocator : public __gnu_cxx::new_allocator<wchar_t> {
    public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef const wchar_t *const_pointer;
        typedef wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef wchar_t value_type;
        template <typename _Tp1 = wchar_t> struct rebind {
            typedef allocator<wchar_t> other;
        }
template <typename _Tp1> struct rebind;
        allocator() throw();
        allocator(const std::allocator<wchar_t> &__a) throw();
        template <typename _Tp1> allocator(const allocator<_Tp1> &) throw();
        ~std::allocator<wchar_t>() throw();
    };
    template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_swap {
        static void _S_do_it(_Alloc &, _Alloc &)         {
        }


    };
    struct __alloc_swap {
        static void _S_do_it(_Alloc &__one, _Alloc &__two)         {
            if (__one != __two)
                swap(__one, __two);
        }


    };
    template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_neq {
        static bool _S_do_it(const _Alloc &, const _Alloc &)         {
            return false;
        }


    };
    struct __alloc_neq {
        static bool _S_do_it(const _Alloc &__one, const _Alloc &__two)         {
            return __one != __two;
        }


    };
}
namespace __cxxabiv1 {
    class __attribute__((visibility("default"))) __forced_unwind {
        virtual ~__cxxabiv1::__forced_unwind() throw();
        virtual void __pure_dummy() = 0;
    };
}
namespace std {
    template <typename _CharT, typename _Traits> inline void __ostream_write(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const streamsize __put = __out.rdbuf()->sputn(__s, __n);
        if (__put != __n)
            __out.setstate(__ios_base::badbit);
    }

;
    template <typename _CharT, typename _Traits> inline void __ostream_fill(basic_ostream<_CharT, _Traits> &__out, streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const _CharT __c = __out.fill();
        for (; __n > 0; --__n) {
            const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
            if (_Traits::eq_int_type(__put, _Traits::eof())) {
                __out.setstate(__ios_base::badbit);
                break;
            }
        }
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> basic_ostream<char, std::char_traits<char> > &__ostream_insert(basic_ostream<char, std::char_traits<char> > &__out, const char *__s, streamsize __n)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> basic_ostream<wchar_t, std::char_traits<wchar_t> > &__ostream_insert(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__out, const wchar_t *__s, streamsize __n)template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &__ostream_insert(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        typename __ostream_type::sentry __cerb(__out);
        if (__cerb) {
            try {
                const streamsize __w = __out.width();
                if (__w > __n) {
                    const bool __left = ((__out.flags() & __ios_base::adjustfield) == __ios_base::left);
                    if (!__left)
                        __ostream_fill(__out, __w - __n);
                    if (__out.good())
                        __ostream_write(__out, __s, __n);
                    if (__left && __out.good())
                        __ostream_fill(__out, __w - __n);
                } else
                    __ostream_write(__out, __s, __n);
                __out.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(__ios_base::badbit);
            }
        }
        return __out;
    }

;
}
namespace std {
    template <typename _Arg, typename _Result> struct unary_function {
        typedef _Arg argument_type;
        typedef _Result result_type;
    };
    template <typename _Arg1, typename _Arg2, typename _Result> struct binary_function {
        typedef _Arg1 first_argument_type;
        typedef _Arg2 second_argument_type;
        typedef _Result result_type;
    };
    template <typename _Tp> struct plus : public binary_function<_Tp, _Tp, _Tp> {
        _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x + __y;
        }


    };
    template <typename _Tp> struct minus : public binary_function<_Tp, _Tp, _Tp> {
        _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x - __y;
        }


    };
    template <typename _Tp> struct multiplies : public binary_function<_Tp, _Tp, _Tp> {
        _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x * __y;
        }


    };
    template <typename _Tp> struct divides : public binary_function<_Tp, _Tp, _Tp> {
        _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x / __y;
        }


    };
    template <typename _Tp> struct modulus : public binary_function<_Tp, _Tp, _Tp> {
        _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x % __y;
        }


    };
    template <typename _Tp> struct negate : public unary_function<_Tp, _Tp> {
        _Tp operator()(const _Tp &__x) const         {
            return - __x;
        }


    };
    template <typename _Tp> struct equal_to : public binary_function<_Tp, _Tp, bool> {
        bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x == __y;
        }


    };
    template <typename _Tp> struct not_equal_to : public binary_function<_Tp, _Tp, bool> {
        bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x != __y;
        }


    };
    template <typename _Tp> struct greater : public binary_function<_Tp, _Tp, bool> {
        bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x > __y;
        }


    };
    template <typename _Tp> struct less : public binary_function<_Tp, _Tp, bool> {
        bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x < __y;
        }


    };
    template <typename _Tp> struct greater_equal : public binary_function<_Tp, _Tp, bool> {
        bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x >= __y;
        }


    };
    template <typename _Tp> struct less_equal : public binary_function<_Tp, _Tp, bool> {
        bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x <= __y;
        }


    };
    template <typename _Tp> struct logical_and : public binary_function<_Tp, _Tp, bool> {
        bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x && __y;
        }


    };
    template <typename _Tp> struct logical_or : public binary_function<_Tp, _Tp, bool> {
        bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x || __y;
        }


    };
    template <typename _Tp> struct logical_not : public unary_function<_Tp, bool> {
        bool operator()(const _Tp &__x) const         {
            return !__x;
        }


    };
    template <typename _Tp> struct bit_and : public binary_function<_Tp, _Tp, _Tp> {
        _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x & __y;
        }


    };
    template <typename _Tp> struct bit_or : public binary_function<_Tp, _Tp, _Tp> {
        _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x | __y;
        }


    };
    template <typename _Tp> struct bit_xor : public binary_function<_Tp, _Tp, _Tp> {
        _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x ^ __y;
        }


    };
    template <typename _Tp> struct bit_not : public unary_function<_Tp, _Tp> {
        _Tp operator()(const _Tp &__x) const         {
            return ~__x;
        }


    };
    template <typename _Predicate> class unary_negate : public unary_function<typename _Predicate::argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        explicit unary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x)         {
        }


        bool operator()(const typename _Predicate::argument_type &__x) const         {
            return !this->_M_pred(__x);
        }


    };
    template <typename _Predicate> inline unary_negate<_Predicate> not1(const _Predicate &__pred)     {
        return unary_negate<_Predicate>(__pred);
    }

;
    template <typename _Predicate> class binary_negate : public binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        explicit binary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x)         {
        }


        bool operator()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const         {
            return !this->_M_pred(__x, __y);
        }


    };
    template <typename _Predicate> inline binary_negate<_Predicate> not2(const _Predicate &__pred)     {
        return binary_negate<_Predicate>(__pred);
    }

;
    template <typename _Arg, typename _Result> class pointer_to_unary_function : public unary_function<_Arg, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg);
    public:
        pointer_to_unary_function<_Arg, _Result>()         {
        }


        explicit pointer_to_unary_function<_Arg, _Result>(_Result (*__x)(_Arg)) : _M_ptr(__x)         {
        }


        _Result operator()(_Arg __x) const         {
            return this->_M_ptr(__x);
        }


    };
    template <typename _Arg, typename _Result> inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))     {
        return pointer_to_unary_function<_Arg, _Result>(__x);
    }

;
    template <typename _Arg1, typename _Arg2, typename _Result> class pointer_to_binary_function : public binary_function<_Arg1, _Arg2, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
        pointer_to_binary_function<_Arg1, _Arg2, _Result>()         {
        }


        explicit pointer_to_binary_function<_Arg1, _Arg2, _Result>(_Result (*__x)(_Arg1, _Arg2)) : _M_ptr(__x)         {
        }


        _Result operator()(_Arg1 __x, _Arg2 __y) const         {
            return this->_M_ptr(__x, __y);
        }


    };
    template <typename _Arg1, typename _Arg2, typename _Result> inline pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2))     {
        return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
    }

;
    template <typename _Tp> struct _Identity : public unary_function<_Tp, _Tp> {
        _Tp &operator()(_Tp &__x) const         {
            return __x;
        }


        const _Tp &operator()(const _Tp &__x) const         {
            return __x;
        }


    };
    template <typename _Pair> struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
        typename _Pair::first_type &operator()(_Pair &__x) const         {
            return __x.first;
        }


        const typename _Pair::first_type &operator()(const _Pair &__x) const         {
            return __x.first;
        }


    };
    template <typename _Pair> struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type> {
        typename _Pair::second_type &operator()(_Pair &__x) const         {
            return __x.second;
        }


        const typename _Pair::second_type &operator()(const _Pair &__x) const         {
            return __x.second;
        }


    };
    template <typename _Ret, typename _Tp> class mem_fun_t : public unary_function<_Tp *, _Ret> {
    public:
        explicit mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf)         {
        }


        _Ret operator()(_Tp *__p) const         {
            return (__p ->* this->_M_f)();
        }


    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class const_mem_fun_t : public unary_function<const _Tp *, _Ret> {
    public:
        explicit const_mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf)         {
        }


        _Ret operator()(const _Tp *__p) const         {
            return (__p ->* this->_M_f)();
        }


    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp> class mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf)         {
        }


        _Ret operator()(_Tp &__r) const         {
            return (__r .* this->_M_f)();
        }


    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class const_mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit const_mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf)         {
        }


        _Ret operator()(const _Tp &__r) const         {
            return (__r .* this->_M_f)();
        }


    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class mem_fun1_t : public binary_function<_Tp *, _Arg, _Ret> {
    public:
        explicit mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf)         {
        }


        _Ret operator()(_Tp *__p, _Arg __x) const         {
            return (__p ->* this->_M_f)(__x);
        }


    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class const_mem_fun1_t : public binary_function<const _Tp *, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf)         {
        }


        _Ret operator()(const _Tp *__p, _Arg __x) const         {
            return (__p ->* this->_M_f)(__x);
        }


    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf)         {
        }


        _Ret operator()(_Tp &__r, _Arg __x) const         {
            return (__r .* this->_M_f)(__x);
        }


    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf)         {
        }


        _Ret operator()(const _Tp &__r, _Arg __x) const         {
            return (__r .* this->_M_f)(__x);
        }


    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp> inline mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)())     {
        return mem_fun_t<_Ret, _Tp>(__f);
    }

;
    template <typename _Ret, typename _Tp> inline const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const)     {
        return const_mem_fun_t<_Ret, _Tp>(__f);
    }

;
    template <typename _Ret, typename _Tp> inline mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)())     {
        return mem_fun_ref_t<_Ret, _Tp>(__f);
    }

;
    template <typename _Ret, typename _Tp> inline const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const)     {
        return const_mem_fun_ref_t<_Ret, _Tp>(__f);
    }

;
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))     {
        return mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }

;
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const)     {
        return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }

;
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))     {
        return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }

;
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)     {
        return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }

;
}
namespace std {
    template <typename _Operation> class binder1st : public unary_function<typename _Operation::second_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::first_argument_type value;
    public:
        binder1st<_Operation>(const _Operation &__x, const typename _Operation::first_argument_type &__y) : op(__x), value(__y)         {
        }


        typename _Operation::result_type operator()(const typename _Operation::second_argument_type &__x) const         {
            return this->op(this->value, __x);
        }


        typename _Operation::result_type operator()(typename _Operation::second_argument_type &__x) const         {
            return this->op(this->value, __x);
        }


    };
    template <typename _Operation, typename _Tp> inline binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x)     {
        typedef typename _Operation::first_argument_type _Arg1_type;
        return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }

;
    template <typename _Operation> class binder2nd : public unary_function<typename _Operation::first_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::second_argument_type value;
    public:
        binder2nd<_Operation>(const _Operation &__x, const typename _Operation::second_argument_type &__y) : op(__x), value(__y)         {
        }


        typename _Operation::result_type operator()(const typename _Operation::first_argument_type &__x) const         {
            return this->op(__x, this->value);
        }


        typename _Operation::result_type operator()(typename _Operation::first_argument_type &__x) const         {
            return this->op(__x, this->value);
        }


    };
    template <typename _Operation, typename _Tp> inline binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x)     {
        typedef typename _Operation::second_argument_type _Arg2_type;
        return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }

;
}
namespace __gnu_cxx {
    template <typename _Alloc = std::allocator<char>> struct __alloc_traits {
        typedef std::allocator<char> allocator_type;
        typedef typename allocator<char>::pointer pointer;
        typedef typename allocator<char>::const_pointer const_pointer;
        typedef typename allocator<char>::value_type value_type;
        typedef typename allocator<char>::reference reference;
        typedef typename allocator<char>::const_reference const_reference;
        typedef typename allocator<char>::size_type size_type;
        typedef typename allocator<char>::difference_type difference_type;
        static pointer allocate(std::allocator<char> &__a, size_type __n);
        static void deallocate(std::allocator<char> &__a, pointer __p, size_type __n)         {
            __a.deallocate(__p, __n);
        }


        template <typename _Tp> static void construct(std::allocator<char> &__a, pointer __p, const _Tp &__arg);
        static void destroy(std::allocator<char> &__a, pointer __p);
        static size_type max_size(const std::allocator<char> &__a);
        static const std::allocator<char> &_S_select_on_copy(const std::allocator<char> &__a);
        static void _S_on_swap(std::allocator<char> &__a, std::allocator<char> &__b);
        template <typename _Tp = char> struct rebind {
            typedef typename allocator<char>::rebind<char>::other other;
        }
template <typename _Tp> struct rebind;
    }
template <typename _Alloc = std::allocator<wchar_t>> struct __alloc_traits {
        typedef std::allocator<wchar_t> allocator_type;
        typedef typename allocator<wchar_t>::pointer pointer;
        typedef typename allocator<wchar_t>::const_pointer const_pointer;
        typedef typename allocator<wchar_t>::value_type value_type;
        typedef typename allocator<wchar_t>::reference reference;
        typedef typename allocator<wchar_t>::const_reference const_reference;
        typedef typename allocator<wchar_t>::size_type size_type;
        typedef typename allocator<wchar_t>::difference_type difference_type;
        static pointer allocate(std::allocator<wchar_t> &__a, size_type __n);
        static void deallocate(std::allocator<wchar_t> &__a, pointer __p, size_type __n);
        template <typename _Tp> static void construct(std::allocator<wchar_t> &__a, pointer __p, const _Tp &__arg);
        static void destroy(std::allocator<wchar_t> &__a, pointer __p);
        static size_type max_size(const std::allocator<wchar_t> &__a);
        static const std::allocator<wchar_t> &_S_select_on_copy(const std::allocator<wchar_t> &__a);
        static void _S_on_swap(std::allocator<wchar_t> &__a, std::allocator<wchar_t> &__b);
        template <typename _Tp = wchar_t> struct rebind {
            typedef typename allocator<wchar_t>::rebind<wchar_t>::other other;
        }
template <typename _Tp> struct rebind;
    }
template <typename _Alloc> struct __alloc_traits {
        typedef _Alloc allocator_type;
        typedef typename _Alloc::pointer pointer;
        typedef typename _Alloc::const_pointer const_pointer;
        typedef typename _Alloc::value_type value_type;
        typedef typename _Alloc::reference reference;
        typedef typename _Alloc::const_reference const_reference;
        typedef typename _Alloc::size_type size_type;
        typedef typename _Alloc::difference_type difference_type;
        static pointer allocate(_Alloc &__a, size_type __n)         {
            return __a.allocate(__n);
        }


        static void deallocate(_Alloc &__a, pointer __p, size_type __n)         {
            __a.deallocate(__p, __n);
        }


        template <typename _Tp> static void construct(_Alloc &__a, pointer __p, const _Tp &__arg)         {
            __a.construct(__p, __arg);
        }

;
        static void destroy(_Alloc &__a, pointer __p)         {
            __a.destroy(__p);
        }


        static size_type max_size(const _Alloc &__a)         {
            return __a.max_size();
        }


        static const _Alloc &_S_select_on_copy(const _Alloc &__a)         {
            return __a;
        }


        static void _S_on_swap(_Alloc &__a, _Alloc &__b)         {
            std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
        }


        template <typename _Tp> struct rebind {
            typedef typename _Alloc::template _Alloc::rebind<_Tp>::other other;
        };
    };
}
namespace std {
    inline namespace __cxx11 {
        template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> class basic_string {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char> >::rebind<char>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char> traits_type;
            typedef typename char_traits<char>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char> > iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char> > const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        private:
            typedef iterator __const_iterator;
            struct _Alloc_hider : allocator_type {
                _Alloc_hider(pointer __dat, const std::allocator<char> &__a) : allocator_type(__a), _M_p(__dat)                 {
                }


                pointer _M_p;
            };
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char)
            };
            union {
                char _M_local_buf[16];
                size_type _M_allocated_capacity;
            };
            void _M_data(pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }


            void _M_length(size_type __length)             {
                this->_M_string_length = __length;
            }


            pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }


            pointer _M_local_data()             {
                return pointer(this->_M_local_buf);
            }


            const_pointer _M_local_data() const             {
                return const_pointer(this->_M_local_buf);
            }


            void _M_capacity(size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }


            void _M_set_length(size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char());
            }


            bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }


            pointer _M_create(size_type &, size_type);
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }


            void _M_destroy(size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }


            template <typename _InIterator = char *> void _M_construct_aux(char *__beg, char *__end, std::__false_type)             {
                typedef typename iterator_traits<char *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }

template <typename _InIterator = const char *> void _M_construct_aux(const char *__beg, const char *__end, std::__false_type)             {
                typedef typename iterator_traits<const char *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }

template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template <typename _Integer = char *> void _M_construct_aux(char *__beg, char *__end, std::__true_type)template <typename _Integer = const char *> void _M_construct_aux(const char *__beg, const char *__end, std::__true_type)template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(size_type __req, char __c);
            template <typename _InIterator = char *> void _M_construct(char *__beg, char *__end)             {
                typedef typename std::__is_integer<char *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }

template <typename _InIterator = const char *> void _M_construct(const char *__beg, const char *__end)             {
                typedef typename std::__is_integer<const char *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }

template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template <typename _InIterator = char *> void _M_construct(char *__beg, char *__end, std::input_iterator_tag)template <typename _InIterator = const char *> void _M_construct(const char *__beg, const char *__end, std::input_iterator_tag)template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template <typename _FwdIterator = char *> void _M_construct(char *__beg, char *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }

template <typename _FwdIterator = const char *> void _M_construct(const char *__beg, const char *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }

template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            void _M_construct(size_type __req, char __c);
            allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }


            const allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }


        private:
            size_type _M_check(size_type __pos, const char *__s) const;
            void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            size_type _M_limit(size_type __pos, size_type __off) const;
            bool _M_disjunct(const char *__s) const;
            static void _S_copy(char *__d, const char *__s, size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }


            static void _S_move(char *__d, const char *__s, size_type __n);
            static void _S_assign(char *__d, size_type __n, char __c);
            template <class _Iterator = char *> static void _S_copy_chars(char *__p, char *__k1, char *__k2)template <class _Iterator = const char *> static void _S_copy_chars(char *__p, const char *__k1, const char *__k2)template <class _Iterator> static void _S_copy_chars(char *__p, _Iterator __k1, _Iterator __k2);
            static void _S_copy_chars(char *__p, iterator __k1, iterator __k2);
            static void _S_copy_chars(char *__p, const_iterator __k1, const_iterator __k2);
            static void _S_copy_chars(char *__p, char *__k1, char *__k2)             {
                _S_copy(__p, __k1, __k2 - __k1);
            }


            static void _S_copy_chars(char *__p, const char *__k1, const char *__k2)             {
                _S_copy(__p, __k1, __k2 - __k1);
            }


            static int _S_compare(size_type __n1, size_type __n2);
            void _M_assign(const std::__cxx11::basic_string<char> &__rcs);
            void _M_mutate(size_type __pos, size_type __len1, const char *__s, size_type __len2);
            void _M_erase(size_type __pos, size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char> &__a);
            basic_string(const std::__cxx11::basic_string<char> &__str) : _M_dataplus(this->_M_local_data(), __str._M_get_allocator())             {
                this->_M_construct(__str._M_data(), __str._M_data() + __str.length());
            }


            basic_string(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n);
            basic_string(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n, const std::allocator<char> &__a);
            basic_string(const char *__s, size_type __n, const std::allocator<char> &__a);
            basic_string(const char *__s, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__s, __s ? __s + traits_type::length(__s) : __s + npos);
            }


            basic_string(size_type __n, char __c, const std::allocator<char> &__a);
            template <typename _InputIterator> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char> &__a);
            ~std::__cxx11::basic_string<char>()             {
                this->_M_dispose();
            }


            std::__cxx11::basic_string<char> &operator=(const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &operator=(const char *__s);
            std::__cxx11::basic_string<char> &operator=(char __c);
            iterator begin();
            const_iterator begin() const;
            iterator end();
            const_iterator end() const;
            reverse_iterator rbegin();
            const_reverse_iterator rbegin() const;
            reverse_iterator rend();
            const_reverse_iterator rend() const;
        public:
            size_type size() const             {
                return this->_M_string_length;
            }


            size_type length() const             {
                return this->_M_string_length;
            }


            size_type max_size() const;
            void resize(size_type __n, char __c);
            void resize(size_type __n);
            size_type capacity() const;
            void reserve(size_type __res_arg);
            void clear();
            bool empty() const;
            const_reference operator[](size_type __pos) const;
            reference operator[](size_type __pos);
            const_reference at(size_type __n) const;
            reference at(size_type __n);
            std::__cxx11::basic_string<char> &operator+=(const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &operator+=(const char *__s);
            std::__cxx11::basic_string<char> &operator+=(char __c);
            std::__cxx11::basic_string<char> &append(const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &append(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n);
            std::__cxx11::basic_string<char> &append(const char *__s, size_type __n);
            std::__cxx11::basic_string<char> &append(const char *__s);
            std::__cxx11::basic_string<char> &append(size_type __n, char __c);
            template <class _InputIterator> std::__cxx11::basic_string<char> &append(_InputIterator __first, _InputIterator __last);
            void push_back(char __c);
            std::__cxx11::basic_string<char> &assign(const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &assign(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n);
            std::__cxx11::basic_string<char> &assign(const char *__s, size_type __n);
            std::__cxx11::basic_string<char> &assign(const char *__s);
            std::__cxx11::basic_string<char> &assign(size_type __n, char __c);
            template <class _InputIterator> std::__cxx11::basic_string<char> &assign(_InputIterator __first, _InputIterator __last);
            void insert(iterator __p, size_type __n, char __c);
            template <class _InputIterator> void insert(iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<char> &insert(size_type __pos1, const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &insert(size_type __pos1, const std::__cxx11::basic_string<char> &__str, size_type __pos2, size_type __n);
            std::__cxx11::basic_string<char> &insert(size_type __pos, const char *__s, size_type __n);
            std::__cxx11::basic_string<char> &insert(size_type __pos, const char *__s);
            std::__cxx11::basic_string<char> &insert(size_type __pos, size_type __n, char __c);
            iterator insert(__const_iterator __p, char __c);
            std::__cxx11::basic_string<char> &erase(size_type __pos, size_type __n);
            iterator erase(__const_iterator __position);
            iterator erase(__const_iterator __first, __const_iterator __last);
            std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n, const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &replace(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<char> &__str, size_type __pos2, size_type __n2);
            std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n1, const char *__s, size_type __n2);
            std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n1, const char *__s);
            std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n1, size_type __n2, char __c);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const std::__cxx11::basic_string<char> &__str);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__s, size_type __n);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__s);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, char __c);
            template <class _InputIterator> std::__cxx11::basic_string<char> &replace(iterator __i1, iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, char *__k1, char *__k2);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__k1, const char *__k2);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
        private:
            template <class _Integer> std::__cxx11::basic_string<char> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<char> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<char> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, char __c);
            std::__cxx11::basic_string<char> &_M_replace(size_type __pos, size_type __len1, const char *__s, const size_type __len2);
            std::__cxx11::basic_string<char> &_M_append(const char *__s, size_type __n);
        public:
            size_type copy(char *__s, size_type __n, size_type __pos) const;
            void swap(std::__cxx11::basic_string<char> &__s);
            const char *c_str() const;
            const char *data() const             {
                return this->_M_data();
            }


            allocator_type get_allocator() const;
            size_type find(const char *__s, size_type __pos, size_type __n) const;
            size_type find(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type find(const char *__s, size_type __pos) const;
            size_type find(char __c, size_type __pos) const;
            size_type rfind(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type rfind(const char *__s, size_type __pos, size_type __n) const;
            size_type rfind(const char *__s, size_type __pos) const;
            size_type rfind(char __c, size_type __pos) const;
            size_type find_first_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type find_first_of(const char *__s, size_type __pos, size_type __n) const;
            size_type find_first_of(const char *__s, size_type __pos) const;
            size_type find_first_of(char __c, size_type __pos) const;
            size_type find_last_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type find_last_of(const char *__s, size_type __pos, size_type __n) const;
            size_type find_last_of(const char *__s, size_type __pos) const;
            size_type find_last_of(char __c, size_type __pos) const;
            size_type find_first_not_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type find_first_not_of(const char *__s, size_type __pos, size_type __n) const;
            size_type find_first_not_of(const char *__s, size_type __pos) const;
            size_type find_first_not_of(char __c, size_type __pos) const;
            size_type find_last_not_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
            size_type find_last_not_of(const char *__s, size_type __pos, size_type __n) const;
            size_type find_last_not_of(const char *__s, size_type __pos) const;
            size_type find_last_not_of(char __c, size_type __pos) const;
            std::__cxx11::basic_string<char> substr(size_type __pos, size_type __n) const;
            int compare(const std::__cxx11::basic_string<char> &__str) const;
            int compare(size_type __pos, size_type __n, const std::__cxx11::basic_string<char> &__str) const;
            int compare(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<char> &__str, size_type __pos2, size_type __n2) const;
            int compare(const char *__s) const;
            int compare(size_type __pos, size_type __n1, const char *__s) const;
            int compare(size_type __pos, size_type __n1, const char *__s, size_type __n2) const;
        }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> class basic_string {
            typedef typename __gnu_cxx::__alloc_traits<allocator<wchar_t> >::rebind<wchar_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef typename char_traits<wchar_t>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<wchar_t> > iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<wchar_t> > const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        private:
            typedef iterator __const_iterator;
            struct _Alloc_hider : allocator_type {
                _Alloc_hider(pointer __dat, const std::allocator<wchar_t> &__a);
                pointer _M_p;
            };
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::_Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(wchar_t)
            };
            union {
                wchar_t _M_local_buf[4];
                size_type _M_allocated_capacity;
            };
            void _M_data(pointer __p);
            void _M_length(size_type __length);
            pointer _M_data() const;
            pointer _M_local_data();
            const_pointer _M_local_data() const;
            void _M_capacity(size_type __capacity);
            void _M_set_length(size_type __n);
            bool _M_is_local() const;
            pointer _M_create(size_type &, size_type);
            void _M_dispose();
            void _M_destroy(size_type __size) throw();
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(size_type __req, wchar_t __c);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            void _M_construct(size_type __req, wchar_t __c);
            allocator_type &_M_get_allocator();
            const allocator_type &_M_get_allocator() const;
        private:
            size_type _M_check(size_type __pos, const char *__s) const;
            void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            size_type _M_limit(size_type __pos, size_type __off) const;
            bool _M_disjunct(const wchar_t *__s) const;
            static void _S_copy(wchar_t *__d, const wchar_t *__s, size_type __n);
            static void _S_move(wchar_t *__d, const wchar_t *__s, size_type __n);
            static void _S_assign(wchar_t *__d, size_type __n, wchar_t __c);
            template <class _Iterator> static void _S_copy_chars(wchar_t *__p, _Iterator __k1, _Iterator __k2);
            static void _S_copy_chars(wchar_t *__p, iterator __k1, iterator __k2);
            static void _S_copy_chars(wchar_t *__p, const_iterator __k1, const_iterator __k2);
            static void _S_copy_chars(wchar_t *__p, wchar_t *__k1, wchar_t *__k2);
            static void _S_copy_chars(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2);
            static int _S_compare(size_type __n1, size_type __n2);
            void _M_assign(const std::__cxx11::basic_string<wchar_t> &__rcs);
            void _M_mutate(size_type __pos, size_type __len1, const wchar_t *__s, size_type __len2);
            void _M_erase(size_type __pos, size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<wchar_t> &__a);
            basic_string(const std::__cxx11::basic_string<wchar_t> &__str);
            basic_string(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            basic_string(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n, const std::allocator<wchar_t> &__a);
            basic_string(const wchar_t *__s, size_type __n, const std::allocator<wchar_t> &__a);
            basic_string(const wchar_t *__s, const std::allocator<wchar_t> &__a);
            basic_string(size_type __n, wchar_t __c, const std::allocator<wchar_t> &__a);
            template <typename _InputIterator> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<wchar_t> &__a);
            ~std::__cxx11::basic_string<wchar_t>();
            std::__cxx11::basic_string<wchar_t> &operator=(const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &operator=(const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &operator=(wchar_t __c);
            iterator begin();
            const_iterator begin() const;
            iterator end();
            const_iterator end() const;
            reverse_iterator rbegin();
            const_reverse_iterator rbegin() const;
            reverse_iterator rend();
            const_reverse_iterator rend() const;
        public:
            size_type size() const;
            size_type length() const;
            size_type max_size() const;
            void resize(size_type __n, wchar_t __c);
            void resize(size_type __n);
            size_type capacity() const;
            void reserve(size_type __res_arg);
            void clear();
            bool empty() const;
            const_reference operator[](size_type __pos) const;
            reference operator[](size_type __pos);
            const_reference at(size_type __n) const;
            reference at(size_type __n);
            std::__cxx11::basic_string<wchar_t> &operator+=(const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &operator+=(const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &operator+=(wchar_t __c);
            std::__cxx11::basic_string<wchar_t> &append(const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &append(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            std::__cxx11::basic_string<wchar_t> &append(const wchar_t *__s, size_type __n);
            std::__cxx11::basic_string<wchar_t> &append(const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &append(size_type __n, wchar_t __c);
            template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &append(_InputIterator __first, _InputIterator __last);
            void push_back(wchar_t __c);
            std::__cxx11::basic_string<wchar_t> &assign(const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &assign(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            std::__cxx11::basic_string<wchar_t> &assign(const wchar_t *__s, size_type __n);
            std::__cxx11::basic_string<wchar_t> &assign(const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &assign(size_type __n, wchar_t __c);
            template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &assign(_InputIterator __first, _InputIterator __last);
            void insert(iterator __p, size_type __n, wchar_t __c);
            template <class _InputIterator> void insert(iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<wchar_t> &insert(size_type __pos1, const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &insert(size_type __pos1, const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos2, size_type __n);
            std::__cxx11::basic_string<wchar_t> &insert(size_type __pos, const wchar_t *__s, size_type __n);
            std::__cxx11::basic_string<wchar_t> &insert(size_type __pos, const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &insert(size_type __pos, size_type __n, wchar_t __c);
            iterator insert(__const_iterator __p, wchar_t __c);
            std::__cxx11::basic_string<wchar_t> &erase(size_type __pos, size_type __n);
            iterator erase(__const_iterator __position);
            iterator erase(__const_iterator __first, __const_iterator __last);
            std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n, const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &replace(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2);
            std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const wchar_t *__s, size_type __n2);
            std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, size_type __n2, wchar_t __c);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const std::__cxx11::basic_string<wchar_t> &__str);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__s, size_type __n);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__s);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, wchar_t __c);
            template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &replace(iterator __i1, iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, wchar_t *__k1, wchar_t *__k2);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__k1, const wchar_t *__k2);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
        private:
            template <class _Integer> std::__cxx11::basic_string<wchar_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<wchar_t> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, wchar_t __c);
            std::__cxx11::basic_string<wchar_t> &_M_replace(size_type __pos, size_type __len1, const wchar_t *__s, const size_type __len2);
            std::__cxx11::basic_string<wchar_t> &_M_append(const wchar_t *__s, size_type __n);
        public:
            size_type copy(wchar_t *__s, size_type __n, size_type __pos) const;
            void swap(std::__cxx11::basic_string<wchar_t> &__s);
            const wchar_t *c_str() const;
            const wchar_t *data() const;
            allocator_type get_allocator() const;
            size_type find(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type find(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type find(const wchar_t *__s, size_type __pos) const;
            size_type find(wchar_t __c, size_type __pos) const;
            size_type rfind(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type rfind(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type rfind(const wchar_t *__s, size_type __pos) const;
            size_type rfind(wchar_t __c, size_type __pos) const;
            size_type find_first_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type find_first_of(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type find_first_of(const wchar_t *__s, size_type __pos) const;
            size_type find_first_of(wchar_t __c, size_type __pos) const;
            size_type find_last_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type find_last_of(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type find_last_of(const wchar_t *__s, size_type __pos) const;
            size_type find_last_of(wchar_t __c, size_type __pos) const;
            size_type find_first_not_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type find_first_not_of(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type find_first_not_of(const wchar_t *__s, size_type __pos) const;
            size_type find_first_not_of(wchar_t __c, size_type __pos) const;
            size_type find_last_not_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
            size_type find_last_not_of(const wchar_t *__s, size_type __pos, size_type __n) const;
            size_type find_last_not_of(const wchar_t *__s, size_type __pos) const;
            size_type find_last_not_of(wchar_t __c, size_type __pos) const;
            std::__cxx11::basic_string<wchar_t> substr(size_type __pos, size_type __n) const;
            int compare(const std::__cxx11::basic_string<wchar_t> &__str) const;
            int compare(size_type __pos, size_type __n, const std::__cxx11::basic_string<wchar_t> &__str) const;
            int compare(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2) const;
            int compare(const wchar_t *__s) const;
            int compare(size_type __pos, size_type __n1, const wchar_t *__s) const;
            int compare(size_type __pos, size_type __n1, const wchar_t *__s, size_type __n2) const;
        }
template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string {
            typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef _Traits traits_type;
            typedef typename _Traits::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<_CharT, _Traits, _Alloc> > iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<_CharT, _Traits, _Alloc> > const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        private:
            typedef iterator __const_iterator;
            struct _Alloc_hider : allocator_type {
                _Alloc_hider(pointer __dat, const _Alloc &__a = _Alloc()) : allocator_type(__a), _M_p(__dat)                 {
                }


                pointer _M_p;
            };
            std::__cxx11::basic_string::_Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(_CharT)
            };
            union {
                _CharT _M_local_buf[_S_local_capacity + 1];
                size_type _M_allocated_capacity;
            };
            void _M_data(pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }


            void _M_length(size_type __length)             {
                this->_M_string_length = __length;
            }


            pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }


            pointer _M_local_data()             {
                return pointer(this->_M_local_buf);
            }


            const_pointer _M_local_data() const             {
                return const_pointer(this->_M_local_buf);
            }


            void _M_capacity(size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }


            void _M_set_length(size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(_M_data()[__n], _CharT());
            }


            bool _M_is_local() const             {
                return _M_data() == _M_local_data();
            }


            pointer _M_create(size_type &, size_type);
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }


            void _M_destroy(size_type __size) throw()             {
                _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1);
            }


            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type)             {
                typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                _M_construct(__beg, __end, _Tag());
            }

;
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)             {
                this->_M_construct_aux_2(static_cast<size_type>(__beg), __end);
            }

;
            void _M_construct_aux_2(size_type __req, _CharT __c)             {
                _M_construct(__req, __c);
            }


            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end)             {
                typedef typename std::__is_integer<_InIterator>::__type _Integral;
                _M_construct_aux(__beg, __end, _Integral());
            }

;
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            void _M_construct(size_type __req, _CharT __c);
            allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }


            const allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }


        private:
            size_type _M_check(size_type __pos, const char *__s) const             {
                if (__pos > this->size())
                    __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
                return __pos;
            }


            void _M_check_length(size_type __n1, size_type __n2, const char *__s) const             {
                if (this->max_size() - (this->size() - __n1) < __n2)
                    __throw_length_error((__s));
            }


            size_type _M_limit(size_type __pos, size_type __off) const             {
                const bool __testoff = __off < this->size() - __pos;
                return __testoff ? __off : this->size() - __pos;
            }


            bool _M_disjunct(const _CharT *__s) const             {
                return (less<const _CharT *>()(__s, _M_data()) || less<const _CharT *>()(_M_data() + this->size(), __s));
            }


            static void _S_copy(_CharT *__d, const _CharT *__s, size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }


            static void _S_move(_CharT *__d, const _CharT *__s, size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::move(__d, __s, __n);
            }


            static void _S_assign(_CharT *__d, size_type __n, _CharT __c)             {
                if (__n == 1)
                    traits_type::assign(*__d, __c);
                else
                    traits_type::assign(__d, __n, __c);
            }


            template <class _Iterator> static void _S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2)             {
                for (; __k1 != __k2; ++__k1 , ++__p) 
                    traits_type::assign(*__p, *__k1);
            }

;
            static void _S_copy_chars(_CharT *__p, iterator __k1, iterator __k2)             {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }


            static void _S_copy_chars(_CharT *__p, const_iterator __k1, const_iterator __k2)             {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }


            static void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2)             {
                _S_copy(__p, __k1, __k2 - __k1);
            }


            static void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2)             {
                _S_copy(__p, __k1, __k2 - __k1);
            }


            static int _S_compare(size_type __n1, size_type __n2)             {
                const difference_type __d = difference_type(__n1 - __n2);
                if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                    return __gnu_cxx::__numeric_traits<int>::__max;
                else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                    return __gnu_cxx::__numeric_traits<int>::__min;
                else
                    return int(__d);
            }


            void _M_assign(const basic_string<_CharT, _Traits, _Alloc> &__rcs);
            void _M_mutate(size_type __pos, size_type __len1, const _CharT *__s, size_type __len2);
            void _M_erase(size_type __pos, size_type __n);
        public:
            basic_string<_CharT, _Traits, _Alloc>() : _M_dataplus(_M_local_data())             {
                this->_M_set_length(0);
            }


            explicit basic_string<_CharT, _Traits, _Alloc>(const _Alloc &__a) : _M_dataplus(_M_local_data(), __a)             {
                this->_M_set_length(0);
            }


            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str) : _M_dataplus(_M_local_data(), __str._M_get_allocator())             {
                _M_construct(__str._M_data(), __str._M_data() + __str.length());
            }


            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos, size_type __n = npos) : _M_dataplus(_M_local_data())             {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n));
            }


            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos, size_type __n, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a)             {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "string::string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n));
            }


            basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, size_type __n, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__s, __s + __n);
            }


            basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__s, __s ? __s + traits_type::length(__s) : __s + npos);
            }


            basic_string<_CharT, _Traits, _Alloc>(size_type __n, _CharT __c, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__n, __c);
            }


            template <typename _InputIterator> basic_string<_CharT, _Traits, _Alloc>(_InputIterator __beg, _InputIterator __end, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__beg, __end);
            }

;
            ~basic_string<_CharT, _Traits, _Alloc>()             {
                this->_M_dispose();
            }


            basic_string<_CharT, _Traits, _Alloc> &operator=(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->assign(__str);
            }


            basic_string<_CharT, _Traits, _Alloc> &operator=(const _CharT *__s)             {
                return this->assign(__s);
            }


            basic_string<_CharT, _Traits, _Alloc> &operator=(_CharT __c)             {
                this->assign(1, __c);
                return *this;
            }


            iterator begin()             {
                return iterator(_M_data());
            }


            const_iterator begin() const             {
                return const_iterator(_M_data());
            }


            iterator end()             {
                return iterator(_M_data() + this->size());
            }


            const_iterator end() const             {
                return const_iterator(_M_data() + this->size());
            }


            reverse_iterator rbegin()             {
                return reverse_iterator(this->end());
            }


            const_reverse_iterator rbegin() const             {
                return const_reverse_iterator(this->end());
            }


            reverse_iterator rend()             {
                return reverse_iterator(this->begin());
            }


            const_reverse_iterator rend() const             {
                return const_reverse_iterator(this->begin());
            }


        public:
            size_type size() const             {
                return this->_M_string_length;
            }


            size_type length() const             {
                return this->_M_string_length;
            }


            size_type max_size() const             {
                return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2;
            }


            void resize(size_type __n, _CharT __c);
            void resize(size_type __n)             {
                this->resize(__n, _CharT());
            }


            size_type capacity() const             {
                return this->_M_is_local() ? size_type(_S_local_capacity) : this->_M_allocated_capacity;
            }


            void reserve(size_type __res_arg = 0);
            void clear()             {
                this->_M_set_length(0);
            }


            bool empty() const             {
                return this->size() == 0;
            }


            const_reference operator[](size_type __pos) const             {
                ;
                return _M_data()[__pos];
            }


            reference operator[](size_type __pos)             {
                ;
                ;
                return _M_data()[__pos];
            }


            const_reference at(size_type __n) const             {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }


            reference at(size_type __n)             {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }


            basic_string<_CharT, _Traits, _Alloc> &operator+=(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->append(__str);
            }


            basic_string<_CharT, _Traits, _Alloc> &operator+=(const _CharT *__s)             {
                return this->append(__s);
            }


            basic_string<_CharT, _Traits, _Alloc> &operator+=(_CharT __c)             {
                this->push_back(__c);
                return *this;
            }


            basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->_M_append(__str._M_data(), __str.size());
            }


            basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos, size_type __n)             {
                return this->_M_append(__str._M_data() + __str._M_check(__pos, "basic_string::append"), __str._M_limit(__pos, __n));
            }


            basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s, size_type __n)             {
                ;
                this->_M_check_length(size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }


            basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s)             {
                ;
                const size_type __n = traits_type::length(__s);
                this->_M_check_length(size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }


            basic_string<_CharT, _Traits, _Alloc> &append(size_type __n, _CharT __c)             {
                return this->_M_replace_aux(this->size(), size_type(0), __n, __c);
            }


            template <class _InputIterator> basic_string<_CharT, _Traits, _Alloc> &append(_InputIterator __first, _InputIterator __last)             {
                return this->replace(end(), end(), __first, __last);
            }

;
            void push_back(_CharT __c)             {
                const size_type __size = this->size();
                if (__size + 1 > this->capacity())
                    this->_M_mutate(__size, size_type(0), 0, size_type(1));
                traits_type::assign(this->_M_data()[__size], __c);
                this->_M_set_length(__size + 1);
            }


            basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                this->_M_assign(__str);
                return *this;
            }


            basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos, size_type __n)             {
                return this->_M_replace(size_type(0), this->size(), __str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n));
            }


            basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s, size_type __n)             {
                ;
                return this->_M_replace(size_type(0), this->size(), __s, __n);
            }


            basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s)             {
                ;
                return this->_M_replace(size_type(0), this->size(), __s, traits_type::length(__s));
            }


            basic_string<_CharT, _Traits, _Alloc> &assign(size_type __n, _CharT __c)             {
                return this->_M_replace_aux(size_type(0), this->size(), __n, __c);
            }


            template <class _InputIterator> basic_string<_CharT, _Traits, _Alloc> &assign(_InputIterator __first, _InputIterator __last)             {
                return this->replace(begin(), end(), __first, __last);
            }

;
            void insert(iterator __p, size_type __n, _CharT __c)             {
                this->replace(__p, __p, __n, __c);
            }


            template <class _InputIterator> void insert(iterator __p, _InputIterator __beg, _InputIterator __end)             {
                this->replace(__p, __p, __beg, __end);
            }

;
            basic_string<_CharT, _Traits, _Alloc> &insert(size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__pos1, size_type(0), __str._M_data(), __str.size());
            }


            basic_string<_CharT, _Traits, _Alloc> &insert(size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos2, size_type __n)             {
                return this->replace(__pos1, size_type(0), __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n));
            }


            basic_string<_CharT, _Traits, _Alloc> &insert(size_type __pos, const _CharT *__s, size_type __n)             {
                return this->replace(__pos, size_type(0), __s, __n);
            }


            basic_string<_CharT, _Traits, _Alloc> &insert(size_type __pos, const _CharT *__s)             {
                ;
                return this->replace(__pos, size_type(0), __s, traits_type::length(__s));
            }


            basic_string<_CharT, _Traits, _Alloc> &insert(size_type __pos, size_type __n, _CharT __c)             {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::insert"), size_type(0), __n, __c);
            }


            iterator insert(__const_iterator __p, _CharT __c)             {
                ;
                const size_type __pos = __p - begin();
                this->_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                return iterator(_M_data() + __pos);
            }


            basic_string<_CharT, _Traits, _Alloc> &erase(size_type __pos = 0, size_type __n = npos)             {
                this->_M_erase(this->_M_check(__pos, "basic_string::erase"), this->_M_limit(__pos, __n));
                return *this;
            }


            iterator erase(__const_iterator __position)             {
                ;
                const size_type __pos = __position - begin();
                this->_M_erase(__pos, size_type(1));
                return iterator(_M_data() + __pos);
            }


            iterator erase(__const_iterator __first, __const_iterator __last)             {
                ;
                const size_type __pos = __first - begin();
                this->_M_erase(__pos, __last - __first);
                return iterator(this->_M_data() + __pos);
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(size_type __pos, size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__pos, __n, __str._M_data(), __str.size());
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos2, size_type __n2)             {
                return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2));
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(size_type __pos, size_type __n1, const _CharT *__s, size_type __n2)             {
                ;
                return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(size_type __pos, size_type __n1, const _CharT *__s)             {
                ;
                return this->replace(__pos, __n1, __s, traits_type::length(__s));
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)             {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __n2, __c);
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__i1, __i2, __str._M_data(), __str.size());
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *__s, size_type __n)             {
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *__s)             {
                ;
                return this->replace(__i1, __i2, __s, traits_type::length(__s));
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, _CharT __c)             {
                ;
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
            }


            template <class _InputIterator> basic_string<_CharT, _Traits, _Alloc> &replace(iterator __i1, iterator __i2, _InputIterator __k1, _InputIterator __k2)             {
                ;
                ;
                typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
            }

;
            basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, _CharT *__k1, _CharT *__k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *__k1, const _CharT *__k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }


            basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }


        private:
            template <class _Integer> basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, std::__true_type)             {
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val);
            }

;
            template <class _InputIterator> basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            basic_string<_CharT, _Traits, _Alloc> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT __c);
            basic_string<_CharT, _Traits, _Alloc> &_M_replace(size_type __pos, size_type __len1, const _CharT *__s, const size_type __len2);
            basic_string<_CharT, _Traits, _Alloc> &_M_append(const _CharT *__s, size_type __n);
        public:
            size_type copy(_CharT *__s, size_type __n, size_type __pos = 0) const;
            void swap(basic_string<_CharT, _Traits, _Alloc> &__s);
            const _CharT *c_str() const             {
                return _M_data();
            }


            const _CharT *data() const             {
                return _M_data();
            }


            allocator_type get_allocator() const             {
                return _M_get_allocator();
            }


            size_type find(const _CharT *__s, size_type __pos, size_type __n) const;
            size_type find(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = 0) const             {
                return this->find(__str.data(), __pos, __str.size());
            }


            size_type find(const _CharT *__s, size_type __pos = 0) const             {
                ;
                return this->find(__s, __pos, traits_type::length(__s));
            }


            size_type find(_CharT __c, size_type __pos = 0) const;
            size_type rfind(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = npos) const             {
                return this->rfind(__str.data(), __pos, __str.size());
            }


            size_type rfind(const _CharT *__s, size_type __pos, size_type __n) const;
            size_type rfind(const _CharT *__s, size_type __pos = npos) const             {
                ;
                return this->rfind(__s, __pos, traits_type::length(__s));
            }


            size_type rfind(_CharT __c, size_type __pos = npos) const;
            size_type find_first_of(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = 0) const             {
                return this->find_first_of(__str.data(), __pos, __str.size());
            }


            size_type find_first_of(const _CharT *__s, size_type __pos, size_type __n) const;
            size_type find_first_of(const _CharT *__s, size_type __pos = 0) const             {
                ;
                return this->find_first_of(__s, __pos, traits_type::length(__s));
            }


            size_type find_first_of(_CharT __c, size_type __pos = 0) const             {
                return this->find(__c, __pos);
            }


            size_type find_last_of(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = npos) const             {
                return this->find_last_of(__str.data(), __pos, __str.size());
            }


            size_type find_last_of(const _CharT *__s, size_type __pos, size_type __n) const;
            size_type find_last_of(const _CharT *__s, size_type __pos = npos) const             {
                ;
                return this->find_last_of(__s, __pos, traits_type::length(__s));
            }


            size_type find_last_of(_CharT __c, size_type __pos = npos) const             {
                return this->rfind(__c, __pos);
            }


            size_type find_first_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = 0) const             {
                return this->find_first_not_of(__str.data(), __pos, __str.size());
            }


            size_type find_first_not_of(const _CharT *__s, size_type __pos, size_type __n) const;
            size_type find_first_not_of(const _CharT *__s, size_type __pos = 0) const             {
                ;
                return this->find_first_not_of(__s, __pos, traits_type::length(__s));
            }


            size_type find_first_not_of(_CharT __c, size_type __pos = 0) const;
            size_type find_last_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = npos) const             {
                return this->find_last_not_of(__str.data(), __pos, __str.size());
            }


            size_type find_last_not_of(const _CharT *__s, size_type __pos, size_type __n) const;
            size_type find_last_not_of(const _CharT *__s, size_type __pos = npos) const             {
                ;
                return this->find_last_not_of(__s, __pos, traits_type::length(__s));
            }


            size_type find_last_not_of(_CharT __c, size_type __pos = npos) const;
            basic_string<_CharT, _Traits, _Alloc> substr(size_type __pos = 0, size_type __n = npos) const             {
                return basic_string<_CharT, _Traits, _Alloc>(*this, this->_M_check(__pos, "basic_string::substr"), __n);
            }


            int compare(const basic_string<_CharT, _Traits, _Alloc> &__str) const             {
                const size_type __size = this->size();
                const size_type __osize = __str.size();
                const size_type __len = std::min(__size, __osize);
                int __r = traits_type::compare(_M_data(), __str.data(), __len);
                if (!__r)
                    __r = _S_compare(__size, __osize);
                return __r;
            }


            int compare(size_type __pos, size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) const;
            int compare(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos2, size_type __n2) const;
            int compare(const _CharT *__s) const;
            int compare(size_type __pos, size_type __n1, const _CharT *__s) const;
            int compare(size_type __pos, size_type __n1, const _CharT *__s, size_type __n2) const;
        };
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs)     {
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        __string_type __str(__lhs);
        __str.append(__size_type(1), __rhs);
        return __str;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __lhs.compare(__rhs) == 0;
    }

;
    template <typename _CharT> inline typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator==(const basic_string<_CharT> &__lhs, const basic_string<_CharT> &__rhs)     {
        return (__lhs.size() == __rhs.size() && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(), __lhs.size()));
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) == 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) == 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return !(__lhs == __rhs);
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return !(__lhs == __rhs);
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return !(__lhs == __rhs);
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __lhs.compare(__rhs) < 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) < 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) > 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __lhs.compare(__rhs) > 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) > 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) < 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __lhs.compare(__rhs) <= 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) <= 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) >= 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __lhs.compare(__rhs) >= 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) >= 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) <= 0;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> inline void swap(basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        __lhs.swap(__rhs);
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &operator>>(basic_istream<char> &__is, basic_string<char> &__str)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > &__str)template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str);
    basic_istream<char> &operator>>(basic_istream<char> &__is, basic_string<char> &__str);
    template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> inline basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__os, const basic_string<char, std::char_traits<char>, std::allocator<char> > &__str)     {
        return __ostream_insert(__os, __str.data(), __str.size());
    }

template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> inline basic_ostream<wchar_t, std::char_traits<wchar_t> > &operator<<(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__os, const basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > &__str)template <typename _CharT, typename _Traits, typename _Alloc> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const basic_string<_CharT, _Traits, _Alloc> &__str)     {
        return __ostream_insert(__os, __str.data(), __str.size());
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &getline(basic_istream<char> &__in, basic_string<char> &__str, char __delim)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t> &getline(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim)template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim);
    template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> inline basic_istream<char, std::char_traits<char> > &getline(basic_istream<char, std::char_traits<char> > &__is, basic_string<char, std::char_traits<char>, std::allocator<char> > &__str)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> inline basic_istream<wchar_t, std::char_traits<wchar_t> > &getline(basic_istream<wchar_t, std::char_traits<wchar_t> > &__is, basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > &__str)template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str)     {
        return std::getline(__is, __str, __is.widen('\n'));
    }

;
    basic_istream<char> &getline(basic_istream<char> &__in, basic_string<char> &__str, char __delim);
    basic_istream<wchar_t> &getline(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim);
}
namespace std {
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type npos;
    void swap(basic_string<_CharT, _Traits, _Alloc> &__s)     {
        if (this == &__s)
            return;
        std::__alloc_swap<allocator_type>::_S_do_it(_M_get_allocator(), __s._M_get_allocator());
        if (this->_M_is_local())
            if (__s._M_is_local()) {
                if (this->length() && __s.length()) {
                    _CharT __tmp_data[_S_local_capacity + 1];
                    traits_type::copy(__tmp_data, __s._M_local_buf, _S_local_capacity + 1);
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, _S_local_capacity + 1);
                    traits_type::copy(this->_M_local_buf, __tmp_data, _S_local_capacity + 1);
                } else if (__s.length()) {
                    traits_type::copy(this->_M_local_buf, __s._M_local_buf, _S_local_capacity + 1);
                    this->_M_length(__s.length());
                    __s._M_set_length(0);
                    return;
                } else if (this->length()) {
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, _S_local_capacity + 1);
                    __s._M_length(this->length());
                    this->_M_set_length(0);
                    return;
                }
            } else {
                const size_type __tmp_capacity = __s._M_allocated_capacity;
                traits_type::copy(__s._M_local_buf, this->_M_local_buf, _S_local_capacity + 1);
                _M_data(__s._M_data());
                __s._M_data(__s._M_local_buf);
                this->_M_capacity(__tmp_capacity);
            }
        else {
            const size_type __tmp_capacity = this->_M_allocated_capacity;
            if (__s._M_is_local()) {
                traits_type::copy(this->_M_local_buf, __s._M_local_buf, _S_local_capacity + 1);
                __s._M_data(_M_data());
                _M_data(this->_M_local_buf);
            } else {
                pointer __tmp_ptr = _M_data();
                _M_data(__s._M_data());
                __s._M_data(__tmp_ptr);
                this->_M_capacity(__s._M_allocated_capacity);
            }
            __s._M_capacity(__tmp_capacity);
        }
        const size_type __tmp_length = this->length();
        this->_M_length(__s.length());
        __s._M_length(__tmp_length);
    }


    typename basic_string<_CharT, _Traits, _Alloc>::pointer _M_create(size_type &__capacity, size_type __old_capacity)     {
        if (__capacity > this->max_size())
            std::__throw_length_error(("basic_string::_M_create"));
        if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
            __capacity = 2 * __old_capacity;
            if (__capacity > this->max_size())
                __capacity = this->max_size();
        }
        return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }


    template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag)     {
        size_type __len = 0;
        size_type __capacity = size_type(_S_local_capacity);
        while (__beg != __end && __len < __capacity)
            {
                _M_data()[__len++] = *__beg;
                ++__beg;
            }
        try {
            while (__beg != __end)
                {
                    if (__len == __capacity) {
                        __capacity = __len + 1;
                        pointer __another = this->_M_create(__capacity, __len);
                        this->_S_copy(__another, _M_data(), __len);
                        this->_M_dispose();
                        _M_data(__another);
                        this->_M_capacity(__capacity);
                    }
                    _M_data()[__len++] = *__beg;
                    ++__beg;
                }
        } catch (...) {
            this->_M_dispose();
            throw;
        }
        this->_M_set_length(__len);
    }

;
    template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::forward_iterator_tag)     {
        if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
            std::__throw_logic_error(("basic_string::_M_construct null not valid"));
        size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
        if (__dnew > size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__dnew, size_type(0)));
            this->_M_capacity(__dnew);
        }
        try {
            this->_S_copy_chars(_M_data(), __beg, __end);
        } catch (...) {
            this->_M_dispose();
            throw;
        }
        this->_M_set_length(__dnew);
    }

;
    void _M_construct(size_type __n, _CharT __c)     {
        if (__n > size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__n, size_type(0)));
            this->_M_capacity(__n);
        }
        if (__n)
            this->_S_assign(_M_data(), __n, __c);
        this->_M_set_length(__n);
    }


    void _M_assign(const basic_string<_CharT, _Traits, _Alloc> &__str)     {
        if (this != &__str) {
            const size_type __rsize = __str.length();
            const size_type __capacity = this->capacity();
            if (__rsize > __capacity) {
                size_type __new_capacity = __rsize;
                pointer __tmp = this->_M_create(__new_capacity, __capacity);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__new_capacity);
            }
            if (__rsize)
                this->_S_copy(_M_data(), __str._M_data(), __rsize);
            this->_M_set_length(__rsize);
        }
    }


    void reserve(size_type __res = 0)     {
        if (__res < this->length())
            __res = this->length();
        const size_type __capacity = this->capacity();
        if (__res != __capacity) {
            if (__res > __capacity || __res > size_type(_S_local_capacity)) {
                pointer __tmp = this->_M_create(__res, __capacity);
                this->_S_copy(__tmp, _M_data(), this->length() + 1);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__res);
            } else if (!this->_M_is_local()) {
                this->_S_copy(_M_local_data(), _M_data(), this->length() + 1);
                this->_M_destroy(__capacity);
                _M_data(_M_local_data());
            }
        }
    }


    void _M_mutate(size_type __pos, size_type __len1, const _CharT *__s, size_type __len2)     {
        const size_type __how_much = this->length() - __pos - __len1;
        size_type __new_capacity = this->length() + __len2 - __len1;
        pointer __r = this->_M_create(__new_capacity, this->capacity());
        if (__pos)
            this->_S_copy(__r, _M_data(), __pos);
        if (__s && __len2)
            this->_S_copy(__r + __pos, __s, __len2);
        if (__how_much)
            this->_S_copy(__r + __pos + __len2, _M_data() + __pos + __len1, __how_much);
        this->_M_dispose();
        _M_data(__r);
        this->_M_capacity(__new_capacity);
    }


    void _M_erase(size_type __pos, size_type __n)     {
        const size_type __how_much = this->length() - __pos - __n;
        if (__how_much && __n)
            this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);
        this->_M_set_length(this->length() - __n);
    }


    void resize(size_type __n, _CharT __c)     {
        const size_type __size = this->size();
        if (__size < __n)
            this->append(__n - __size, __c);
        else if (__n < __size)
            this->_M_erase(__n, __size - __n);
    }


    basic_string<_CharT, _Traits, _Alloc> &_M_append(const _CharT *__s, size_type __n)     {
        const size_type __len = __n + this->size();
        if (__len <= this->capacity()) {
            if (__n)
                this->_S_copy(this->_M_data() + this->size(), __s, __n);
        } else
            this->_M_mutate(this->size(), size_type(0), __s, __n);
        this->_M_set_length(__len);
        return *this;
    }


    template <typename _InputIterator> basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type)     {
        const basic_string<_CharT, _Traits, _Alloc> __s(__k1, __k2);
        const size_type __n1 = __i2 - __i1;
        return this->_M_replace(__i1 - begin(), __n1, __s._M_data(), __s.size());
    }

;
    basic_string<_CharT, _Traits, _Alloc> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT __c)     {
        this->_M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
        const size_type __old_size = this->size();
        const size_type __new_size = __old_size + __n2 - __n1;
        if (__new_size <= this->capacity()) {
            _CharT *__p = this->_M_data() + __pos1;
            const size_type __how_much = __old_size - __pos1 - __n1;
            if (__how_much && __n1 != __n2)
                this->_S_move(__p + __n2, __p + __n1, __how_much);
        } else
            this->_M_mutate(__pos1, __n1, 0, __n2);
        if (__n2)
            this->_S_assign(this->_M_data() + __pos1, __n2, __c);
        this->_M_set_length(__new_size);
        return *this;
    }


    basic_string<_CharT, _Traits, _Alloc> &_M_replace(size_type __pos, size_type __len1, const _CharT *__s, const size_type __len2)     {
        this->_M_check_length(__len1, __len2, "basic_string::_M_replace");
        const size_type __old_size = this->size();
        const size_type __new_size = __old_size + __len2 - __len1;
        if (__new_size <= this->capacity()) {
            _CharT *__p = this->_M_data() + __pos;
            const size_type __how_much = __old_size - __pos - __len1;
            if (this->_M_disjunct(__s)) {
                if (__how_much && __len1 != __len2)
                    this->_S_move(__p + __len2, __p + __len1, __how_much);
                if (__len2)
                    this->_S_copy(__p, __s, __len2);
            } else {
                if (__len2 && __len2 <= __len1)
                    this->_S_move(__p, __s, __len2);
                if (__how_much && __len1 != __len2)
                    this->_S_move(__p + __len2, __p + __len1, __how_much);
                if (__len2 > __len1) {
                    if (__s + __len2 <= __p + __len1)
                        this->_S_move(__p, __s, __len2);
                    else if (__s >= __p + __len1)
                        this->_S_copy(__p, __s + __len2 - __len1, __len2);
                    else {
                        const size_type __nleft = (__p + __len1) - __s;
                        this->_S_move(__p, __s, __nleft);
                        this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
                    }
                }
            }
        } else
            this->_M_mutate(__pos, __len1, __s, __len2);
        this->_M_set_length(__new_size);
        return *this;
    }


    typename basic_string<_CharT, _Traits, _Alloc>::size_type copy(_CharT *__s, size_type __n, size_type __pos = 0) const     {
        this->_M_check(__pos, "basic_string::copy");
        __n = this->_M_limit(__pos, __n);
        ;
        if (__n)
            _S_copy(__s, _M_data() + __pos, __n);
        return __n;
    }


    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        ;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        const __size_type __len = _Traits::length(__lhs);
        __string_type __str;
        __str.reserve(__len + __rhs.size());
        __str.append(__lhs, __len);
        __str.append(__rhs);
        return __str;
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        __string_type __str;
        const __size_type __len = __rhs.size();
        __str.reserve(__len + 1);
        __str.append(__size_type(1), __lhs);
        __str.append(__rhs);
        return __str;
    }

;
    typename basic_string<_CharT, _Traits, _Alloc>::size_type find(const _CharT *__s, size_type __pos, size_type __n) const     {
        ;
        const size_type __size = this->size();
        const _CharT *__data = _M_data();
        if (__n == 0)
            return __pos <= __size ? __pos : npos;
        if (__n <= __size) {
            for (; __pos <= __size - __n; ++__pos) 
                if (traits_type::eq(__data[__pos], __s[0]) && traits_type::compare(__data + __pos + 1, __s + 1, __n - 1) == 0)
                    return __pos;
        }
        return npos;
    }


    typename basic_string<_CharT, _Traits, _Alloc>::size_type find(_CharT __c, size_type __pos = 0) const     {
        size_type __ret = npos;
        const size_type __size = this->size();
        if (__pos < __size) {
            const _CharT *__data = _M_data();
            const size_type __n = __size - __pos;
            const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
            if (__p)
                __ret = __p - __data;
        }
        return __ret;
    }


    typename basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const _CharT *__s, size_type __pos, size_type __n) const     {
        ;
        const size_type __size = this->size();
        if (__n <= __size) {
            __pos = std::min(size_type(__size - __n), __pos);
            const _CharT *__data = _M_data();
            do {
                if (traits_type::compare(__data + __pos, __s, __n) == 0)
                    return __pos;
            } while (__pos-- > 0);
        }
        return npos;
    }


    typename basic_string<_CharT, _Traits, _Alloc>::size_type rfind(_CharT __c, size_type __pos = npos) const     {
        size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            for (++__size; __size-- > 0;) 
                if (traits_type::eq(_M_data()[__size], __c))
                    return __size;
        }
        return npos;
    }


    typename basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const _CharT *__s, size_type __pos, size_type __n) const     {
        ;
        for (; __n && __pos < this->size(); ++__pos) {
            const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]);
            if (__p)
                return __pos;
        }
        return npos;
    }


    typename basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const _CharT *__s, size_type __pos, size_type __n) const     {
        ;
        size_type __size = this->size();
        if (__size && __n) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size-- != 0);
        }
        return npos;
    }


    typename basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const _CharT *__s, size_type __pos, size_type __n) const     {
        ;
        for (; __pos < this->size(); ++__pos) 
            if (!traits_type::find(__s, __n, _M_data()[__pos]))
                return __pos;
        return npos;
    }


    typename basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(_CharT __c, size_type __pos = 0) const     {
        for (; __pos < this->size(); ++__pos) 
            if (!traits_type::eq(_M_data()[__pos], __c))
                return __pos;
        return npos;
    }


    typename basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const _CharT *__s, size_type __pos, size_type __n) const     {
        ;
        size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size--);
        }
        return npos;
    }


    typename basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(_CharT __c, size_type __pos = npos) const     {
        size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::eq(_M_data()[__size], __c))
                    return __size;
            } while (__size--);
        }
        return npos;
    }


    int compare(size_type __pos, size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) const     {
        this->_M_check(__pos, "basic_string::compare");
        __n = this->_M_limit(__pos, __n);
        const size_type __osize = __str.size();
        const size_type __len = std::min(__n, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
        if (!__r)
            __r = _S_compare(__n, __osize);
        return __r;
    }


    int compare(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos2, size_type __n2) const     {
        this->_M_check(__pos1, "basic_string::compare");
        __str._M_check(__pos2, "basic_string::compare");
        __n1 = this->_M_limit(__pos1, __n1);
        __n2 = __str._M_limit(__pos2, __n2);
        const size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos1, __str.data() + __pos2, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }


    int compare(const _CharT *__s) const     {
        ;
        const size_type __size = this->size();
        const size_type __osize = traits_type::length(__s);
        const size_type __len = std::min(__size, __osize);
        int __r = traits_type::compare(_M_data(), __s, __len);
        if (!__r)
            __r = _S_compare(__size, __osize);
        return __r;
    }


    int compare(size_type __pos, size_type __n1, const _CharT *__s) const     {
        ;
        this->_M_check(__pos, "basic_string::compare");
        __n1 = this->_M_limit(__pos, __n1);
        const size_type __osize = traits_type::length(__s);
        const size_type __len = std::min(__n1, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __osize);
        return __r;
    }


    int compare(size_type __pos, size_type __n1, const _CharT *__s, size_type __n2) const     {
        ;
        this->_M_check(__pos, "basic_string::compare");
        __n1 = this->_M_limit(__pos, __n1);
        const size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }


    template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &operator>>(basic_istream<char> &__is, basic_string<char> &__str)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > &__str)template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        typedef ctype<_CharT> __ctype_type;
        typedef typename __ctype_type::ctype_base __ctype_base;
        __size_type __extracted = 0;
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                __str.erase();
                _CharT __buf[128];
                __size_type __len = 0;
                const streamsize __w = __in.width();
                const __size_type __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        if (__len == sizeof (__buf) / sizeof(_CharT)) {
                            __str.append(__buf, sizeof (__buf) / sizeof(_CharT));
                            __len = 0;
                        }
                        __buf[__len++] = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                __str.append(__buf, __len);
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &getline(basic_istream<char> &__in, basic_string<char> &__str, char __delim)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t> &getline(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim)template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        __size_type __extracted = 0;
        const __size_type __n = __str.max_size();
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, true);
        if (__cerb) {
            try {
                __str.erase();
                const __int_type __idelim = _Traits::to_int_type(__delim);
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !_Traits::eq_int_type(__c, __idelim))
                    {
                        __str += _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                else if (_Traits::eq_int_type(__c, __idelim)) {
                    ++__extracted;
                    __in.rdbuf()->sbumpc();
                } else
                    __err |= __ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }

;
    class basic_string {
        typedef typename __gnu_cxx::__alloc_traits<allocator<char> >::rebind<char>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
    public:
        typedef std::char_traits<char> traits_type;
        typedef typename char_traits<char>::char_type value_type;
        typedef _Char_alloc_type allocator_type;
        typedef typename _Alloc_traits::size_type size_type;
        typedef typename _Alloc_traits::difference_type difference_type;
        typedef typename _Alloc_traits::reference reference;
        typedef typename _Alloc_traits::const_reference const_reference;
        typedef typename _Alloc_traits::pointer pointer;
        typedef typename _Alloc_traits::const_pointer const_pointer;
        typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char> > iterator;
        typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char> > const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        static const size_type npos = static_cast<size_type>(-1);
    private:
        typedef iterator __const_iterator;
        struct _Alloc_hider : allocator_type {
            _Alloc_hider(pointer __dat, const std::allocator<char> &__a) : allocator_type(__a), _M_p(__dat)             {
            }


            pointer _M_p;
        };
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider _M_dataplus;
        size_type _M_string_length;
        enum  {
            _S_local_capacity = 15 / sizeof(char)
        };
        union {
            char _M_local_buf[16];
            size_type _M_allocated_capacity;
        };
        void _M_data(pointer __p)         {
            this->_M_dataplus._M_p = __p;
        }


        void _M_length(size_type __length)         {
            this->_M_string_length = __length;
        }


        pointer _M_data() const         {
            return this->_M_dataplus._M_p;
        }


        pointer _M_local_data()         {
            return pointer(this->_M_local_buf);
        }


        const_pointer _M_local_data() const         {
            return const_pointer(this->_M_local_buf);
        }


        void _M_capacity(size_type __capacity)         {
            this->_M_allocated_capacity = __capacity;
        }


        void _M_set_length(size_type __n)         {
            this->_M_length(__n);
            traits_type::assign(this->_M_data()[__n], char());
        }


        bool _M_is_local() const         {
            return this->_M_data() == this->_M_local_data();
        }


        pointer _M_create(size_type &, size_type);
        void _M_dispose()         {
            if (!this->_M_is_local())
                this->_M_destroy(this->_M_allocated_capacity);
        }


        void _M_destroy(size_type __size) throw()         {
            _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
        }


        template <typename _InIterator = char *> void _M_construct_aux(char *__beg, char *__end, std::__false_type)         {
            typedef typename iterator_traits<char *>::iterator_category _Tag;
            this->_M_construct(__beg, __end, _Tag());
        }

template <typename _InIterator = const char *> void _M_construct_aux(const char *__beg, const char *__end, std::__false_type)         {
            typedef typename iterator_traits<const char *>::iterator_category _Tag;
            this->_M_construct(__beg, __end, _Tag());
        }

template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
        template <typename _Integer = char *> void _M_construct_aux(char *__beg, char *__end, std::__true_type)template <typename _Integer = const char *> void _M_construct_aux(const char *__beg, const char *__end, std::__true_type)template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
        void _M_construct_aux_2(size_type __req, char __c);
        template <typename _InIterator = char *> void _M_construct(char *__beg, char *__end)         {
            typedef typename std::__is_integer<char *>::__type _Integral;
            this->_M_construct_aux(__beg, __end, _Integral());
        }

template <typename _InIterator = const char *> void _M_construct(const char *__beg, const char *__end)         {
            typedef typename std::__is_integer<const char *>::__type _Integral;
            this->_M_construct_aux(__beg, __end, _Integral());
        }

template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
        template <typename _InIterator = char *> void _M_construct(char *__beg, char *__end, std::input_iterator_tag)template <typename _InIterator = const char *> void _M_construct(const char *__beg, const char *__end, std::input_iterator_tag)template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
        template <typename _FwdIterator = char *> void _M_construct(char *__beg, char *__end, std::forward_iterator_tag)         {
            if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                std::__throw_logic_error(("basic_string::_M_construct null not valid"));
            size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
            if (__dnew > size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, size_type(0)));
                this->_M_capacity(__dnew);
            }
            try {
                this->_S_copy_chars(this->_M_data(), __beg, __end);
            } catch (...) {
                this->_M_dispose();
                throw;
            }
            this->_M_set_length(__dnew);
        }

template <typename _FwdIterator = const char *> void _M_construct(const char *__beg, const char *__end, std::forward_iterator_tag)         {
            if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                std::__throw_logic_error(("basic_string::_M_construct null not valid"));
            size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
            if (__dnew > size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, size_type(0)));
                this->_M_capacity(__dnew);
            }
            try {
                this->_S_copy_chars(this->_M_data(), __beg, __end);
            } catch (...) {
                this->_M_dispose();
                throw;
            }
            this->_M_set_length(__dnew);
        }

template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
        void _M_construct(size_type __req, char __c);
        allocator_type &_M_get_allocator()         {
            return this->_M_dataplus;
        }


        const allocator_type &_M_get_allocator() const         {
            return this->_M_dataplus;
        }


    private:
        size_type _M_check(size_type __pos, const char *__s) const;
        void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
        size_type _M_limit(size_type __pos, size_type __off) const;
        bool _M_disjunct(const char *__s) const;
        static void _S_copy(char *__d, const char *__s, size_type __n)         {
            if (__n == 1)
                traits_type::assign(*__d, *__s);
            else
                traits_type::copy(__d, __s, __n);
        }


        static void _S_move(char *__d, const char *__s, size_type __n);
        static void _S_assign(char *__d, size_type __n, char __c);
        template <class _Iterator = char *> static void _S_copy_chars(char *__p, char *__k1, char *__k2)template <class _Iterator = const char *> static void _S_copy_chars(char *__p, const char *__k1, const char *__k2)template <class _Iterator> static void _S_copy_chars(char *__p, _Iterator __k1, _Iterator __k2);
        static void _S_copy_chars(char *__p, iterator __k1, iterator __k2);
        static void _S_copy_chars(char *__p, const_iterator __k1, const_iterator __k2);
        static void _S_copy_chars(char *__p, char *__k1, char *__k2)         {
            _S_copy(__p, __k1, __k2 - __k1);
        }


        static void _S_copy_chars(char *__p, const char *__k1, const char *__k2)         {
            _S_copy(__p, __k1, __k2 - __k1);
        }


        static int _S_compare(size_type __n1, size_type __n2);
        void _M_assign(const std::__cxx11::basic_string<char> &__rcs);
        void _M_mutate(size_type __pos, size_type __len1, const char *__s, size_type __len2);
        void _M_erase(size_type __pos, size_type __n);
    public:
        basic_string();
        explicit basic_string(const std::allocator<char> &__a);
        basic_string(const std::__cxx11::basic_string<char> &__str) : _M_dataplus(this->_M_local_data(), __str._M_get_allocator())         {
            this->_M_construct(__str._M_data(), __str._M_data() + __str.length());
        }


        basic_string(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n);
        basic_string(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n, const std::allocator<char> &__a);
        basic_string(const char *__s, size_type __n, const std::allocator<char> &__a);
        basic_string(const char *__s, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)         {
            this->_M_construct(__s, __s ? __s + traits_type::length(__s) : __s + npos);
        }


        basic_string(size_type __n, char __c, const std::allocator<char> &__a);
        template <typename _InputIterator> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char> &__a);
        ~std::__cxx11::basic_string<char>()         {
            this->_M_dispose();
        }


        std::__cxx11::basic_string<char> &operator=(const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &operator=(const char *__s);
        std::__cxx11::basic_string<char> &operator=(char __c);
        iterator begin();
        const_iterator begin() const;
        iterator end();
        const_iterator end() const;
        reverse_iterator rbegin();
        const_reverse_iterator rbegin() const;
        reverse_iterator rend();
        const_reverse_iterator rend() const;
    public:
        size_type size() const         {
            return this->_M_string_length;
        }


        size_type length() const         {
            return this->_M_string_length;
        }


        size_type max_size() const;
        void resize(size_type __n, char __c);
        void resize(size_type __n);
        size_type capacity() const;
        void reserve(size_type __res_arg);
        void clear();
        bool empty() const;
        const_reference operator[](size_type __pos) const;
        reference operator[](size_type __pos);
        const_reference at(size_type __n) const;
        reference at(size_type __n);
        std::__cxx11::basic_string<char> &operator+=(const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &operator+=(const char *__s);
        std::__cxx11::basic_string<char> &operator+=(char __c);
        std::__cxx11::basic_string<char> &append(const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &append(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n);
        std::__cxx11::basic_string<char> &append(const char *__s, size_type __n);
        std::__cxx11::basic_string<char> &append(const char *__s);
        std::__cxx11::basic_string<char> &append(size_type __n, char __c);
        template <class _InputIterator> std::__cxx11::basic_string<char> &append(_InputIterator __first, _InputIterator __last);
        void push_back(char __c);
        std::__cxx11::basic_string<char> &assign(const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &assign(const std::__cxx11::basic_string<char> &__str, size_type __pos, size_type __n);
        std::__cxx11::basic_string<char> &assign(const char *__s, size_type __n);
        std::__cxx11::basic_string<char> &assign(const char *__s);
        std::__cxx11::basic_string<char> &assign(size_type __n, char __c);
        template <class _InputIterator> std::__cxx11::basic_string<char> &assign(_InputIterator __first, _InputIterator __last);
        void insert(iterator __p, size_type __n, char __c);
        template <class _InputIterator> void insert(iterator __p, _InputIterator __beg, _InputIterator __end);
        std::__cxx11::basic_string<char> &insert(size_type __pos1, const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &insert(size_type __pos1, const std::__cxx11::basic_string<char> &__str, size_type __pos2, size_type __n);
        std::__cxx11::basic_string<char> &insert(size_type __pos, const char *__s, size_type __n);
        std::__cxx11::basic_string<char> &insert(size_type __pos, const char *__s);
        std::__cxx11::basic_string<char> &insert(size_type __pos, size_type __n, char __c);
        iterator insert(__const_iterator __p, char __c);
        std::__cxx11::basic_string<char> &erase(size_type __pos, size_type __n);
        iterator erase(__const_iterator __position);
        iterator erase(__const_iterator __first, __const_iterator __last);
        std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n, const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &replace(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<char> &__str, size_type __pos2, size_type __n2);
        std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n1, const char *__s, size_type __n2);
        std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n1, const char *__s);
        std::__cxx11::basic_string<char> &replace(size_type __pos, size_type __n1, size_type __n2, char __c);
        std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__s, size_type __n);
        std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__s);
        std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, char __c);
        template <class _InputIterator> std::__cxx11::basic_string<char> &replace(iterator __i1, iterator __i2, _InputIterator __k1, _InputIterator __k2);
        std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, char *__k1, char *__k2);
        std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__k1, const char *__k2);
        std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
        std::__cxx11::basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
    private:
        template <class _Integer> std::__cxx11::basic_string<char> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
        template <class _InputIterator> std::__cxx11::basic_string<char> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
        std::__cxx11::basic_string<char> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, char __c);
        std::__cxx11::basic_string<char> &_M_replace(size_type __pos, size_type __len1, const char *__s, const size_type __len2);
        std::__cxx11::basic_string<char> &_M_append(const char *__s, size_type __n);
    public:
        size_type copy(char *__s, size_type __n, size_type __pos) const;
        void swap(std::__cxx11::basic_string<char> &__s);
        const char *c_str() const;
        const char *data() const         {
            return this->_M_data();
        }


        allocator_type get_allocator() const;
        size_type find(const char *__s, size_type __pos, size_type __n) const;
        size_type find(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
        size_type find(const char *__s, size_type __pos) const;
        size_type find(char __c, size_type __pos) const;
        size_type rfind(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
        size_type rfind(const char *__s, size_type __pos, size_type __n) const;
        size_type rfind(const char *__s, size_type __pos) const;
        size_type rfind(char __c, size_type __pos) const;
        size_type find_first_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
        size_type find_first_of(const char *__s, size_type __pos, size_type __n) const;
        size_type find_first_of(const char *__s, size_type __pos) const;
        size_type find_first_of(char __c, size_type __pos) const;
        size_type find_last_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
        size_type find_last_of(const char *__s, size_type __pos, size_type __n) const;
        size_type find_last_of(const char *__s, size_type __pos) const;
        size_type find_last_of(char __c, size_type __pos) const;
        size_type find_first_not_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
        size_type find_first_not_of(const char *__s, size_type __pos, size_type __n) const;
        size_type find_first_not_of(const char *__s, size_type __pos) const;
        size_type find_first_not_of(char __c, size_type __pos) const;
        size_type find_last_not_of(const std::__cxx11::basic_string<char> &__str, size_type __pos) const;
        size_type find_last_not_of(const char *__s, size_type __pos, size_type __n) const;
        size_type find_last_not_of(const char *__s, size_type __pos) const;
        size_type find_last_not_of(char __c, size_type __pos) const;
        std::__cxx11::basic_string<char> substr(size_type __pos, size_type __n) const;
        int compare(const std::__cxx11::basic_string<char> &__str) const;
        int compare(size_type __pos, size_type __n, const std::__cxx11::basic_string<char> &__str) const;
        int compare(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<char> &__str, size_type __pos2, size_type __n2) const;
        int compare(const char *__s) const;
        int compare(size_type __pos, size_type __n1, const char *__s) const;
        int compare(size_type __pos, size_type __n1, const char *__s, size_type __n2) const;
    };
    class basic_string {
        typedef typename __gnu_cxx::__alloc_traits<allocator<wchar_t> >::rebind<wchar_t>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
    public:
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename char_traits<wchar_t>::char_type value_type;
        typedef _Char_alloc_type allocator_type;
        typedef typename _Alloc_traits::size_type size_type;
        typedef typename _Alloc_traits::difference_type difference_type;
        typedef typename _Alloc_traits::reference reference;
        typedef typename _Alloc_traits::const_reference const_reference;
        typedef typename _Alloc_traits::pointer pointer;
        typedef typename _Alloc_traits::const_pointer const_pointer;
        typedef __gnu_cxx::__normal_iterator<pointer, basic_string<wchar_t> > iterator;
        typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<wchar_t> > const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        static const size_type npos = static_cast<size_type>(-1);
    private:
        typedef iterator __const_iterator;
        struct _Alloc_hider : allocator_type {
            _Alloc_hider(pointer __dat, const std::allocator<wchar_t> &__a);
            pointer _M_p;
        };
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::_Alloc_hider _M_dataplus;
        size_type _M_string_length;
        enum  {
            _S_local_capacity = 15 / sizeof(wchar_t)
        };
        union {
            wchar_t _M_local_buf[4];
            size_type _M_allocated_capacity;
        };
        void _M_data(pointer __p);
        void _M_length(size_type __length);
        pointer _M_data() const;
        pointer _M_local_data();
        const_pointer _M_local_data() const;
        void _M_capacity(size_type __capacity);
        void _M_set_length(size_type __n);
        bool _M_is_local() const;
        pointer _M_create(size_type &, size_type);
        void _M_dispose();
        void _M_destroy(size_type __size) throw();
        template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
        template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
        void _M_construct_aux_2(size_type __req, wchar_t __c);
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
        template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
        void _M_construct(size_type __req, wchar_t __c);
        allocator_type &_M_get_allocator();
        const allocator_type &_M_get_allocator() const;
    private:
        size_type _M_check(size_type __pos, const char *__s) const;
        void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
        size_type _M_limit(size_type __pos, size_type __off) const;
        bool _M_disjunct(const wchar_t *__s) const;
        static void _S_copy(wchar_t *__d, const wchar_t *__s, size_type __n);
        static void _S_move(wchar_t *__d, const wchar_t *__s, size_type __n);
        static void _S_assign(wchar_t *__d, size_type __n, wchar_t __c);
        template <class _Iterator> static void _S_copy_chars(wchar_t *__p, _Iterator __k1, _Iterator __k2);
        static void _S_copy_chars(wchar_t *__p, iterator __k1, iterator __k2);
        static void _S_copy_chars(wchar_t *__p, const_iterator __k1, const_iterator __k2);
        static void _S_copy_chars(wchar_t *__p, wchar_t *__k1, wchar_t *__k2);
        static void _S_copy_chars(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2);
        static int _S_compare(size_type __n1, size_type __n2);
        void _M_assign(const std::__cxx11::basic_string<wchar_t> &__rcs);
        void _M_mutate(size_type __pos, size_type __len1, const wchar_t *__s, size_type __len2);
        void _M_erase(size_type __pos, size_type __n);
    public:
        basic_string();
        explicit basic_string(const std::allocator<wchar_t> &__a);
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str);
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n, const std::allocator<wchar_t> &__a);
        basic_string(const wchar_t *__s, size_type __n, const std::allocator<wchar_t> &__a);
        basic_string(const wchar_t *__s, const std::allocator<wchar_t> &__a);
        basic_string(size_type __n, wchar_t __c, const std::allocator<wchar_t> &__a);
        template <typename _InputIterator> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<wchar_t> &__a);
        ~std::__cxx11::basic_string<wchar_t>();
        std::__cxx11::basic_string<wchar_t> &operator=(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &operator=(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &operator=(wchar_t __c);
        iterator begin();
        const_iterator begin() const;
        iterator end();
        const_iterator end() const;
        reverse_iterator rbegin();
        const_reverse_iterator rbegin() const;
        reverse_iterator rend();
        const_reverse_iterator rend() const;
    public:
        size_type size() const;
        size_type length() const;
        size_type max_size() const;
        void resize(size_type __n, wchar_t __c);
        void resize(size_type __n);
        size_type capacity() const;
        void reserve(size_type __res_arg);
        void clear();
        bool empty() const;
        const_reference operator[](size_type __pos) const;
        reference operator[](size_type __pos);
        const_reference at(size_type __n) const;
        reference at(size_type __n);
        std::__cxx11::basic_string<wchar_t> &operator+=(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &operator+=(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &operator+=(wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &append(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &append(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
        std::__cxx11::basic_string<wchar_t> &append(const wchar_t *__s, size_type __n);
        std::__cxx11::basic_string<wchar_t> &append(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &append(size_type __n, wchar_t __c);
        template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &append(_InputIterator __first, _InputIterator __last);
        void push_back(wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &assign(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &assign(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
        std::__cxx11::basic_string<wchar_t> &assign(const wchar_t *__s, size_type __n);
        std::__cxx11::basic_string<wchar_t> &assign(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &assign(size_type __n, wchar_t __c);
        template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &assign(_InputIterator __first, _InputIterator __last);
        void insert(iterator __p, size_type __n, wchar_t __c);
        template <class _InputIterator> void insert(iterator __p, _InputIterator __beg, _InputIterator __end);
        std::__cxx11::basic_string<wchar_t> &insert(size_type __pos1, const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &insert(size_type __pos1, const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos2, size_type __n);
        std::__cxx11::basic_string<wchar_t> &insert(size_type __pos, const wchar_t *__s, size_type __n);
        std::__cxx11::basic_string<wchar_t> &insert(size_type __pos, const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &insert(size_type __pos, size_type __n, wchar_t __c);
        iterator insert(__const_iterator __p, wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &erase(size_type __pos, size_type __n);
        iterator erase(__const_iterator __position);
        iterator erase(__const_iterator __first, __const_iterator __last);
        std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n, const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &replace(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2);
        std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const wchar_t *__s, size_type __n2);
        std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, size_type __n2, wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__s, size_type __n);
        std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, wchar_t __c);
        template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &replace(iterator __i1, iterator __i2, _InputIterator __k1, _InputIterator __k2);
        std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, wchar_t *__k1, wchar_t *__k2);
        std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__k1, const wchar_t *__k2);
        std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
        std::__cxx11::basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
    private:
        template <class _Integer> std::__cxx11::basic_string<wchar_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
        template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
        std::__cxx11::basic_string<wchar_t> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &_M_replace(size_type __pos, size_type __len1, const wchar_t *__s, const size_type __len2);
        std::__cxx11::basic_string<wchar_t> &_M_append(const wchar_t *__s, size_type __n);
    public:
        size_type copy(wchar_t *__s, size_type __n, size_type __pos) const;
        void swap(std::__cxx11::basic_string<wchar_t> &__s);
        const wchar_t *c_str() const;
        const wchar_t *data() const;
        allocator_type get_allocator() const;
        size_type find(const wchar_t *__s, size_type __pos, size_type __n) const;
        size_type find(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
        size_type find(const wchar_t *__s, size_type __pos) const;
        size_type find(wchar_t __c, size_type __pos) const;
        size_type rfind(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
        size_type rfind(const wchar_t *__s, size_type __pos, size_type __n) const;
        size_type rfind(const wchar_t *__s, size_type __pos) const;
        size_type rfind(wchar_t __c, size_type __pos) const;
        size_type find_first_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
        size_type find_first_of(const wchar_t *__s, size_type __pos, size_type __n) const;
        size_type find_first_of(const wchar_t *__s, size_type __pos) const;
        size_type find_first_of(wchar_t __c, size_type __pos) const;
        size_type find_last_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
        size_type find_last_of(const wchar_t *__s, size_type __pos, size_type __n) const;
        size_type find_last_of(const wchar_t *__s, size_type __pos) const;
        size_type find_last_of(wchar_t __c, size_type __pos) const;
        size_type find_first_not_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
        size_type find_first_not_of(const wchar_t *__s, size_type __pos, size_type __n) const;
        size_type find_first_not_of(const wchar_t *__s, size_type __pos) const;
        size_type find_first_not_of(wchar_t __c, size_type __pos) const;
        size_type find_last_not_of(const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos) const;
        size_type find_last_not_of(const wchar_t *__s, size_type __pos, size_type __n) const;
        size_type find_last_not_of(const wchar_t *__s, size_type __pos) const;
        size_type find_last_not_of(wchar_t __c, size_type __pos) const;
        std::__cxx11::basic_string<wchar_t> substr(size_type __pos, size_type __n) const;
        int compare(const std::__cxx11::basic_string<wchar_t> &__str) const;
        int compare(size_type __pos, size_type __n, const std::__cxx11::basic_string<wchar_t> &__str) const;
        int compare(size_type __pos1, size_type __n1, const std::__cxx11::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2) const;
        int compare(const wchar_t *__s) const;
        int compare(size_type __pos, size_type __n1, const wchar_t *__s) const;
        int compare(size_type __pos, size_type __n1, const wchar_t *__s, size_type __n2) const;
    };
}
namespace std {
    class locale {
    public:
        typedef int category;
        class facet;
        class id;
        class _Impl;
        friend  class facet;
        friend  class _Impl;
        friend template <typename _Facet = std::__cxx11::collate<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::collate<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::ctype<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::numpunct<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_put<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_get<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::ctype<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::numpunct<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_put<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_get<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet> bool has_facet(const std::locale &) throw();
        friend template <typename _Facet = std::__cxx11::collate<char>> const std::__cxx11::collate<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::collate<wchar_t>> const std::__cxx11::collate<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::ctype<char>> const std::ctype<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::numpunct<char>> const std::__cxx11::numpunct<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_put<char>> const std::num_put<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_get<char>> const std::num_get<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::ctype<wchar_t>> const std::ctype<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::numpunct<wchar_t>> const std::__cxx11::numpunct<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_put<wchar_t>> const std::num_put<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_get<wchar_t>> const std::num_get<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Cache> struct __use_cache;
        static const category none = 0;
        static const category ctype = 1L << 0;
        static const category numeric = 1L << 1;
        static const category collate = 1L << 2;
        static const category time = 1L << 3;
        static const category monetary = 1L << 4;
        static const category messages = 1L << 5;
        static const category all = (ctype | numeric | collate | time | monetary | messages);
        locale() throw();
        locale(const std::locale &__other) throw();
        explicit locale(const char *__s);
        locale(const std::locale &__base, const char *__s, category __cat);
        locale(const std::locale &__base, const std::locale &__add, category __cat);
        template <typename _Facet> locale(const std::locale &__other, _Facet *__f);
        ~std::locale() throw();
        const std::locale &operator=(const std::locale &__other) throw();
        template <typename _Facet> std::locale combine(const std::locale &__other) const;
        string name() const __attribute__((abi_tag("cxx11")));
        bool operator==(const std::locale &__other) const throw();
        bool operator!=(const std::locale &__other) const throw()         {
            return !(this->operator==(__other));
        }


        template <typename _Char, typename _Traits, typename _Alloc> bool operator()(const basic_string<_Char, _Traits, _Alloc> &__s1, const basic_string<_Char, _Traits, _Alloc> &__s2) const;
        static std::locale global(const std::locale &__loc);
        static const std::locale &classic();
    private:
        std::locale::_Impl *_M_impl;
        static std::locale::_Impl *_S_classic;
        static std::locale::_Impl *_S_global;
        static const char *const *const _S_categories;
        enum  {
            _S_categories_size = 6 + 6
        };
        static __gthread_once_t _S_once;
        explicit locale(std::locale::_Impl *) throw();
        static void _S_initialize();
        static void _S_initialize_once() throw();
        static category _S_normalize_category(category);
        void _M_coalesce(const std::locale &__base, const std::locale &__add, category __cat);
        static const std::locale::id *const _S_twinned_facets[];
    };
    class facet {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        mutable _Atomic_word _M_refcount;
        static __c_locale _S_c_locale;
        static const char _S_c_name[2];
        static __gthread_once_t _S_once;
        static void _S_initialize_once();
    protected:
        explicit facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)         {
        }


        virtual ~std::locale::facet();
        static void _S_create_c_locale(__c_locale &__cloc, const char *__s, __c_locale __old = 0);
        static __c_locale _S_clone_c_locale(__c_locale &__cloc) throw();
        static void _S_destroy_c_locale(__c_locale &__cloc);
        static __c_locale _S_lc_ctype_c_locale(__c_locale __cloc, const char *__s);
        static __c_locale _S_get_c_locale();
        static const char *_S_get_c_name() throw() __attribute__((const));
    private:
        void _M_add_reference() const throw()         {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }


        void _M_remove_reference() const throw()         {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }


        facet(const std::locale::facet &);
        std::locale::facet &operator=(const std::locale::facet &);
        class __shim;
        const std::locale::facet *_M_sso_shim(const std::locale::id *) const;
        const std::locale::facet *_M_cow_shim(const std::locale::id *) const;
    };
    class id {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        friend template <typename _Facet = std::__cxx11::collate<char>> const std::__cxx11::collate<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::collate<wchar_t>> const std::__cxx11::collate<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::ctype<char>> const std::ctype<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::numpunct<char>> const std::__cxx11::numpunct<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_put<char>> const std::num_put<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_get<char>> const std::num_get<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::ctype<wchar_t>> const std::ctype<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::numpunct<wchar_t>> const std::__cxx11::numpunct<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_put<wchar_t>> const std::num_put<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_get<wchar_t>> const std::num_get<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Facet = std::__cxx11::collate<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::collate<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::ctype<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::numpunct<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_put<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_get<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::ctype<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::numpunct<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_put<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_get<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet> bool has_facet(const std::locale &) throw();
        mutable size_t _M_index;
        static _Atomic_word _S_refcount;
        void operator=(const std::locale::id &);
        id(const std::locale::id &);
    public:
        id()         {
        }


        size_t _M_id() const throw();
    };
    class _Impl {
    public:
        friend  class locale;
        friend  class locale::facet;
        friend template <typename _Facet = std::__cxx11::collate<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::collate<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::ctype<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::numpunct<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_put<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_get<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::ctype<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::numpunct<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_put<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_get<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet> bool has_facet(const std::locale &) throw();
        friend template <typename _Facet = std::__cxx11::collate<char>> const std::__cxx11::collate<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::collate<wchar_t>> const std::__cxx11::collate<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::ctype<char>> const std::ctype<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::numpunct<char>> const std::__cxx11::numpunct<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_put<char>> const std::num_put<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_get<char>> const std::num_get<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::ctype<wchar_t>> const std::ctype<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::numpunct<wchar_t>> const std::__cxx11::numpunct<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_put<wchar_t>> const std::num_put<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_get<wchar_t>> const std::num_get<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Cache> struct __use_cache;
    private:
        _Atomic_word _M_refcount;
        const std::locale::facet **_M_facets;
        size_t _M_facets_size;
        const std::locale::facet **_M_caches;
        char **_M_names;
        static const locale::id *const _S_id_ctype[];
        static const locale::id *const _S_id_numeric[];
        static const locale::id *const _S_id_collate[];
        static const locale::id *const _S_id_time[];
        static const locale::id *const _S_id_monetary[];
        static const locale::id *const _S_id_messages[];
        static const locale::id *const *const _S_facet_categories[];
        void _M_add_reference() throw()         {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }


        void _M_remove_reference() throw()         {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }


        _Impl(const std::locale::_Impl &, size_t);
        _Impl(const char *, size_t);
        _Impl(size_t) throw();
        ~std::locale::_Impl() throw();
        _Impl(const std::locale::_Impl &);
        void operator=(const std::locale::_Impl &);
        bool _M_check_same_name()         {
            bool __ret = true;
            if (this->_M_names[1])
                for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i) 
                    __ret = __builtin_strcmp(this->_M_names[__i], this->_M_names[__i + 1]) == 0;
            return __ret;
        }


        void _M_replace_categories(const std::locale::_Impl *, category);
        void _M_replace_category(const std::locale::_Impl *, const locale::id *const *);
        void _M_replace_facet(const std::locale::_Impl *, const locale::id *);
        void _M_install_facet(const locale::id *, const std::locale::facet *);
        template <typename _Facet> void _M_init_facet(_Facet *__facet)         {
            this->_M_install_facet(&_Facet::id, __facet);
        }

;
        template <typename _Facet> void _M_init_facet_unchecked(_Facet *__facet)         {
            __facet->_M_add_reference();
            this->_M_facets[_Facet::id._M_id()] = __facet;
        }

;
        void _M_install_cache(const std::locale::facet *, size_t);
        void _M_init_extra(std::locale::facet **);
        void _M_init_extra(void *, void *, const char *, const char *);
    };
    template <typename _CharT = char> class collate : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
    protected:
        __c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(size_t __refs);
        explicit collate(__c_locale __cloc, size_t __refs);
        int compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        string_type transform(const char *__lo, const char *__hi) const;
        long hash(const char *__lo, const char *__hi) const;
        int _M_compare(const char *, const char *) const throw();
        size_t _M_transform(char *, const char *, size_t) const throw();
    protected:
        virtual ~std::__cxx11::collate<char>();
        virtual int do_compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        virtual string_type do_transform(const char *__lo, const char *__hi) const;
        virtual long do_hash(const char *__lo, const char *__hi) const;
    }
template <typename _CharT = wchar_t> class collate : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
    protected:
        __c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(size_t __refs);
        explicit collate(__c_locale __cloc, size_t __refs);
        int compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        string_type transform(const wchar_t *__lo, const wchar_t *__hi) const;
        long hash(const wchar_t *__lo, const wchar_t *__hi) const;
        int _M_compare(const wchar_t *, const wchar_t *) const throw();
        size_t _M_transform(wchar_t *, const wchar_t *, size_t) const throw();
    protected:
        virtual ~std::__cxx11::collate<wchar_t>();
        virtual int do_compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        virtual string_type do_transform(const wchar_t *__lo, const wchar_t *__hi) const;
        virtual long do_hash(const wchar_t *__lo, const wchar_t *__hi) const;
    }
template <typename _CharT> class collate : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
    protected:
        __c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate<_CharT>(size_t __refs = 0) : std::locale::facet(__refs), _M_c_locale_collate(_S_get_c_locale())         {
        }


        explicit collate<_CharT>(__c_locale __cloc, size_t __refs = 0) : std::locale::facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))         {
        }


        int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const         {
            return this->do_compare(__lo1, __hi1, __lo2, __hi2);
        }


        string_type transform(const _CharT *__lo, const _CharT *__hi) const         {
            return this->do_transform(__lo, __hi);
        }


        long hash(const _CharT *__lo, const _CharT *__hi) const         {
            return this->do_hash(__lo, __hi);
        }


        int _M_compare(const _CharT *, const _CharT *) const throw();
        size_t _M_transform(_CharT *, const _CharT *, size_t) const throw();
    protected:
        virtual ~collate<_CharT>()         {
            _S_destroy_c_locale(this->_M_c_locale_collate);
        }


        virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const;
        virtual string_type do_transform(const _CharT *__lo, const _CharT *__hi) const;
        virtual long do_hash(const _CharT *__lo, const _CharT *__hi) const;
    };
    locale::id id;
    int _M_compare(const char *, const char *) const throw();
    size_t _M_transform(char *, const char *, size_t) const throw();
    int _M_compare(const wchar_t *, const wchar_t *) const throw();
    size_t _M_transform(wchar_t *, const wchar_t *, size_t) const throw();
    template <typename _CharT = char> class collate_byname : public collate<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit collate_byname(const char *__s, size_t __refs);
    protected:
        virtual ~std::__cxx11::collate_byname<char>();
    }
template <typename _CharT = wchar_t> class collate_byname : public collate<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit collate_byname(const char *__s, size_t __refs);
    protected:
        virtual ~std::__cxx11::collate_byname<wchar_t>();
    }
template <typename _CharT> class collate_byname : public collate<_CharT> {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
        explicit collate_byname<_CharT>(const char *__s, size_t __refs = 0) : collate<_CharT>(__refs)         {
            if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                this->_S_destroy_c_locale(this->_M_c_locale_collate);
                this->_S_create_c_locale(this->_M_c_locale_collate, __s);
            }
        }


    protected:
        virtual ~collate_byname<_CharT>()         {
        }


    };
}
namespace std {
    template <typename _Facet> locale(const std::locale &__other, _Facet *__f)     {
        this->_M_impl = new std::locale::_Impl(*__other._M_impl, 1);
        try {
            this->_M_impl->_M_install_facet(&_Facet::id, __f);
        } catch (...) {
            this->_M_impl->_M_remove_reference();
            throw;
        }
        delete [] this->_M_impl->_M_names[0];
        this->_M_impl->_M_names[0] = 0;
    }

;
    template <typename _Facet> std::locale combine(const std::locale &__other) const     {
        std::locale::_Impl *__tmp = new std::locale::_Impl(*this->_M_impl, 1);
        try {
            __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
        } catch (...) {
            __tmp->_M_remove_reference();
            throw;
        }
        return std::locale(__tmp);
    }

;
    template <typename _CharT, typename _Traits, typename _Alloc> bool operator()(const basic_string<_CharT, _Traits, _Alloc> &__s1, const basic_string<_CharT, _Traits, _Alloc> &__s2) const     {
        typedef std::collate<_CharT> __collate_type;
        const __collate_type &__collate = use_facet<__collate_type>(*this);
        return (__collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0);
    }

;
    template <typename _Facet = std::__cxx11::collate<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::collate<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::ctype<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::numpunct<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_put<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_get<char>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::ctype<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::__cxx11::numpunct<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_put<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet = std::num_get<wchar_t>> bool has_facet(const std::locale &__loc) throw()template <typename _Facet> bool has_facet(const std::locale &__loc) throw()     {
        const size_t __i = _Facet::id._M_id();
        const locale::facet **__facets = __loc._M_impl->_M_facets;
        return (__i < __loc._M_impl->_M_facets_size && dynamic_cast<const _Facet *>(__facets[__i]));
    }

;
    template <typename _Facet = std::__cxx11::collate<char>> const std::__cxx11::collate<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::collate<wchar_t>> const std::__cxx11::collate<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::ctype<char>> const std::ctype<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::numpunct<char>> const std::__cxx11::numpunct<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_put<char>> const std::num_put<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_get<char>> const std::num_get<char> &use_facet(const std::locale &__loc)template <typename _Facet = std::ctype<wchar_t>> const std::ctype<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::__cxx11::numpunct<wchar_t>> const std::__cxx11::numpunct<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_put<wchar_t>> const std::num_put<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet = std::num_get<wchar_t>> const std::num_get<wchar_t> &use_facet(const std::locale &__loc)template <typename _Facet> const _Facet &use_facet(const std::locale &__loc)     {
        const size_t __i = _Facet::id._M_id();
        const locale::facet **__facets = __loc._M_impl->_M_facets;
        if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
            __throw_bad_cast();
        return dynamic_cast<const _Facet &>(*__facets[__i]);
    }

;
    int _M_compare(const _CharT *, const _CharT *) const throw()     {
        return 0;
    }


    size_t _M_transform(_CharT *, const _CharT *, size_t) const throw()     {
        return 0;
    }


    int do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const     {
        const string_type __one(__lo1, __hi1);
        const string_type __two(__lo2, __hi2);
        const _CharT *__p = __one.c_str();
        const _CharT *__pend = __one.data() + __one.length();
        const _CharT *__q = __two.c_str();
        const _CharT *__qend = __two.data() + __two.length();
        for (;;) {
            const int __res = this->_M_compare(__p, __q);
            if (__res)
                return __res;
            __p += char_traits<_CharT>::length(__p);
            __q += char_traits<_CharT>::length(__q);
            if (__p == __pend && __q == __qend)
                return 0;
            else if (__p == __pend)
                return -1;
            else if (__q == __qend)
                return 1;
            __p++;
            __q++;
        }
    }


    typename collate<_CharT>::string_type do_transform(const _CharT *__lo, const _CharT *__hi) const     {
        string_type __ret;
        const string_type __str(__lo, __hi);
        const _CharT *__p = __str.c_str();
        const _CharT *__pend = __str.data() + __str.length();
        size_t __len = (__hi - __lo) * 2;
        _CharT *__c = new _CharT [__len];
        try {
            for (;;) {
                size_t __res = this->_M_transform(__c, __p, __len);
                if (__res >= __len) {
                    __len = __res + 1;
                    delete [] __c , __c = 0;
                    __c = new _CharT [__len];
                    __res = this->_M_transform(__c, __p, __len);
                }
                __ret.append(__c, __res);
                __p += char_traits<_CharT>::length(__p);
                if (__p == __pend)
                    break;
                __p++;
                __ret.push_back(_CharT());
            }
        } catch (...) {
            delete [] __c;
            throw;
        }
        delete [] __c;
        return __ret;
    }


    long do_hash(const _CharT *__lo, const _CharT *__hi) const     {
        unsigned long __val = 0;
        for (; __lo < __hi; ++__lo) 
            __val = *__lo + ((__val << 7) | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::__digits - 7)));
        return static_cast<long>(__val);
    }


    class collate : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
    protected:
        __c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(size_t __refs);
        explicit collate(__c_locale __cloc, size_t __refs);
        int compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        string_type transform(const char *__lo, const char *__hi) const;
        long hash(const char *__lo, const char *__hi) const;
        int _M_compare(const char *, const char *) const throw();
        size_t _M_transform(char *, const char *, size_t) const throw();
    protected:
        virtual ~std::__cxx11::collate<char>();
        virtual int do_compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        virtual string_type do_transform(const char *__lo, const char *__hi) const;
        virtual long do_hash(const char *__lo, const char *__hi) const;
    };
    class collate_byname : public collate<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit collate_byname(const char *__s, size_t __refs);
    protected:
        virtual ~std::__cxx11::collate_byname<char>();
    };
    class collate : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
    protected:
        __c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(size_t __refs);
        explicit collate(__c_locale __cloc, size_t __refs);
        int compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        string_type transform(const wchar_t *__lo, const wchar_t *__hi) const;
        long hash(const wchar_t *__lo, const wchar_t *__hi) const;
        int _M_compare(const wchar_t *, const wchar_t *) const throw();
        size_t _M_transform(wchar_t *, const wchar_t *, size_t) const throw();
    protected:
        virtual ~std::__cxx11::collate<wchar_t>();
        virtual int do_compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        virtual string_type do_transform(const wchar_t *__lo, const wchar_t *__hi) const;
        virtual long do_hash(const wchar_t *__lo, const wchar_t *__hi) const;
    };
    class collate_byname : public collate<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit collate_byname(const char *__s, size_t __refs);
    protected:
        virtual ~std::__cxx11::collate_byname<wchar_t>();
    };
}
namespace std {
    struct __cow_string {
        union {
            const char *_M_p;
            char _M_bytes[8];
        };
        __cow_string();
        __cow_string(const std::string &);
        __cow_string(const char *, size_t);
        __cow_string(const std::__cow_string &) throw();
        std::__cow_string &operator=(const std::__cow_string &) throw();
        ~std::__cow_string();
    };
    typedef basic_string<char> __sso_string;
    class logic_error : public std::exception {
        std::__cow_string _M_msg;
    public:
        explicit logic_error(const string &__arg);
        logic_error(const std::logic_error &) throw();
        std::logic_error &operator=(const std::logic_error &) throw();
        virtual ~std::logic_error() throw();
        virtual const char *what() const throw();
    };
    class domain_error : public std::logic_error {
    public:
        explicit domain_error(const string &__arg);
        virtual ~std::domain_error() throw();
    };
    class invalid_argument : public std::logic_error {
    public:
        explicit invalid_argument(const string &__arg);
        virtual ~std::invalid_argument() throw();
    };
    class length_error : public std::logic_error {
    public:
        explicit length_error(const string &__arg);
        virtual ~std::length_error() throw();
    };
    class out_of_range : public std::logic_error {
    public:
        explicit out_of_range(const string &__arg);
        virtual ~std::out_of_range() throw();
    };
    class runtime_error : public std::exception {
        std::__cow_string _M_msg;
    public:
        explicit runtime_error(const string &__arg);
        runtime_error(const std::runtime_error &) throw();
        std::runtime_error &operator=(const std::runtime_error &) throw();
        virtual ~std::runtime_error() throw();
        virtual const char *what() const throw();
    };
    class range_error : public std::runtime_error {
    public:
        explicit range_error(const string &__arg);
        virtual ~std::range_error() throw();
    };
    class overflow_error : public std::runtime_error {
    public:
        explicit overflow_error(const string &__arg);
        virtual ~std::overflow_error() throw();
    };
    class underflow_error : public std::runtime_error {
    public:
        explicit underflow_error(const string &__arg);
        virtual ~std::underflow_error() throw();
    };
}
namespace std {
    enum _Ios_Fmtflags {
        _S_boolalpha = 1L << 0,
        _S_dec = 1L << 1,
        _S_fixed = 1L << 2,
        _S_hex = 1L << 3,
        _S_internal = 1L << 4,
        _S_left = 1L << 5,
        _S_oct = 1L << 6,
        _S_right = 1L << 7,
        _S_scientific = 1L << 8,
        _S_showbase = 1L << 9,
        _S_showpoint = 1L << 10,
        _S_showpos = 1L << 11,
        _S_skipws = 1L << 12,
        _S_unitbuf = 1L << 13,
        _S_uppercase = 1L << 14,
        _S_adjustfield = _S_left | _S_right | _S_internal,
        _S_basefield = _S_dec | _S_oct | _S_hex,
        _S_floatfield = _S_scientific | _S_fixed,
        _S_ios_fmtflags_end = 1L << 16,
        _S_ios_fmtflags_max = 2147483647,
        _S_ios_fmtflags_min = ~2147483647
    };
    inline std::_Ios_Fmtflags operator&(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b));
    }


    inline std::_Ios_Fmtflags operator|(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b));
    }


    inline std::_Ios_Fmtflags operator^(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b));
    }


    inline std::_Ios_Fmtflags operator~(std::_Ios_Fmtflags __a)     {
        return std::_Ios_Fmtflags(~static_cast<int>(__a));
    }


    inline const std::_Ios_Fmtflags &operator|=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a | __b;
    }


    inline const std::_Ios_Fmtflags &operator&=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a & __b;
    }


    inline const std::_Ios_Fmtflags &operator^=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a ^ __b;
    }


    enum _Ios_Openmode {
        _S_app = 1L << 0,
        _S_ate = 1L << 1,
        _S_bin = 1L << 2,
        _S_in = 1L << 3,
        _S_out = 1L << 4,
        _S_trunc = 1L << 5,
        _S_ios_openmode_end = 1L << 16,
        _S_ios_openmode_max = 2147483647,
        _S_ios_openmode_min = ~2147483647
    };
    inline std::_Ios_Openmode operator&(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b));
    }


    inline std::_Ios_Openmode operator|(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b));
    }


    inline std::_Ios_Openmode operator^(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b));
    }


    inline std::_Ios_Openmode operator~(std::_Ios_Openmode __a)     {
        return std::_Ios_Openmode(~static_cast<int>(__a));
    }


    inline const std::_Ios_Openmode &operator|=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a | __b;
    }


    inline const std::_Ios_Openmode &operator&=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a & __b;
    }


    inline const std::_Ios_Openmode &operator^=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a ^ __b;
    }


    enum _Ios_Iostate {
        _S_goodbit = 0,
        _S_badbit = 1L << 0,
        _S_eofbit = 1L << 1,
        _S_failbit = 1L << 2,
        _S_ios_iostate_end = 1L << 16,
        _S_ios_iostate_max = 2147483647,
        _S_ios_iostate_min = ~2147483647
    };
    inline std::_Ios_Iostate operator&(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b));
    }


    inline std::_Ios_Iostate operator|(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b));
    }


    inline std::_Ios_Iostate operator^(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b));
    }


    inline std::_Ios_Iostate operator~(std::_Ios_Iostate __a)     {
        return std::_Ios_Iostate(~static_cast<int>(__a));
    }


    inline const std::_Ios_Iostate &operator|=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a | __b;
    }


    inline const std::_Ios_Iostate &operator&=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a & __b;
    }


    inline const std::_Ios_Iostate &operator^=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a ^ __b;
    }


    enum _Ios_Seekdir {
        _S_beg = 0,
        _S_cur = 1,
        _S_end = 2,
        _S_ios_seekdir_end = 1L << 16
    };
    class ios_base {
        struct system_error : std::runtime_error {
            struct error_code {
                error_code()                 {
                }


            private:
                int _M_value;
                const void *_M_cat;
            };
            struct error_code _M_code;
        };
    public:
        class __attribute__((abi_tag("cxx11"))) failure : public std::ios_base::system_error {
        public:
            explicit failure(const string &__str);
            virtual ~std::ios_base::failure() throw();
            virtual const char *what() const throw();
        };
        typedef std::_Ios_Fmtflags fmtflags;
        static const fmtflags boolalpha = _S_boolalpha;
        static const fmtflags dec = _S_dec;
        static const fmtflags fixed = _S_fixed;
        static const fmtflags hex = _S_hex;
        static const fmtflags internal = _S_internal;
        static const fmtflags left = _S_left;
        static const fmtflags oct = _S_oct;
        static const fmtflags right = _S_right;
        static const fmtflags scientific = _S_scientific;
        static const fmtflags showbase = _S_showbase;
        static const fmtflags showpoint = _S_showpoint;
        static const fmtflags showpos = _S_showpos;
        static const fmtflags skipws = _S_skipws;
        static const fmtflags unitbuf = _S_unitbuf;
        static const fmtflags uppercase = _S_uppercase;
        static const fmtflags adjustfield = _S_adjustfield;
        static const fmtflags basefield = _S_basefield;
        static const fmtflags floatfield = _S_floatfield;
        typedef std::_Ios_Iostate iostate;
        static const iostate badbit = _S_badbit;
        static const iostate eofbit = _S_eofbit;
        static const iostate failbit = _S_failbit;
        static const iostate goodbit = _S_goodbit;
        typedef std::_Ios_Openmode openmode;
        static const openmode app = _S_app;
        static const openmode ate = _S_ate;
        static const openmode binary = _S_bin;
        static const openmode in = _S_in;
        static const openmode out = _S_out;
        static const openmode trunc = _S_trunc;
        typedef std::_Ios_Seekdir seekdir;
        static const seekdir beg = _S_beg;
        static const seekdir cur = _S_cur;
        static const seekdir end = _S_end;
        typedef int io_state;
        typedef int open_mode;
        typedef int seek_dir;
        typedef std::streampos streampos;
        typedef std::streamoff streamoff;
        enum event {
            erase_event,
            imbue_event,
            copyfmt_event
        };
        typedef void (*event_callback)(std::ios_base::event, std::ios_base &, int);
        void register_callback(event_callback __fn, int __index);
    protected:
        streamsize _M_precision;
        streamsize _M_width;
        fmtflags _M_flags;
        iostate _M_exception;
        iostate _M_streambuf_state;
        struct _Callback_list {
            std::ios_base::_Callback_list *_M_next;
            ios_base::event_callback _M_fn;
            int _M_index;
            _Atomic_word _M_refcount;
            _Callback_list(ios_base::event_callback __fn, int __index, std::ios_base::_Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0)             {
            }


            void _M_add_reference()             {
                __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
            }


            int _M_remove_reference()             {
                ;
                int __res = __gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1);
                if (__res == 0) {
                    ;
                }
                return __res;
            }


        };
        std::ios_base::_Callback_list *_M_callbacks;
        void _M_call_callbacks(std::ios_base::event __ev) throw();
        void _M_dispose_callbacks() throw();
        struct _Words {
            void *_M_pword;
            long _M_iword;
            _Words() : _M_pword(0), _M_iword(0)             {
            }


        };
        std::ios_base::_Words _M_word_zero;
        enum  {
            _S_local_word_size = 8
        };
        std::ios_base::_Words _M_local_word[8];
        int _M_word_size;
        std::ios_base::_Words *_M_word;
        std::ios_base::_Words &_M_grow_words(int __index, bool __iword);
        std::locale _M_ios_locale;
        void _M_init() throw();
    public:
        class Init {
            friend  class ios_base;
        public:
            Init();
            ~std::ios_base::Init();
        private:
            static _Atomic_word _S_refcount;
            static bool _S_synced_with_stdio;
        };
        fmtflags flags() const         {
            return this->_M_flags;
        }


        fmtflags flags(fmtflags __fmtfl)         {
            fmtflags __old = this->_M_flags;
            this->_M_flags = __fmtfl;
            return __old;
        }


        fmtflags setf(fmtflags __fmtfl)         {
            fmtflags __old = this->_M_flags;
            this->_M_flags |= __fmtfl;
            return __old;
        }


        fmtflags setf(fmtflags __fmtfl, fmtflags __mask)         {
            fmtflags __old = this->_M_flags;
            this->_M_flags &= ~ __mask;
            this->_M_flags |= (__fmtfl & __mask);
            return __old;
        }


        void unsetf(fmtflags __mask)         {
            this->_M_flags &= ~ __mask;
        }


        streamsize precision() const         {
            return this->_M_precision;
        }


        streamsize precision(streamsize __prec)         {
            streamsize __old = this->_M_precision;
            this->_M_precision = __prec;
            return __old;
        }


        streamsize width() const         {
            return this->_M_width;
        }


        streamsize width(streamsize __wide)         {
            streamsize __old = this->_M_width;
            this->_M_width = __wide;
            return __old;
        }


        static bool sync_with_stdio(bool __sync = true);
        std::locale imbue(const std::locale &__loc) throw();
        std::locale getloc() const         {
            return this->_M_ios_locale;
        }


        const std::locale &_M_getloc() const         {
            return this->_M_ios_locale;
        }


        static int xalloc() throw();
        long &iword(int __ix)         {
            std::ios_base::_Words &__word = (__ix < this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, true);
            return __word._M_iword;
        }


        void *&pword(int __ix)         {
            std::ios_base::_Words &__word = (__ix < this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, false);
            return __word._M_pword;
        }


        virtual ~std::ios_base();
    protected:
        ios_base() throw();
    private:
        ios_base(const std::ios_base &);
        std::ios_base &operator=(const std::ios_base &);
    };
    inline std::ios_base &boolalpha(std::ios_base &__base)     {
        __base.setf(ios_base::boolalpha);
        return __base;
    }


    inline std::ios_base &noboolalpha(std::ios_base &__base)     {
        __base.unsetf(ios_base::boolalpha);
        return __base;
    }


    inline std::ios_base &showbase(std::ios_base &__base)     {
        __base.setf(ios_base::showbase);
        return __base;
    }


    inline std::ios_base &noshowbase(std::ios_base &__base)     {
        __base.unsetf(ios_base::showbase);
        return __base;
    }


    inline std::ios_base &showpoint(std::ios_base &__base)     {
        __base.setf(ios_base::showpoint);
        return __base;
    }


    inline std::ios_base &noshowpoint(std::ios_base &__base)     {
        __base.unsetf(ios_base::showpoint);
        return __base;
    }


    inline std::ios_base &showpos(std::ios_base &__base)     {
        __base.setf(ios_base::showpos);
        return __base;
    }


    inline std::ios_base &noshowpos(std::ios_base &__base)     {
        __base.unsetf(ios_base::showpos);
        return __base;
    }


    inline std::ios_base &skipws(std::ios_base &__base)     {
        __base.setf(ios_base::skipws);
        return __base;
    }


    inline std::ios_base &noskipws(std::ios_base &__base)     {
        __base.unsetf(ios_base::skipws);
        return __base;
    }


    inline std::ios_base &uppercase(std::ios_base &__base)     {
        __base.setf(ios_base::uppercase);
        return __base;
    }


    inline std::ios_base &nouppercase(std::ios_base &__base)     {
        __base.unsetf(ios_base::uppercase);
        return __base;
    }


    inline std::ios_base &unitbuf(std::ios_base &__base)     {
        __base.setf(ios_base::unitbuf);
        return __base;
    }


    inline std::ios_base &nounitbuf(std::ios_base &__base)     {
        __base.unsetf(ios_base::unitbuf);
        return __base;
    }


    inline std::ios_base &internal(std::ios_base &__base)     {
        __base.setf(ios_base::internal, ios_base::adjustfield);
        return __base;
    }


    inline std::ios_base &left(std::ios_base &__base)     {
        __base.setf(ios_base::left, ios_base::adjustfield);
        return __base;
    }


    inline std::ios_base &right(std::ios_base &__base)     {
        __base.setf(ios_base::right, ios_base::adjustfield);
        return __base;
    }


    inline std::ios_base &dec(std::ios_base &__base)     {
        __base.setf(ios_base::dec, ios_base::basefield);
        return __base;
    }


    inline std::ios_base &hex(std::ios_base &__base)     {
        __base.setf(ios_base::hex, ios_base::basefield);
        return __base;
    }


    inline std::ios_base &oct(std::ios_base &__base)     {
        __base.setf(ios_base::oct, ios_base::basefield);
        return __base;
    }


    inline std::ios_base &fixed(std::ios_base &__base)     {
        __base.setf(ios_base::fixed, ios_base::floatfield);
        return __base;
    }


    inline std::ios_base &scientific(std::ios_base &__base)     {
        __base.setf(ios_base::scientific, ios_base::floatfield);
        return __base;
    }


}
namespace std {
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> streamsize __copy_streambufs_eof(std::basic_streambuf<char> *, std::basic_streambuf<char> *, bool &)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> streamsize __copy_streambufs_eof(std::basic_streambuf<wchar_t> *, std::basic_streambuf<wchar_t> *, bool &)template <typename _CharT, typename _Traits> streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_streambuf {
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<char_type, traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend streamsize __copy_streambufs_eof(std::basic_streambuf<char> *, std::basic_streambuf<char> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>> basic_istream<char> &operator>>(basic_istream<char> &__in, char *__s)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, wchar_t *__s)template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &operator>>(basic_istream<char> &__is, basic_string<char> &__str)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > &__str)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &getline(basic_istream<char> &__in, basic_string<char> &__str, char __delim)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t> &getline(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        char_type *_M_in_beg;
        char_type *_M_in_cur;
        char_type *_M_in_end;
        char_type *_M_out_beg;
        char_type *_M_out_cur;
        char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~std::basic_streambuf<char>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<char> *pubsetbuf(char_type *__s, streamsize __n);
        pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        pos_type pubseekpos(pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        streamsize in_avail();
        int_type snextc();
        int_type sbumpc();
        int_type sgetc();
        streamsize sgetn(char_type *__s, streamsize __n);
        int_type sputbackc(char_type __c);
        int_type sungetc();
        int_type sputc(char_type __c);
        streamsize sputn(const char_type *__s, streamsize __n);
    protected:
        basic_streambuf();
        char_type *eback() const;
        char_type *gptr() const;
        char_type *egptr() const;
        void gbump(int __n);
        void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend);
        char_type *pbase() const;
        char_type *pptr() const;
        char_type *epptr() const;
        void pbump(int __n);
        void setp(char_type *__pbeg, char_type *__pend);
        virtual void imbue(const std::locale &__loc);
        virtual basic_streambuf<char_type, std::char_traits<char> > *setbuf(char_type *, streamsize);
        virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode);
        virtual pos_type seekpos(pos_type, ios_base::openmode);
        virtual int sync();
        virtual streamsize showmanyc();
        virtual streamsize xsgetn(char_type *__s, streamsize __n);
        virtual int_type underflow();
        virtual int_type uflow();
        virtual int_type pbackfail(int_type __c);
        virtual streamsize xsputn(const char_type *__s, streamsize __n);
        virtual int_type overflow(int_type __c);
    public:
        void stossc();
        void __safe_gbump(streamsize __n);
        void __safe_pbump(streamsize __n);
    private:
        basic_streambuf(const std::basic_streambuf<char> &);
        std::basic_streambuf<char> &operator=(const std::basic_streambuf<char> &);
    }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_streambuf {
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<char_type, traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend streamsize __copy_streambufs_eof(std::basic_streambuf<wchar_t> *, std::basic_streambuf<wchar_t> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>> basic_istream<char> &operator>>(basic_istream<char> &__in, char *__s)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, wchar_t *__s)template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &operator>>(basic_istream<char> &__is, basic_string<char> &__str)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > &__str)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &getline(basic_istream<char> &__in, basic_string<char> &__str, char __delim)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t> &getline(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        char_type *_M_in_beg;
        char_type *_M_in_cur;
        char_type *_M_in_end;
        char_type *_M_out_beg;
        char_type *_M_out_cur;
        char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~std::basic_streambuf<wchar_t>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<wchar_t> *pubsetbuf(char_type *__s, streamsize __n);
        pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        pos_type pubseekpos(pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        streamsize in_avail();
        int_type snextc();
        int_type sbumpc();
        int_type sgetc();
        streamsize sgetn(char_type *__s, streamsize __n);
        int_type sputbackc(char_type __c);
        int_type sungetc();
        int_type sputc(char_type __c);
        streamsize sputn(const char_type *__s, streamsize __n);
    protected:
        basic_streambuf();
        char_type *eback() const;
        char_type *gptr() const;
        char_type *egptr() const;
        void gbump(int __n);
        void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend);
        char_type *pbase() const;
        char_type *pptr() const;
        char_type *epptr() const;
        void pbump(int __n);
        void setp(char_type *__pbeg, char_type *__pend);
        virtual void imbue(const std::locale &__loc);
        virtual basic_streambuf<char_type, std::char_traits<wchar_t> > *setbuf(char_type *, streamsize);
        virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode);
        virtual pos_type seekpos(pos_type, ios_base::openmode);
        virtual int sync();
        virtual streamsize showmanyc();
        virtual streamsize xsgetn(char_type *__s, streamsize __n);
        virtual int_type underflow();
        virtual int_type uflow();
        virtual int_type pbackfail(int_type __c);
        virtual streamsize xsputn(const char_type *__s, streamsize __n);
        virtual int_type overflow(int_type __c);
    public:
        void stossc();
        void __safe_gbump(streamsize __n);
        void __safe_pbump(streamsize __n);
    private:
        basic_streambuf(const std::basic_streambuf<wchar_t> &);
        std::basic_streambuf<wchar_t> &operator=(const std::basic_streambuf<wchar_t> &);
    }
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<char_type, traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        char_type *_M_in_beg;
        char_type *_M_in_cur;
        char_type *_M_in_end;
        char_type *_M_out_beg;
        char_type *_M_out_cur;
        char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<_CharT, _Traits>()         {
        }


        std::locale pubimbue(const std::locale &__loc)         {
            std::locale __tmp(this->getloc());
            this->imbue(__loc);
            this->_M_buf_locale = __loc;
            return __tmp;
        }


        std::locale getloc() const         {
            return this->_M_buf_locale;
        }


        basic_streambuf<_CharT, _Traits> *pubsetbuf(char_type *__s, streamsize __n)         {
            return this->setbuf(__s, __n);
        }


        pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = ios_base::in | ios_base::out)         {
            return this->seekoff(__off, __way, __mode);
        }


        pos_type pubseekpos(pos_type __sp, ios_base::openmode __mode = ios_base::in | ios_base::out)         {
            return this->seekpos(__sp, __mode);
        }


        int pubsync()         {
            return this->sync();
        }


        streamsize in_avail()         {
            const streamsize __ret = this->egptr() - this->gptr();
            return __ret ? __ret : this->showmanyc();
        }


        int_type snextc()         {
            int_type __ret = traits_type::eof();
            if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true))
                __ret = this->sgetc();
            return __ret;
        }


        int_type sbumpc()         {
            int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true)) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            } else
                __ret = this->uflow();
            return __ret;
        }


        int_type sgetc()         {
            int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true))
                __ret = traits_type::to_int_type(*this->gptr());
            else
                __ret = this->underflow();
            return __ret;
        }


        streamsize sgetn(char_type *__s, streamsize __n)         {
            return this->xsgetn(__s, __n);
        }


        int_type sputbackc(char_type __c)         {
            int_type __ret;
            const bool __testpos = this->eback() < this->gptr();
            if (__builtin_expect(!__testpos || !traits_type::eq(__c, this->gptr()[-1]), false))
                __ret = this->pbackfail(traits_type::to_int_type(__c));
            else {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            }
            return __ret;
        }


        int_type sungetc()         {
            int_type __ret;
            if (__builtin_expect(this->eback() < this->gptr(), true)) {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            } else
                __ret = this->pbackfail();
            return __ret;
        }


        int_type sputc(char_type __c)         {
            int_type __ret;
            if (__builtin_expect(this->pptr() < this->epptr(), true)) {
                *this->pptr() = __c;
                this->pbump(1);
                __ret = traits_type::to_int_type(__c);
            } else
                __ret = this->overflow(traits_type::to_int_type(__c));
            return __ret;
        }


        streamsize sputn(const char_type *__s, streamsize __n)         {
            return this->xsputn(__s, __n);
        }


    protected:
        basic_streambuf<_CharT, _Traits>() : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(std::locale())         {
        }


        char_type *eback() const         {
            return this->_M_in_beg;
        }


        char_type *gptr() const         {
            return this->_M_in_cur;
        }


        char_type *egptr() const         {
            return this->_M_in_end;
        }


        void gbump(int __n)         {
            this->_M_in_cur += __n;
        }


        void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend)         {
            this->_M_in_beg = __gbeg;
            this->_M_in_cur = __gnext;
            this->_M_in_end = __gend;
        }


        char_type *pbase() const         {
            return this->_M_out_beg;
        }


        char_type *pptr() const         {
            return this->_M_out_cur;
        }


        char_type *epptr() const         {
            return this->_M_out_end;
        }


        void pbump(int __n)         {
            this->_M_out_cur += __n;
        }


        void setp(char_type *__pbeg, char_type *__pend)         {
            this->_M_out_beg = this->_M_out_cur = __pbeg;
            this->_M_out_end = __pend;
        }


        virtual void imbue(const std::locale &__loc)         {
        }


        virtual basic_streambuf<char_type, _Traits> *setbuf(char_type *, streamsize)         {
            return this;
        }


        virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out)         {
            return pos_type(off_type(-1));
        }


        virtual pos_type seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out)         {
            return pos_type(off_type(-1));
        }


        virtual int sync()         {
            return 0;
        }


        virtual streamsize showmanyc()         {
            return 0;
        }


        virtual streamsize xsgetn(char_type *__s, streamsize __n);
        virtual int_type underflow()         {
            return traits_type::eof();
        }


        virtual int_type uflow()         {
            int_type __ret = traits_type::eof();
            const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
            if (!__testeof) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            }
            return __ret;
        }


        virtual int_type pbackfail(int_type __c = traits_type::eof())         {
            return traits_type::eof();
        }


        virtual streamsize xsputn(const char_type *__s, streamsize __n);
        virtual int_type overflow(int_type __c = traits_type::eof())         {
            return traits_type::eof();
        }


    public:
        void stossc()         {
            if (this->gptr() < this->egptr())
                this->gbump(1);
            else
                this->uflow();
        }


        void __safe_gbump(streamsize __n)         {
            this->_M_in_cur += __n;
        }


        void __safe_pbump(streamsize __n)         {
            this->_M_out_cur += __n;
        }


    private:
        basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &);
        basic_streambuf<_CharT, _Traits> &operator=(const basic_streambuf<_CharT, _Traits> &);
    };
    streamsize __copy_streambufs_eof(basic_streambuf<char> *__sbin, basic_streambuf<char> *__sbout, bool &__ineof);
    streamsize __copy_streambufs_eof(basic_streambuf<wchar_t> *__sbin, basic_streambuf<wchar_t> *__sbout, bool &__ineof);
}
namespace std {
    streamsize xsgetn(char_type *__s, streamsize __n)     {
        streamsize __ret = 0;
        while (__ret < __n)
            {
                const streamsize __buf_len = this->egptr() - this->gptr();
                if (__buf_len) {
                    const streamsize __remaining = __n - __ret;
                    const streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(__s, this->gptr(), __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_gbump(__len);
                }
                if (__ret < __n) {
                    const int_type __c = this->uflow();
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        traits_type::assign(*__s++, traits_type::to_char_type(__c));
                        ++__ret;
                    } else
                        break;
                }
            }
        return __ret;
    }


    streamsize xsputn(const char_type *__s, streamsize __n)     {
        streamsize __ret = 0;
        while (__ret < __n)
            {
                const streamsize __buf_len = this->epptr() - this->pptr();
                if (__buf_len) {
                    const streamsize __remaining = __n - __ret;
                    const streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(this->pptr(), __s, __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_pbump(__len);
                }
                if (__ret < __n) {
                    int_type __c = this->overflow(traits_type::to_int_type(*__s));
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        ++__ret;
                        ++__s;
                    } else
                        break;
                }
            }
        return __ret;
    }


    template <typename _CharT = char, typename _Traits = std::char_traits<char>> streamsize __copy_streambufs_eof(std::basic_streambuf<char> *, std::basic_streambuf<char> *, bool &)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> streamsize __copy_streambufs_eof(std::basic_streambuf<wchar_t> *, std::basic_streambuf<wchar_t> *, bool &)template <typename _CharT, typename _Traits> streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof)     {
        streamsize __ret = 0;
        __ineof = true;
        typename _Traits::int_type __c = __sbin->sgetc();
        while (!_Traits::eq_int_type(__c, _Traits::eof()))
            {
                __c = __sbout->sputc(_Traits::to_char_type(__c));
                if (_Traits::eq_int_type(__c, _Traits::eof())) {
                    __ineof = false;
                    break;
                }
                ++__ret;
                __c = __sbin->snextc();
            }
        return __ret;
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> inline streamsize __copy_streambufs(basic_streambuf<char, std::char_traits<char> > *__sbin, basic_streambuf<char, std::char_traits<char> > *__sbout)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> inline streamsize __copy_streambufs(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sbin, basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sbout)template <typename _CharT, typename _Traits> inline streamsize __copy_streambufs(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout)     {
        bool __ineof;
        return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }

;
    class basic_streambuf {
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<char_type, traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend streamsize __copy_streambufs_eof(std::basic_streambuf<char> *, std::basic_streambuf<char> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>> basic_istream<char> &operator>>(basic_istream<char> &__in, char *__s)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, wchar_t *__s)template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &operator>>(basic_istream<char> &__is, basic_string<char> &__str)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > &__str)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &getline(basic_istream<char> &__in, basic_string<char> &__str, char __delim)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t> &getline(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        char_type *_M_in_beg;
        char_type *_M_in_cur;
        char_type *_M_in_end;
        char_type *_M_out_beg;
        char_type *_M_out_cur;
        char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~std::basic_streambuf<char>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<char> *pubsetbuf(char_type *__s, streamsize __n);
        pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        pos_type pubseekpos(pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        streamsize in_avail();
        int_type snextc();
        int_type sbumpc();
        int_type sgetc();
        streamsize sgetn(char_type *__s, streamsize __n);
        int_type sputbackc(char_type __c);
        int_type sungetc();
        int_type sputc(char_type __c);
        streamsize sputn(const char_type *__s, streamsize __n);
    protected:
        basic_streambuf();
        char_type *eback() const;
        char_type *gptr() const;
        char_type *egptr() const;
        void gbump(int __n);
        void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend);
        char_type *pbase() const;
        char_type *pptr() const;
        char_type *epptr() const;
        void pbump(int __n);
        void setp(char_type *__pbeg, char_type *__pend);
        virtual void imbue(const std::locale &__loc);
        virtual basic_streambuf<char_type, std::char_traits<char> > *setbuf(char_type *, streamsize);
        virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode);
        virtual pos_type seekpos(pos_type, ios_base::openmode);
        virtual int sync();
        virtual streamsize showmanyc();
        virtual streamsize xsgetn(char_type *__s, streamsize __n);
        virtual int_type underflow();
        virtual int_type uflow();
        virtual int_type pbackfail(int_type __c);
        virtual streamsize xsputn(const char_type *__s, streamsize __n);
        virtual int_type overflow(int_type __c);
    public:
        void stossc();
        void __safe_gbump(streamsize __n);
        void __safe_pbump(streamsize __n);
    private:
        basic_streambuf(const std::basic_streambuf<char> &);
        std::basic_streambuf<char> &operator=(const std::basic_streambuf<char> &);
    };
    class basic_streambuf {
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<char_type, traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend streamsize __copy_streambufs_eof(std::basic_streambuf<wchar_t> *, std::basic_streambuf<wchar_t> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>> basic_istream<char> &operator>>(basic_istream<char> &__in, char *__s)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, wchar_t *__s)template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &operator>>(basic_istream<char> &__is, basic_string<char> &__str)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > &__str)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2 = char, typename _Traits2 = std::char_traits<char>, typename _Alloc = std::allocator<char>> basic_istream<char> &getline(basic_istream<char> &__in, basic_string<char> &__str, char __delim)template <typename _CharT2 = wchar_t, typename _Traits2 = std::char_traits<wchar_t>, typename _Alloc = std::allocator<wchar_t>> basic_istream<wchar_t> &getline(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim)template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        char_type *_M_in_beg;
        char_type *_M_in_cur;
        char_type *_M_in_end;
        char_type *_M_out_beg;
        char_type *_M_out_cur;
        char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~std::basic_streambuf<wchar_t>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<wchar_t> *pubsetbuf(char_type *__s, streamsize __n);
        pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        pos_type pubseekpos(pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        streamsize in_avail();
        int_type snextc();
        int_type sbumpc();
        int_type sgetc();
        streamsize sgetn(char_type *__s, streamsize __n);
        int_type sputbackc(char_type __c);
        int_type sungetc();
        int_type sputc(char_type __c);
        streamsize sputn(const char_type *__s, streamsize __n);
    protected:
        basic_streambuf();
        char_type *eback() const;
        char_type *gptr() const;
        char_type *egptr() const;
        void gbump(int __n);
        void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend);
        char_type *pbase() const;
        char_type *pptr() const;
        char_type *epptr() const;
        void pbump(int __n);
        void setp(char_type *__pbeg, char_type *__pend);
        virtual void imbue(const std::locale &__loc);
        virtual basic_streambuf<char_type, std::char_traits<wchar_t> > *setbuf(char_type *, streamsize);
        virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode);
        virtual pos_type seekpos(pos_type, ios_base::openmode);
        virtual int sync();
        virtual streamsize showmanyc();
        virtual streamsize xsgetn(char_type *__s, streamsize __n);
        virtual int_type underflow();
        virtual int_type uflow();
        virtual int_type pbackfail(int_type __c);
        virtual streamsize xsputn(const char_type *__s, streamsize __n);
        virtual int_type overflow(int_type __c);
    public:
        void stossc();
        void __safe_gbump(streamsize __n);
        void __safe_pbump(streamsize __n);
    private:
        basic_streambuf(const std::basic_streambuf<wchar_t> &);
        std::basic_streambuf<wchar_t> &operator=(const std::basic_streambuf<wchar_t> &);
    };
}
typedef unsigned long wctype_t;
enum  {
    __ISwupper = 0,
    __ISwlower = 1,
    __ISwalpha = 2,
    __ISwdigit = 3,
    __ISwxdigit = 4,
    __ISwspace = 5,
    __ISwprint = 6,
    __ISwgraph = 7,
    __ISwblank = 8,
    __ISwcntrl = 9,
    __ISwpunct = 10,
    __ISwalnum = 11,
    _ISwupper = ((__ISwupper) < 8 ? (int)((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int)((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int)((1UL << (__ISwupper)) >> 8) : (int)((1UL << (__ISwupper)) >> 24)))),
    _ISwlower = ((__ISwlower) < 8 ? (int)((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int)((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int)((1UL << (__ISwlower)) >> 8) : (int)((1UL << (__ISwlower)) >> 24)))),
    _ISwalpha = ((__ISwalpha) < 8 ? (int)((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int)((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int)((1UL << (__ISwalpha)) >> 8) : (int)((1UL << (__ISwalpha)) >> 24)))),
    _ISwdigit = ((__ISwdigit) < 8 ? (int)((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int)((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int)((1UL << (__ISwdigit)) >> 8) : (int)((1UL << (__ISwdigit)) >> 24)))),
    _ISwxdigit = ((__ISwxdigit) < 8 ? (int)((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int)((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int)((1UL << (__ISwxdigit)) >> 8) : (int)((1UL << (__ISwxdigit)) >> 24)))),
    _ISwspace = ((__ISwspace) < 8 ? (int)((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int)((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int)((1UL << (__ISwspace)) >> 8) : (int)((1UL << (__ISwspace)) >> 24)))),
    _ISwprint = ((__ISwprint) < 8 ? (int)((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int)((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int)((1UL << (__ISwprint)) >> 8) : (int)((1UL << (__ISwprint)) >> 24)))),
    _ISwgraph = ((__ISwgraph) < 8 ? (int)((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int)((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int)((1UL << (__ISwgraph)) >> 8) : (int)((1UL << (__ISwgraph)) >> 24)))),
    _ISwblank = ((__ISwblank) < 8 ? (int)((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int)((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int)((1UL << (__ISwblank)) >> 8) : (int)((1UL << (__ISwblank)) >> 24)))),
    _ISwcntrl = ((__ISwcntrl) < 8 ? (int)((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int)((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int)((1UL << (__ISwcntrl)) >> 8) : (int)((1UL << (__ISwcntrl)) >> 24)))),
    _ISwpunct = ((__ISwpunct) < 8 ? (int)((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int)((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int)((1UL << (__ISwpunct)) >> 8) : (int)((1UL << (__ISwpunct)) >> 24)))),
    _ISwalnum = ((__ISwalnum) < 8 ? (int)((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int)((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int)((1UL << (__ISwalnum)) >> 8) : (int)((1UL << (__ISwalnum)) >> 24))))
};
extern "C" {
    extern int iswalnum(wint_t __wc) throw();
    extern int iswalpha(wint_t __wc) throw();
    extern int iswcntrl(wint_t __wc) throw();
    extern int iswdigit(wint_t __wc) throw();
    extern int iswgraph(wint_t __wc) throw();
    extern int iswlower(wint_t __wc) throw();
    extern int iswprint(wint_t __wc) throw();
    extern int iswpunct(wint_t __wc) throw();
    extern int iswspace(wint_t __wc) throw();
    extern int iswupper(wint_t __wc) throw();
    extern int iswxdigit(wint_t __wc) throw();
    extern int iswblank(wint_t __wc) throw();
    extern wctype_t wctype(const char *__property) throw();
    extern int iswctype(wint_t __wc, wctype_t __desc) throw();
    typedef const __int32_t *wctrans_t;
    extern wint_t towlower(wint_t __wc) throw();
    extern wint_t towupper(wint_t __wc) throw();
}
extern "C" {
    extern wctrans_t wctrans(const char *__property) throw();
    extern wint_t towctrans(wint_t __wc, wctrans_t __desc) throw();
    extern int iswalnum_l(wint_t __wc, __locale_t __locale) throw();
    extern int iswalpha_l(wint_t __wc, __locale_t __locale) throw();
    extern int iswcntrl_l(wint_t __wc, __locale_t __locale) throw();
    extern int iswdigit_l(wint_t __wc, __locale_t __locale) throw();
    extern int iswgraph_l(wint_t __wc, __locale_t __locale) throw();
    extern int iswlower_l(wint_t __wc, __locale_t __locale) throw();
    extern int iswprint_l(wint_t __wc, __locale_t __locale) throw();
    extern int iswpunct_l(wint_t __wc, __locale_t __locale) throw();
    extern int iswspace_l(wint_t __wc, __locale_t __locale) throw();
    extern int iswupper_l(wint_t __wc, __locale_t __locale) throw();
    extern int iswxdigit_l(wint_t __wc, __locale_t __locale) throw();
    extern int iswblank_l(wint_t __wc, __locale_t __locale) throw();
    extern wctype_t wctype_l(const char *__property, __locale_t __locale) throw();
    extern int iswctype_l(wint_t __wc, wctype_t __desc, __locale_t __locale) throw();
    extern wint_t towlower_l(wint_t __wc, __locale_t __locale) throw();
    extern wint_t towupper_l(wint_t __wc, __locale_t __locale) throw();
    extern wctrans_t wctrans_l(const char *__property, __locale_t __locale) throw();
    extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc, __locale_t __locale) throw();
}
namespace std {
    using ::wctrans_t;
    using ::wctype_t;
    using ::wint_t;
    using ::iswalnum;
    using ::iswalpha;
    using ::iswblank;
    using ::iswcntrl;
    using ::iswctype;
    using ::iswdigit;
    using ::iswgraph;
    using ::iswlower;
    using ::iswprint;
    using ::iswpunct;
    using ::iswspace;
    using ::iswupper;
    using ::iswxdigit;
    using ::towctrans;
    using ::towlower;
    using ::towupper;
    using ::wctrans;
    using ::wctype;
}
namespace std {
    struct ctype_base {
        typedef const int *__to_type;
        typedef unsigned short mask;
        static const mask upper = _ISupper;
        static const mask lower = _ISlower;
        static const mask alpha = _ISalpha;
        static const mask digit = _ISdigit;
        static const mask xdigit = _ISxdigit;
        static const mask space = _ISspace;
        static const mask print = _ISprint;
        static const mask graph = _ISalpha | _ISdigit | _ISpunct;
        static const mask cntrl = _IScntrl;
        static const mask punct = _ISpunct;
        static const mask alnum = _ISalpha | _ISdigit;
    };
}
namespace std {
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class istreambuf_iterator
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class istreambuf_iterator
template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator : public iterator<std::input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT &> {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename _Traits::int_type int_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_istream<_CharT, _Traits> istream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2> >::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
    private:
        mutable streambuf_type *_M_sbuf;
        mutable int_type _M_c;
    public:
        istreambuf_iterator<_CharT, _Traits>() throw() : _M_sbuf(0), _M_c(traits_type::eof())         {
        }


        istreambuf_iterator<_CharT, _Traits>(istream_type &__s) throw() : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof())         {
        }


        istreambuf_iterator<_CharT, _Traits>(streambuf_type *__s) throw() : _M_sbuf(__s), _M_c(traits_type::eof())         {
        }


        char_type operator*() const         {
            return traits_type::to_char_type(this->_M_get());
        }


        istreambuf_iterator<_CharT, _Traits> &operator++()         {
            ;
            if (this->_M_sbuf) {
                this->_M_sbuf->sbumpc();
                this->_M_c = traits_type::eof();
            }
            return *this;
        }


        istreambuf_iterator<_CharT, _Traits> operator++(int)         {
            ;
            istreambuf_iterator<_CharT, _Traits> __old = *this;
            if (this->_M_sbuf) {
                __old._M_c = this->_M_sbuf->sbumpc();
                this->_M_c = traits_type::eof();
            }
            return __old;
        }


        bool equal(const istreambuf_iterator<_CharT, _Traits> &__b) const         {
            return this->_M_at_eof() == __b._M_at_eof();
        }


    private:
        int_type _M_get() const         {
            const int_type __eof = traits_type::eof();
            int_type __ret = __eof;
            if (this->_M_sbuf) {
                if (!traits_type::eq_int_type(this->_M_c, __eof))
                    __ret = this->_M_c;
                else if (!traits_type::eq_int_type((__ret = this->_M_sbuf->sgetc()), __eof))
                    this->_M_c = __ret;
                else
                    this->_M_sbuf = 0;
            }
            return __ret;
        }


        bool _M_at_eof() const         {
            const int_type __eof = traits_type::eof();
            return traits_type::eq_int_type(this->_M_get(), __eof);
        }


    };
    template <typename _CharT, typename _Traits> inline bool operator==(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b)     {
        return __a.equal(__b);
    }

;
    template <typename _CharT, typename _Traits> inline bool operator!=(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b)     {
        return !__a.equal(__b);
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class ostreambuf_iterator
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class ostreambuf_iterator
template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_ostream<_CharT, _Traits> ostream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2> >::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
    private:
        streambuf_type *_M_sbuf;
        bool _M_failed;
    public:
        ostreambuf_iterator<_CharT, _Traits>(ostream_type &__s) throw() : _M_sbuf(__s.rdbuf()), _M_failed(!this->_M_sbuf)         {
        }


        ostreambuf_iterator<_CharT, _Traits>(streambuf_type *__s) throw() : _M_sbuf(__s), _M_failed(!this->_M_sbuf)         {
        }


        ostreambuf_iterator<_CharT, _Traits> &operator=(_CharT __c)         {
            if (!this->_M_failed && _Traits::eq_int_type(this->_M_sbuf->sputc(__c), _Traits::eof()))
                this->_M_failed = true;
            return *this;
        }


        ostreambuf_iterator<_CharT, _Traits> &operator*()         {
            return *this;
        }


        ostreambuf_iterator<_CharT, _Traits> &operator++(int)         {
            return *this;
        }


        ostreambuf_iterator<_CharT, _Traits> &operator++()         {
            return *this;
        }


        bool failed() const throw()         {
            return this->_M_failed;
        }


        ostreambuf_iterator<_CharT, _Traits> &_M_put(const _CharT *__ws, streamsize __len)         {
            if (__builtin_expect(!this->_M_failed, true) && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
                this->_M_failed = true;
            return *this;
        }


    };
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT> >::__type copy(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, ostreambuf_iterator<_CharT> __result)     {
        if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed) {
            bool __ineof;
            __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
            if (!__ineof)
                __result._M_failed = true;
        }
        return __result;
    }

;
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT> >::__type __copy_move_a2(_CharT *__first, _CharT *__last, ostreambuf_iterator<_CharT> __result)     {
        const streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }

;
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT> >::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ostreambuf_iterator<_CharT> __result)     {
        const streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }

;
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, _CharT *__result)     {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        if (__first._M_sbuf && !__last._M_sbuf) {
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                    const streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        traits_type::copy(__result, __sb->gptr(), __n);
                        __sb->__safe_gbump(__n);
                        __result += __n;
                        __c = __sb->underflow();
                    } else {
                        *__result++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                    }
                }
        }
        return __result;
    }

;
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, istreambuf_iterator<_CharT> >::__type find(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, const _CharT &__val)     {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        if (__first._M_sbuf && !__last._M_sbuf) {
            const int_type __ival = traits_type::to_int_type(__val);
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, traits_type::eof()) && !traits_type::eq_int_type(__c, __ival))
                {
                    streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val);
                        if (__p)
                            __n = __p - __sb->gptr();
                        __sb->__safe_gbump(__n);
                        __c = __sb->sgetc();
                    } else
                        __c = __sb->snextc();
                }
            if (!traits_type::eq_int_type(__c, traits_type::eof()))
                __first._M_c = __c;
            else
                __first._M_sbuf = 0;
        }
        return __first;
    }

;
}
namespace std {
    template <typename _Tp = float> void __convert_to_v(const char *, float &, ios_base::iostate &, const __c_locale &) throw()template <typename _Tp = double> void __convert_to_v(const char *, double &, ios_base::iostate &, const __c_locale &) throw()template <typename _Tp = long double> void __convert_to_v(const char *, long double &, ios_base::iostate &, const __c_locale &) throw()template <typename _Tp> void __convert_to_v(const char *, _Tp &, ios_base::iostate &, const __c_locale &) throw();
    void __convert_to_v(const char *, float &, ios_base::iostate &, const __c_locale &) throw();
    void __convert_to_v(const char *, double &, ios_base::iostate &, const __c_locale &) throw();
    void __convert_to_v(const char *, long double &, ios_base::iostate &, const __c_locale &) throw();
    template <typename _CharT, typename _Traits> struct __pad {
        static void _S_pad(std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, streamsize __newlen, streamsize __oldlen);
    };
    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, size_t __gsize, const _CharT *__first, const _CharT *__last);
    template <typename _CharT> inline ostreambuf_iterator<_CharT> __write(ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len)     {
        __s._M_put(__ws, __len);
        return __s;
    }

;
    template <typename _CharT, typename _OutIter> inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len)     {
        for (int __j = 0; __j < __len; __j++ , ++__s) 
            *__s = __ws[__j];
        return __s;
    }

;
    template <typename _CharT = wchar_t> class __ctype_abstract_base : public locale::facet, public std::ctype_base {
    public:
        typedef wchar_t char_type;
        bool is(mask __m, char_type __c) const;
        const char_type *is(const char_type *__lo, const char_type *__hi, mask *__vec) const;
        const char_type *scan_is(mask __m, const char_type *__lo, const char_type *__hi) const;
        const char_type *scan_not(mask __m, const char_type *__lo, const char_type *__hi) const;
        char_type toupper(char_type __c) const;
        const char_type *toupper(char_type *__lo, const char_type *__hi) const;
        char_type tolower(char_type __c) const;
        const char_type *tolower(char_type *__lo, const char_type *__hi) const;
        char_type widen(char __c) const;
        const char *widen(const char *__lo, const char *__hi, char_type *__to) const;
        char narrow(char_type __c, char __dfault) const;
        const char_type *narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const;
    protected:
        explicit __ctype_abstract_base(size_t __refs);
        virtual ~std::__ctype_abstract_base<wchar_t>();
        virtual bool do_is(mask __m, char_type __c) const = 0;
        virtual const char_type *do_is(const char_type *__lo, const char_type *__hi, mask *__vec) const = 0;
        virtual const char_type *do_scan_is(mask __m, const char_type *__lo, const char_type *__hi) const = 0;
        virtual const char_type *do_scan_not(mask __m, const char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_toupper(char_type __c) const = 0;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_tolower(char_type __c) const = 0;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const = 0;
        virtual char do_narrow(char_type __c, char __dfault) const = 0;
        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const = 0;
    }
template <typename _CharT> class __ctype_abstract_base : public locale::facet, public std::ctype_base {
    public:
        typedef _CharT char_type;
        bool is(mask __m, char_type __c) const         {
            return this->do_is(__m, __c);
        }


        const char_type *is(const char_type *__lo, const char_type *__hi, mask *__vec) const         {
            return this->do_is(__lo, __hi, __vec);
        }


        const char_type *scan_is(mask __m, const char_type *__lo, const char_type *__hi) const         {
            return this->do_scan_is(__m, __lo, __hi);
        }


        const char_type *scan_not(mask __m, const char_type *__lo, const char_type *__hi) const         {
            return this->do_scan_not(__m, __lo, __hi);
        }


        char_type toupper(char_type __c) const         {
            return this->do_toupper(__c);
        }


        const char_type *toupper(char_type *__lo, const char_type *__hi) const         {
            return this->do_toupper(__lo, __hi);
        }


        char_type tolower(char_type __c) const         {
            return this->do_tolower(__c);
        }


        const char_type *tolower(char_type *__lo, const char_type *__hi) const         {
            return this->do_tolower(__lo, __hi);
        }


        char_type widen(char __c) const         {
            return this->do_widen(__c);
        }


        const char *widen(const char *__lo, const char *__hi, char_type *__to) const         {
            return this->do_widen(__lo, __hi, __to);
        }


        char narrow(char_type __c, char __dfault) const         {
            return this->do_narrow(__c, __dfault);
        }


        const char_type *narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const         {
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }


    protected:
        explicit __ctype_abstract_base<_CharT>(size_t __refs = 0) : std::locale::facet(__refs)         {
        }


        virtual ~__ctype_abstract_base<_CharT>()         {
        }


        virtual bool do_is(mask __m, char_type __c) const = 0;
        virtual const char_type *do_is(const char_type *__lo, const char_type *__hi, mask *__vec) const = 0;
        virtual const char_type *do_scan_is(mask __m, const char_type *__lo, const char_type *__hi) const = 0;
        virtual const char_type *do_scan_not(mask __m, const char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_toupper(char_type __c) const = 0;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_tolower(char_type __c) const = 0;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const = 0;
        virtual char do_narrow(char_type __c, char __dfault) const = 0;
        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const = 0;
    };
    template <typename _CharT = char> class ctype : public locale::facet, public std::ctype_base {
    public:
        typedef char char_type;
    protected:
        __c_locale _M_c_locale_ctype;
        bool _M_del;
        __to_type _M_toupper;
        __to_type _M_tolower;
        const mask *_M_table;
        mutable char _M_widen_ok;
        mutable char _M_widen[256];
        mutable char _M_narrow[256];
        mutable char _M_narrow_ok;
    public:
        static locale::id id;
        static const size_t table_size = 1 + static_cast<unsigned char>(-1);
        explicit ctype(const mask *__table = 0, bool __del = false, size_t __refs = 0);
        explicit ctype(__c_locale __cloc, const mask *__table = 0, bool __del = false, size_t __refs = 0);
        inline bool is(mask __m, char __c) const;
        inline const char *is(const char *__lo, const char *__hi, mask *__vec) const;
        inline const char *scan_is(mask __m, const char *__lo, const char *__hi) const;
        inline const char *scan_not(mask __m, const char *__lo, const char *__hi) const;
        char_type toupper(char_type __c) const         {
            return this->do_toupper(__c);
        }


        const char_type *toupper(char_type *__lo, const char_type *__hi) const         {
            return this->do_toupper(__lo, __hi);
        }


        char_type tolower(char_type __c) const         {
            return this->do_tolower(__c);
        }


        const char_type *tolower(char_type *__lo, const char_type *__hi) const         {
            return this->do_tolower(__lo, __hi);
        }


        char_type widen(char __c) const         {
            if (this->_M_widen_ok)
                return this->_M_widen[static_cast<unsigned char>(__c)];
            this->_M_widen_init();
            return this->do_widen(__c);
        }


        const char *widen(const char *__lo, const char *__hi, char_type *__to) const         {
            if (this->_M_widen_ok == 1) {
                __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_widen_ok)
                this->_M_widen_init();
            return this->do_widen(__lo, __hi, __to);
        }


        char narrow(char_type __c, char __dfault) const         {
            if (this->_M_narrow[static_cast<unsigned char>(__c)])
                return this->_M_narrow[static_cast<unsigned char>(__c)];
            const char __t = this->do_narrow(__c, __dfault);
            if (__t != __dfault)
                this->_M_narrow[static_cast<unsigned char>(__c)] = __t;
            return __t;
        }


        const char_type *narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const         {
            if (__builtin_expect(this->_M_narrow_ok == 1, true)) {
                __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_narrow_ok)
                this->_M_narrow_init();
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }


        const mask *table() const throw()         {
            return this->_M_table;
        }


        static const mask *classic_table() throw();
    protected:
        virtual ~std::ctype<char>();
        virtual char_type do_toupper(char_type __c) const;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_tolower(char_type __c) const;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_widen(char __c) const         {
            return __c;
        }


        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const         {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }


        virtual char do_narrow(char_type __c, char __dfault) const         {
            return __c;
        }


        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const         {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }


    private:
        void _M_narrow_init() const;
        void _M_widen_init() const;
    }
template <typename _CharT = wchar_t> class ctype : public __ctype_abstract_base<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef wctype_t __wmask_type;
    protected:
        __c_locale _M_c_locale_ctype;
        bool _M_narrow_ok;
        char _M_narrow[128];
        wint_t _M_widen[256];
        mask _M_bit[16];
        __wmask_type _M_wmask[16];
    public:
        static locale::id id;
        explicit ctype(size_t __refs = 0);
        explicit ctype(__c_locale __cloc, size_t __refs = 0);
    protected:
        __wmask_type _M_convert_to_wmask(const mask __m) const throw();
        virtual ~std::ctype<wchar_t>();
        virtual bool do_is(mask __m, char_type __c) const;
        virtual const char_type *do_is(const char_type *__lo, const char_type *__hi, mask *__vec) const;
        virtual const char_type *do_scan_is(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual const char_type *do_scan_not(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual char_type do_toupper(char_type __c) const;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_tolower(char_type __c) const;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const;
        virtual char do_narrow(char_type __c, char __dfault) const;
        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const;
        void _M_initialize_ctype() throw();
    }
template <typename _CharT> class ctype : public __ctype_abstract_base<_CharT> {
    public:
        typedef _CharT char_type;
        typedef typename __ctype_abstract_base<_CharT>::mask mask;
        static locale::id id;
        explicit ctype<_CharT>(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs)         {
        }


    protected:
        virtual ~ctype<_CharT>();
        virtual bool do_is(mask __m, char_type __c) const;
        virtual const char_type *do_is(const char_type *__lo, const char_type *__hi, mask *__vec) const;
        virtual const char_type *do_scan_is(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual const char_type *do_scan_not(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual char_type do_toupper(char_type __c) const;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_tolower(char_type __c) const;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__dest) const;
        virtual char do_narrow(char_type, char __dfault) const;
        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const;
    };
    locale::id id;
    class ctype : public locale::facet, public std::ctype_base {
    public:
        typedef char char_type;
    protected:
        __c_locale _M_c_locale_ctype;
        bool _M_del;
        __to_type _M_toupper;
        __to_type _M_tolower;
        const mask *_M_table;
        mutable char _M_widen_ok;
        mutable char _M_widen[256];
        mutable char _M_narrow[256];
        mutable char _M_narrow_ok;
    public:
        static locale::id id;
        static const size_t table_size = 1 + static_cast<unsigned char>(-1);
        explicit ctype(const mask *__table = 0, bool __del = false, size_t __refs = 0);
        explicit ctype(__c_locale __cloc, const mask *__table = 0, bool __del = false, size_t __refs = 0);
        inline bool is(mask __m, char __c) const;
        inline const char *is(const char *__lo, const char *__hi, mask *__vec) const;
        inline const char *scan_is(mask __m, const char *__lo, const char *__hi) const;
        inline const char *scan_not(mask __m, const char *__lo, const char *__hi) const;
        char_type toupper(char_type __c) const         {
            return this->do_toupper(__c);
        }


        const char_type *toupper(char_type *__lo, const char_type *__hi) const         {
            return this->do_toupper(__lo, __hi);
        }


        char_type tolower(char_type __c) const         {
            return this->do_tolower(__c);
        }


        const char_type *tolower(char_type *__lo, const char_type *__hi) const         {
            return this->do_tolower(__lo, __hi);
        }


        char_type widen(char __c) const         {
            if (this->_M_widen_ok)
                return this->_M_widen[static_cast<unsigned char>(__c)];
            this->_M_widen_init();
            return this->do_widen(__c);
        }


        const char *widen(const char *__lo, const char *__hi, char_type *__to) const         {
            if (this->_M_widen_ok == 1) {
                __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_widen_ok)
                this->_M_widen_init();
            return this->do_widen(__lo, __hi, __to);
        }


        char narrow(char_type __c, char __dfault) const         {
            if (this->_M_narrow[static_cast<unsigned char>(__c)])
                return this->_M_narrow[static_cast<unsigned char>(__c)];
            const char __t = this->do_narrow(__c, __dfault);
            if (__t != __dfault)
                this->_M_narrow[static_cast<unsigned char>(__c)] = __t;
            return __t;
        }


        const char_type *narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const         {
            if (__builtin_expect(this->_M_narrow_ok == 1, true)) {
                __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_narrow_ok)
                this->_M_narrow_init();
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }


        const mask *table() const throw()         {
            return this->_M_table;
        }


        static const mask *classic_table() throw();
    protected:
        virtual ~std::ctype<char>();
        virtual char_type do_toupper(char_type __c) const;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_tolower(char_type __c) const;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_widen(char __c) const         {
            return __c;
        }


        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const         {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }


        virtual char do_narrow(char_type __c, char __dfault) const         {
            return __c;
        }


        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const         {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }


    private:
        void _M_narrow_init() const;
        void _M_widen_init() const;
    };
    class ctype : public __ctype_abstract_base<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef wctype_t __wmask_type;
    protected:
        __c_locale _M_c_locale_ctype;
        bool _M_narrow_ok;
        char _M_narrow[128];
        wint_t _M_widen[256];
        mask _M_bit[16];
        __wmask_type _M_wmask[16];
    public:
        static locale::id id;
        explicit ctype(size_t __refs = 0);
        explicit ctype(__c_locale __cloc, size_t __refs = 0);
    protected:
        __wmask_type _M_convert_to_wmask(const mask __m) const throw();
        virtual ~std::ctype<wchar_t>();
        virtual bool do_is(mask __m, char_type __c) const;
        virtual const char_type *do_is(const char_type *__lo, const char_type *__hi, mask *__vec) const;
        virtual const char_type *do_scan_is(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual const char_type *do_scan_not(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual char_type do_toupper(char_type __c) const;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_tolower(char_type __c) const;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const;
        virtual char do_narrow(char_type __c, char __dfault) const;
        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const;
        void _M_initialize_ctype() throw();
    };
    template <typename _CharT = char> class ctype_byname
template <typename _CharT = wchar_t> class ctype_byname
template <typename _CharT> class ctype_byname : public ctype<_CharT> {
    public:
        typedef typename ctype<_CharT>::mask mask;
        explicit ctype_byname<_CharT>(const char *__s, size_t __refs = 0);
    protected:
        virtual ~ctype_byname<_CharT>()         {
        }


    };
    class ctype_byname : public ctype<char> {
    public:
        explicit ctype_byname(const char *__s, size_t __refs = 0);
    protected:
        virtual ~std::ctype_byname<char>();
    };
    class ctype_byname : public ctype<wchar_t> {
    public:
        explicit ctype_byname(const char *__s, size_t __refs = 0);
    protected:
        virtual ~std::ctype_byname<wchar_t>();
    };
}
namespace std {
    bool is(mask __m, char __c) const     {
        return this->_M_table[static_cast<unsigned char>(__c)] & __m;
    }


    const char *is(const char *__low, const char *__high, mask *__vec) const     {
        while (__low < __high)
            *__vec++ = this->_M_table[static_cast<unsigned char>(*__low++)];
        return __high;
    }


    const char *scan_is(mask __m, const char *__low, const char *__high) const     {
        while (__low < __high && !(this->_M_table[static_cast<unsigned char>(*__low)] & __m))
            ++__low;
        return __low;
    }


    const char *scan_not(mask __m, const char *__low, const char *__high) const     {
        while (__low < __high && (this->_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
            ++__low;
        return __low;
    }


}
namespace std {
    class __num_base {
    public:
        enum  {
            _S_ominus,
            _S_oplus,
            _S_ox,
            _S_oX,
            _S_odigits,
            _S_odigits_end = _S_odigits + 16,
            _S_oudigits = _S_odigits_end,
            _S_oudigits_end = _S_oudigits + 16,
            _S_oe = _S_odigits + 14,
            _S_oE = _S_oudigits + 14,
            _S_oend = _S_oudigits_end
        };
        static const char *_S_atoms_out;
        static const char *_S_atoms_in;
        enum  {
            _S_iminus,
            _S_iplus,
            _S_ix,
            _S_iX,
            _S_izero,
            _S_ie = _S_izero + 14,
            _S_iE = _S_izero + 20,
            _S_iend = 26
        };
        static void _S_format_float(const std::ios_base &__io, char *__fptr, char __mod) throw();
    };
    template <typename _CharT = char> struct __numpunct_cache
template <typename _CharT = wchar_t> struct __numpunct_cache
template <typename _CharT> struct __numpunct_cache : public locale::facet {
        const char *_M_grouping;
        size_t _M_grouping_size;
        bool _M_use_grouping;
        const _CharT *_M_truename;
        size_t _M_truename_size;
        const _CharT *_M_falsename;
        size_t _M_falsename_size;
        _CharT _M_decimal_point;
        _CharT _M_thousands_sep;
        _CharT _M_atoms_out[36];
        _CharT _M_atoms_in[26];
        bool _M_allocated;
        __numpunct_cache<_CharT>(size_t __refs = 0) : std::locale::facet(__refs), _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false), _M_truename(0), _M_truename_size(0), _M_falsename(0), _M_falsename_size(0), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false)         {
        }


        ~__numpunct_cache<_CharT>();
        void _M_cache(const std::locale &__loc);
    private:
        __numpunct_cache<_CharT> &operator=(const __numpunct_cache<_CharT> &);
        explicit __numpunct_cache<_CharT>(const __numpunct_cache<_CharT> &);
    };
    ~__numpunct_cache<_CharT>()     {
        if (this->_M_allocated) {
            delete [] this->_M_grouping;
            delete [] this->_M_truename;
            delete [] this->_M_falsename;
        }
    }


    inline namespace __cxx11 {
        template <typename _CharT = char> class numpunct : public locale::facet {
        public:
            typedef char char_type;
            typedef basic_string<char> string_type;
            typedef __numpunct_cache<char> __cache_type;
        protected:
            __cache_type *_M_data;
        public:
            static locale::id id;
            explicit numpunct(size_t __refs);
            explicit numpunct(__cache_type *__cache, size_t __refs);
            explicit numpunct(__c_locale __cloc, size_t __refs);
            char_type decimal_point() const;
            char_type thousands_sep() const;
            string grouping() const;
            string_type truename() const;
            string_type falsename() const;
        protected:
            virtual ~std::__cxx11::numpunct<char>();
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_truename() const;
            virtual string_type do_falsename() const;
            void _M_initialize_numpunct(__c_locale __cloc);
        }
template <typename _CharT = wchar_t> class numpunct : public locale::facet {
        public:
            typedef wchar_t char_type;
            typedef basic_string<wchar_t> string_type;
            typedef __numpunct_cache<wchar_t> __cache_type;
        protected:
            __cache_type *_M_data;
        public:
            static locale::id id;
            explicit numpunct(size_t __refs);
            explicit numpunct(__cache_type *__cache, size_t __refs);
            explicit numpunct(__c_locale __cloc, size_t __refs);
            char_type decimal_point() const;
            char_type thousands_sep() const;
            string grouping() const;
            string_type truename() const;
            string_type falsename() const;
        protected:
            virtual ~std::__cxx11::numpunct<wchar_t>();
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_truename() const;
            virtual string_type do_falsename() const;
            void _M_initialize_numpunct(__c_locale __cloc);
        }
template <typename _CharT> class numpunct : public locale::facet {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            typedef __numpunct_cache<_CharT> __cache_type;
        protected:
            __cache_type *_M_data;
        public:
            static locale::id id;
            explicit numpunct<_CharT>(size_t __refs = 0) : std::locale::facet(__refs), _M_data(0)             {
                this->_M_initialize_numpunct();
            }


            explicit numpunct<_CharT>(__cache_type *__cache, size_t __refs = 0) : std::locale::facet(__refs), _M_data(__cache)             {
                this->_M_initialize_numpunct();
            }


            explicit numpunct<_CharT>(__c_locale __cloc, size_t __refs = 0) : std::locale::facet(__refs), _M_data(0)             {
                this->_M_initialize_numpunct(__cloc);
            }


            char_type decimal_point() const             {
                return this->do_decimal_point();
            }


            char_type thousands_sep() const             {
                return this->do_thousands_sep();
            }


            string grouping() const             {
                return this->do_grouping();
            }


            string_type truename() const             {
                return this->do_truename();
            }


            string_type falsename() const             {
                return this->do_falsename();
            }


        protected:
            virtual ~numpunct<_CharT>();
            virtual char_type do_decimal_point() const             {
                return this->_M_data->_M_decimal_point;
            }


            virtual char_type do_thousands_sep() const             {
                return this->_M_data->_M_thousands_sep;
            }


            virtual string do_grouping() const             {
                return this->_M_data->_M_grouping;
            }


            virtual string_type do_truename() const             {
                return this->_M_data->_M_truename;
            }


            virtual string_type do_falsename() const             {
                return this->_M_data->_M_falsename;
            }


            void _M_initialize_numpunct(__c_locale __cloc = 0);
        };
        locale::id id;
        ~std::__cxx11::numpunct<char>();
        void _M_initialize_numpunct(__c_locale __cloc);
        ~std::__cxx11::numpunct<wchar_t>();
        void _M_initialize_numpunct(__c_locale __cloc);
        template <typename _CharT = char> class numpunct_byname : public numpunct<char> {
        public:
            typedef char char_type;
            typedef basic_string<char> string_type;
            explicit numpunct_byname(const char *__s, size_t __refs);
        protected:
            virtual ~std::__cxx11::numpunct_byname<char>();
        }
template <typename _CharT = wchar_t> class numpunct_byname : public numpunct<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef basic_string<wchar_t> string_type;
            explicit numpunct_byname(const char *__s, size_t __refs);
        protected:
            virtual ~std::__cxx11::numpunct_byname<wchar_t>();
        }
template <typename _CharT> class numpunct_byname : public numpunct<_CharT> {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            explicit numpunct_byname<_CharT>(const char *__s, size_t __refs = 0) : numpunct<_CharT>(__refs)             {
                if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                    __c_locale __tmp;
                    this->_S_create_c_locale(__tmp, __s);
                    this->_M_initialize_numpunct(__tmp);
                    this->_S_destroy_c_locale(__tmp);
                }
            }


        protected:
            virtual ~numpunct_byname<_CharT>()             {
            }


        };
    }
    template <typename _CharT = char, typename _InIter = std::istreambuf_iterator<char, std::char_traits<char> >> class num_get : public locale::facet {
    public:
        typedef char char_type;
        typedef std::istreambuf_iterator<char, std::char_traits<char> > iter_type;
        static locale::id id;
        explicit num_get(size_t __refs);
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~std::num_get<char>();
        iter_type _M_extract_float(iter_type, iter_type, std::ios_base &, ios_base::iostate &, string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> iter_type _M_extract_int(iter_type, iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    }
template <typename _CharT = wchar_t, typename _InIter = std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> >> class num_get : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > iter_type;
        static locale::id id;
        explicit num_get(size_t __refs);
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~std::num_get<wchar_t>();
        iter_type _M_extract_float(iter_type, iter_type, std::ios_base &, ios_base::iostate &, string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> iter_type _M_extract_int(iter_type, iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    }
template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _InIter iter_type;
        static locale::id id;
        explicit num_get<_CharT, _InIter>(size_t __refs = 0) : std::locale::facet(__refs)         {
        }


        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }


        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }


        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }


        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }


        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }


        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }


        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }


        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }


        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }


        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }


        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }


    protected:
        virtual ~num_get<_CharT, _InIter>()         {
        }


        iter_type _M_extract_float(iter_type, iter_type, std::ios_base &, ios_base::iostate &, string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> iter_type _M_extract_int(iter_type, iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const         {
            int __ret = -1;
            if (__len <= 10) {
                if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
                    __ret = __c - _CharT2('0');
            } else {
                if (__c >= _CharT2('0') && __c <= _CharT2('9'))
                    __ret = __c - _CharT2('0');
                else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
                    __ret = 10 + (__c - _CharT2('a'));
                else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
                    __ret = 10 + (__c - _CharT2('A'));
            }
            return __ret;
        }

;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const         {
            int __ret = -1;
            const char_type *__q = char_traits<_CharT2>::find(__zero, __len, __c);
            if (__q) {
                __ret = __q - __zero;
                if (__ret > 15)
                    __ret -= 6;
            }
            return __ret;
        }

;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }


        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }


        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }


        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }


        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }


        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }


        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    locale::id id;
    template <typename _CharT = char, typename _OutIter = std::ostreambuf_iterator<char, std::char_traits<char> >> class num_put : public locale::facet {
    public:
        typedef char char_type;
        typedef std::ostreambuf_iterator<char, std::char_traits<char> > iter_type;
        static locale::id id;
        explicit num_put(size_t __refs);
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> iter_type _M_insert_float(iter_type, std::ios_base &__io, char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, size_t __grouping_size, char_type __sep, const char_type *__p, char_type *__new, char_type *__cs, int &__len) const;
        template <typename _ValueT> iter_type _M_insert_int(iter_type, std::ios_base &__io, char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, size_t __grouping_size, char_type __sep, std::ios_base &__io, char_type *__new, char_type *__cs, int &__len) const;
        void _M_pad(char_type __fill, streamsize __w, std::ios_base &__io, char_type *__new, const char_type *__cs, int &__len) const;
        virtual ~std::num_put<char>();
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, long double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, const void *) const;
    }
template <typename _CharT = wchar_t, typename _OutIter = std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> >> class num_put : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > iter_type;
        static locale::id id;
        explicit num_put(size_t __refs);
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> iter_type _M_insert_float(iter_type, std::ios_base &__io, char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, size_t __grouping_size, char_type __sep, const char_type *__p, char_type *__new, char_type *__cs, int &__len) const;
        template <typename _ValueT> iter_type _M_insert_int(iter_type, std::ios_base &__io, char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, size_t __grouping_size, char_type __sep, std::ios_base &__io, char_type *__new, char_type *__cs, int &__len) const;
        void _M_pad(char_type __fill, streamsize __w, std::ios_base &__io, char_type *__new, const char_type *__cs, int &__len) const;
        virtual ~std::num_put<wchar_t>();
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, long double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, const void *) const;
    }
template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _OutIter iter_type;
        static locale::id id;
        explicit num_put<_CharT, _OutIter>(size_t __refs = 0) : std::locale::facet(__refs)         {
        }


        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }


        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }


        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }


        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }


        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }


        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, double __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }


        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long double __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }


        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, const void *__v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }


    protected:
        template <typename _ValueT> iter_type _M_insert_float(iter_type, std::ios_base &__io, char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, size_t __grouping_size, char_type __sep, const char_type *__p, char_type *__new, char_type *__cs, int &__len) const;
        template <typename _ValueT> iter_type _M_insert_int(iter_type, std::ios_base &__io, char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, size_t __grouping_size, char_type __sep, std::ios_base &__io, char_type *__new, char_type *__cs, int &__len) const;
        void _M_pad(char_type __fill, streamsize __w, std::ios_base &__io, char_type *__new, const char_type *__cs, int &__len) const;
        virtual ~num_put<_CharT, _OutIter>()         {
        }


        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }


        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }


        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }


        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }


        virtual iter_type do_put(iter_type, std::ios_base &, char_type, double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, long double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, const void *) const;
    };
    locale::id id;
    template <typename _CharT> inline bool isspace(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
    }

;
    template <typename _CharT> inline bool isprint(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
    }

;
    template <typename _CharT> inline bool iscntrl(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
    }

;
    template <typename _CharT> inline bool isupper(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
    }

;
    template <typename _CharT> inline bool islower(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
    }

;
    template <typename _CharT> inline bool isalpha(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
    }

;
    template <typename _CharT> inline bool isdigit(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
    }

;
    template <typename _CharT> inline bool ispunct(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
    }

;
    template <typename _CharT> inline bool isxdigit(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
    }

;
    template <typename _CharT> inline bool isalnum(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
    }

;
    template <typename _CharT> inline bool isgraph(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
    }

;
    template <typename _CharT> inline _CharT toupper(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).toupper(__c);
    }

;
    template <typename _CharT> inline _CharT tolower(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).tolower(__c);
    }

;
}
namespace std {
    template <typename _Facet> struct __use_cache {
        const _Facet *operator()(const std::locale &__loc) const;
    };
    struct __use_cache {
        const __numpunct_cache<_CharT> *operator()(const std::locale &__loc) const         {
            const size_t __i = numpunct<_CharT>::id._M_id();
            const locale::facet **__caches = __loc._M_impl->_M_caches;
            if (!__caches[__i]) {
                __numpunct_cache<_CharT> *__tmp = 0;
                try {
                    __tmp = new __numpunct_cache<_CharT>;
                    __tmp->_M_cache(__loc);
                } catch (...) {
                    delete __tmp;
                    throw;
                }
                __loc._M_impl->_M_install_cache(__tmp, __i);
            }
            return static_cast<const __numpunct_cache<_CharT> *>(__caches[__i]);
        }


    };
    void _M_cache(const std::locale &__loc)     {
        const numpunct<_CharT> &__np = use_facet<numpunct<_CharT> >(__loc);
        char *__grouping = 0;
        _CharT *__truename = 0;
        _CharT *__falsename = 0;
        try {
            const string &__g = __np.grouping();
            this->_M_grouping_size = __g.size();
            __grouping = new char [this->_M_grouping_size];
            __g.copy(__grouping, this->_M_grouping_size);
            this->_M_use_grouping = (this->_M_grouping_size && static_cast<signed char>(__grouping[0]) > 0 && (__grouping[0] != __gnu_cxx::__numeric_traits<char>::__max));
            const basic_string<_CharT> &__tn = __np.truename();
            this->_M_truename_size = __tn.size();
            __truename = new _CharT [this->_M_truename_size];
            __tn.copy(__truename, this->_M_truename_size);
            const basic_string<_CharT> &__fn = __np.falsename();
            this->_M_falsename_size = __fn.size();
            __falsename = new _CharT [this->_M_falsename_size];
            __fn.copy(__falsename, this->_M_falsename_size);
            this->_M_decimal_point = __np.decimal_point();
            this->_M_thousands_sep = __np.thousands_sep();
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__loc);
            __ct.widen(__num_base::_S_atoms_out, __num_base::_S_atoms_out + __num_base::_S_oend, this->_M_atoms_out);
            __ct.widen(__num_base::_S_atoms_in, __num_base::_S_atoms_in + __num_base::_S_iend, this->_M_atoms_in);
            this->_M_grouping = __grouping;
            this->_M_truename = __truename;
            this->_M_falsename = __falsename;
            this->_M_allocated = true;
        } catch (...) {
            delete [] __grouping;
            delete [] __truename;
            delete [] __falsename;
            throw;
        }
    }


    bool __verify_grouping(const char *__grouping, size_t __grouping_size, const string &__grouping_tmp) throw() __attribute__((pure));
    _InIter _M_extract_float(_InIter __beg, _InIter __end, std::ios_base &__io, ios_base::iostate &__err, string &__xtrc) const __attribute__((abi_tag("cxx11")))     {
        typedef char_traits<_CharT> __traits_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        char_type __c = char_type();
        bool __testeof = __beg == __end;
        if (!__testeof) {
            __c = *__beg;
            const bool __plus = __c == __lit[__num_base::_S_iplus];
            if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                __xtrc += __plus ? '+' : '-';
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_mantissa = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero]) {
                    if (!__found_mantissa) {
                        __xtrc += '0';
                        __found_mantissa = true;
                    }
                    ++__sep_pos;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                } else
                    break;
            }
        bool __found_dec = false;
        bool __found_sci = false;
        string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        const char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    const int __digit = _M_find(__lit_zero, 10, __c);
                    if (__digit != -1) {
                        __xtrc += '0' + __digit;
                        __found_mantissa = true;
                    } else if (__c == __lc->_M_decimal_point && !__found_dec && !__found_sci) {
                        __xtrc += '.';
                        __found_dec = true;
                    } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                        __xtrc += 'e';
                        __found_sci = true;
                        if (++__beg != __end) {
                            __c = *__beg;
                            const bool __plus = __c == __lit[__num_base::_S_iplus];
                            if (__plus || __c == __lit[__num_base::_S_iminus])
                                __xtrc += __plus ? '+' : '-';
                            else
                                continue;
                        } else {
                            __testeof = true;
                            break;
                        }
                    } else
                        break;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (!__found_dec && !__found_sci) {
                            if (__sep_pos) {
                                __found_grouping += static_cast<char>(__sep_pos);
                                __sep_pos = 0;
                            } else {
                                __xtrc.clear();
                                break;
                            }
                        } else
                            break;
                    } else if (__c == __lc->_M_decimal_point) {
                        if (!__found_dec && !__found_sci) {
                            if (__found_grouping.size())
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += '.';
                            __found_dec = true;
                        } else
                            break;
                    } else {
                        const char_type *__q = __traits_type::find(__lit_zero, 10, __c);
                        if (__q) {
                            __xtrc += '0' + (__q - __lit_zero);
                            __found_mantissa = true;
                            ++__sep_pos;
                        } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                            if (__found_grouping.size() && !__found_dec)
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += 'e';
                            __found_sci = true;
                            if (++__beg != __end) {
                                __c = *__beg;
                                const bool __plus = __c == __lit[__num_base::_S_iplus];
                                if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point))
                                    __xtrc += __plus ? '+' : '-';
                                else
                                    continue;
                            } else {
                                __testeof = true;
                                break;
                            }
                        } else
                            break;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            if (!__found_dec && !__found_sci)
                __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        return __beg;
    }


    template <typename _ValueT> _InIter _M_extract_int(_InIter __beg, _InIter __end, std::ios_base &__io, ios_base::iostate &__err, _ValueT &__v) const __attribute__((abi_tag("cxx11")))     {
        typedef char_traits<_CharT> __traits_type;
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        char_type __c = char_type();
        const ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
        const bool __oct = __basefield == ios_base::oct;
        int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);
        bool __testeof = __beg == __end;
        bool __negative = false;
        if (!__testeof) {
            __c = *__beg;
            __negative = __c == __lit[__num_base::_S_iminus];
            if ((__negative || __c == __lit[__num_base::_S_iplus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_zero = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero] && (!__found_zero || __base == 10)) {
                    __found_zero = true;
                    ++__sep_pos;
                    if (__basefield == 0)
                        __base = 8;
                    if (__base == 8)
                        __sep_pos = 0;
                } else if (__found_zero && (__c == __lit[__num_base::_S_ix] || __c == __lit[__num_base::_S_iX])) {
                    if (__basefield == 0)
                        __base = 16;
                    if (__base == 16) {
                        __found_zero = false;
                        __sep_pos = 0;
                    } else
                        break;
                } else
                    break;
                if (++__beg != __end) {
                    __c = *__beg;
                    if (!__found_zero)
                        break;
                } else
                    __testeof = true;
            }
        const size_t __len = (__base == 16 ? __num_base::_S_iend - __num_base::_S_izero : __base);
        string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        bool __testfail = false;
        bool __testoverflow = false;
        const __unsigned_type __max = (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed) ? - __gnu_cxx::__numeric_traits<_ValueT>::__min : __gnu_cxx::__numeric_traits<_ValueT>::__max;
        const __unsigned_type __smax = __max / __base;
        __unsigned_type __result = 0;
        int __digit = 0;
        const char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    __digit = _M_find(__lit_zero, __len, __c);
                    if (__digit == -1)
                        break;
                    if (__result > __smax)
                        __testoverflow = true;
                    else {
                        __result *= __base;
                        __testoverflow |= __result > __max - __digit;
                        __result += __digit;
                        ++__sep_pos;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (__sep_pos) {
                            __found_grouping += static_cast<char>(__sep_pos);
                            __sep_pos = 0;
                        } else {
                            __testfail = true;
                            break;
                        }
                    } else if (__c == __lc->_M_decimal_point)
                        break;
                    else {
                        const char_type *__q = __traits_type::find(__lit_zero, __len, __c);
                        if (!__q)
                            break;
                        __digit = __q - __lit_zero;
                        if (__digit > 15)
                            __digit -= 6;
                        if (__result > __smax)
                            __testoverflow = true;
                        else {
                            __result *= __base;
                            __testoverflow |= __result > __max - __digit;
                            __result += __digit;
                            ++__sep_pos;
                        }
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        if ((!__sep_pos && !__found_zero && !__found_grouping.size()) || __testfail) {
            __v = 0;
            __err = ios_base::failbit;
        } else if (__testoverflow) {
            if (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
                __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
            else
                __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
            __err = ios_base::failbit;
        } else
            __v = __negative ? - __result : __result;
        if (__testeof)
            __err |= ios_base::eofbit;
        return __beg;
    }

;
    _InIter do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const     {
        if (!(__io.flags() & ios_base::boolalpha)) {
            long __l = -1;
            __beg = _M_extract_int(__beg, __end, __io, __err, __l);
            if (__l == 0 || __l == 1)
                __v = bool(__l);
            else {
                __v = true;
                __err = ios_base::failbit;
                if (__beg == __end)
                    __err |= ios_base::eofbit;
            }
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const std::locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            bool __testf = true;
            bool __testt = true;
            bool __donef = __lc->_M_falsename_size == 0;
            bool __donet = __lc->_M_truename_size == 0;
            bool __testeof = false;
            size_t __n = 0;
            while (!__donef || !__donet)
                {
                    if (__beg == __end) {
                        __testeof = true;
                        break;
                    }
                    const char_type __c = *__beg;
                    if (!__donef)
                        __testf = __c == __lc->_M_falsename[__n];
                    if (!__testf && __donet)
                        break;
                    if (!__donet)
                        __testt = __c == __lc->_M_truename[__n];
                    if (!__testt && __donef)
                        break;
                    if (!__testt && !__testf)
                        break;
                    ++__n;
                    ++__beg;
                    __donef = !__testf || __n >= __lc->_M_falsename_size;
                    __donet = !__testt || __n >= __lc->_M_truename_size;
                }
            if (__testf && __n == __lc->_M_falsename_size && __n) {
                __v = false;
                if (__testt && __n == __lc->_M_truename_size)
                    __err = ios_base::failbit;
                else
                    __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else if (__testt && __n == __lc->_M_truename_size && __n) {
                __v = true;
                __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else {
                __v = false;
                __err = ios_base::failbit;
                if (__testeof)
                    __err |= ios_base::eofbit;
            }
        }
        return __beg;
    }


    _InIter do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const     {
        string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }


    _InIter do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const     {
        string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }


    _InIter do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const     {
        string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }


    _InIter do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const     {
        typedef ios_base::fmtflags fmtflags;
        const fmtflags __fmt = __io.flags();
        __io.flags((__fmt & ~ ios_base::basefield) | ios_base::hex);
        typedef __gnu_cxx::__conditional_type<(sizeof(void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        _UIntPtrType __ul;
        __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
        __io.flags(__fmt);
        __v = reinterpret_cast<void *>(__ul);
        return __beg;
    }


    void _M_pad(_CharT __fill, streamsize __w, std::ios_base &__io, _CharT *__new, const _CharT *__cs, int &__len) const     {
        __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs, __w, __len);
        __len = static_cast<int>(__w);
    }


    template <typename _CharT, typename _ValueT> int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ios_base::fmtflags __flags, bool __dec)     {
        _CharT *__buf = __bufend;
        if (__builtin_expect(__dec, true)) {
            do {
                *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
                __v /= 10;
            } while (__v != 0);
        } else if ((__flags & ios_base::basefield) == ios_base::oct) {
            do {
                *--__buf = __lit[(__v & 7) + __num_base::_S_odigits];
                __v >>= 3;
            } while (__v != 0);
        } else {
            const bool __uppercase = __flags & ios_base::uppercase;
            const int __case_offset = __uppercase ? __num_base::_S_oudigits : __num_base::_S_odigits;
            do {
                *--__buf = __lit[(__v & 15) + __case_offset];
                __v >>= 4;
            } while (__v != 0);
        }
        return __bufend - __buf;
    }

;
    void _M_group_int(const char *__grouping, size_t __grouping_size, _CharT __sep, std::ios_base &, _CharT *__new, _CharT *__cs, int &__len) const     {
        _CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len);
        __len = __p - __new;
    }


    template <typename _ValueT> _OutIter _M_insert_int(_OutIter __s, std::ios_base &__io, _CharT __fill, _ValueT __v) const     {
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_out;
        const ios_base::fmtflags __flags = __io.flags();
        const int __ilen = 5 * sizeof(_ValueT);
        _CharT *__cs = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen));
        const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
        const bool __dec = (__basefield != ios_base::oct && __basefield != ios_base::hex);
        const __unsigned_type __u = ((__v > 0 || !__dec) ? __unsigned_type(__v) : - __unsigned_type(__v));
        int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
        __cs += __ilen - __len;
        if (__lc->_M_use_grouping) {
            _CharT *__cs2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
            this->_M_group_int(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
            __cs = __cs2 + 2;
        }
        if (__builtin_expect(__dec, true)) {
            if (__v >= 0) {
                if (bool(__flags & ios_base::showpos) && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
                    *--__cs = __lit[__num_base::_S_oplus] , ++__len;
            } else
                *--__cs = __lit[__num_base::_S_ominus] , ++__len;
        } else if (bool(__flags & ios_base::showbase) && __v) {
            if (__basefield == ios_base::oct)
                *--__cs = __lit[__num_base::_S_odigits] , ++__len;
            else {
                const bool __uppercase = __flags & ios_base::uppercase;
                *--__cs = __lit[__num_base::_S_ox + __uppercase];
                *--__cs = __lit[__num_base::_S_odigits];
                __len += 2;
            }
        }
        const streamsize __w = __io.width();
        if (__w > static_cast<streamsize>(__len)) {
            _CharT *__cs3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __cs3, __cs, __len);
            __cs = __cs3;
        }
        __io.width(0);
        return std::__write(__s, __cs, __len);
    }

;
    void _M_group_float(const char *__grouping, size_t __grouping_size, _CharT __sep, const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len) const     {
        const int __declen = __p ? __p - __cs : __len;
        _CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen);
        int __newlen = __p2 - __new;
        if (__p) {
            char_traits<_CharT>::copy(__p2, __p, __len - __declen);
            __newlen += __len - __declen;
        }
        __len = __newlen;
    }


    template <typename _ValueT> _OutIter _M_insert_float(_OutIter __s, std::ios_base &__io, _CharT __fill, char __mod, _ValueT __v) const     {
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();
        const int __max_digits = __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
        int __len;
        char __fbuf[16];
        __num_base::_S_format_float(__io, __fbuf, __mod);
        const bool __use_prec = (__io.flags() & ios_base::floatfield) != ios_base::floatfield;
        int __cs_size = __max_digits * 3;
        char *__cs = static_cast<char *>(__builtin_alloca(__cs_size));
        if (__use_prec)
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
        else
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        if (__len >= __cs_size) {
            __cs_size = __len + 1;
            __cs = static_cast<char *>(__builtin_alloca(__cs_size));
            if (__use_prec)
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
            else
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        }
        const ctype<_CharT> &__ctype = use_facet<ctype<_CharT> >(__loc);
        _CharT *__ws = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len));
        __ctype.widen(__cs, __cs + __len, __ws);
        _CharT *__wp = 0;
        const char *__p = char_traits<char>::find(__cs, __len, '.');
        if (__p) {
            __wp = __ws + (__p - __cs);
            *__wp = __lc->_M_decimal_point;
        }
        if (__lc->_M_use_grouping && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9' && __cs[1] >= '0' && __cs[2] >= '0'))) {
            _CharT *__ws2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len * 2));
            streamsize __off = 0;
            if (__cs[0] == '-' || __cs[0] == '+') {
                __off = 1;
                __ws2[0] = __ws[0];
                __len -= 1;
            }
            this->_M_group_float(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off, __len);
            __len += __off;
            __ws = __ws2;
        }
        const streamsize __w = __io.width();
        if (__w > static_cast<streamsize>(__len)) {
            _CharT *__ws3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __ws3, __ws, __len);
            __ws = __ws3;
        }
        __io.width(0);
        return std::__write(__s, __ws, __len);
    }

;
    _OutIter do_put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const     {
        const ios_base::fmtflags __flags = __io.flags();
        if ((__flags & ios_base::boolalpha) == 0) {
            const long __l = __v;
            __s = _M_insert_int(__s, __io, __fill, __l);
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const std::locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            const _CharT *__name = __v ? __lc->_M_truename : __lc->_M_falsename;
            int __len = __v ? __lc->_M_truename_size : __lc->_M_falsename_size;
            const streamsize __w = __io.width();
            if (__w > static_cast<streamsize>(__len)) {
                const streamsize __plen = __w - __len;
                _CharT *__ps = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __plen));
                char_traits<_CharT>::assign(__ps, __plen, __fill);
                __io.width(0);
                if ((__flags & ios_base::adjustfield) == ios_base::left) {
                    __s = std::__write(__s, __name, __len);
                    __s = std::__write(__s, __ps, __plen);
                } else {
                    __s = std::__write(__s, __ps, __plen);
                    __s = std::__write(__s, __name, __len);
                }
                return __s;
            }
            __io.width(0);
            __s = std::__write(__s, __name, __len);
        }
        return __s;
    }


    _OutIter do_put(iter_type __s, std::ios_base &__io, char_type __fill, double __v) const     {
        return _M_insert_float(__s, __io, __fill, char(), __v);
    }


    _OutIter do_put(iter_type __s, std::ios_base &__io, char_type __fill, long double __v) const     {
        return _M_insert_float(__s, __io, __fill, 'L', __v);
    }


    _OutIter do_put(iter_type __s, std::ios_base &__io, char_type __fill, const void *__v) const     {
        const ios_base::fmtflags __flags = __io.flags();
        const ios_base::fmtflags __fmt = ~ (ios_base::basefield | ios_base::uppercase);
        __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));
        typedef __gnu_cxx::__conditional_type<(sizeof(const void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        __s = _M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType>(__v));
        __io.flags(__flags);
        return __s;
    }


    void _S_pad(std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, streamsize __newlen, streamsize __oldlen)     {
        const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
        const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;
        if (__adjust == ios_base::left) {
            _Traits::copy(__news, __olds, __oldlen);
            _Traits::assign(__news + __oldlen, __plen, __fill);
            return;
        }
        size_t __mod = 0;
        if (__adjust == ios_base::internal) {
            const std::locale &__loc = __io._M_getloc();
            const ctype<_CharT> &__ctype = use_facet<ctype<_CharT> >(__loc);
            if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0]) {
                __news[0] = __olds[0];
                __mod = 1;
                ++__news;
            } else if (__ctype.widen('0') == __olds[0] && __oldlen > 1 && (__ctype.widen('x') == __olds[1] || __ctype.widen('X') == __olds[1])) {
                __news[0] = __olds[0];
                __news[1] = __olds[1];
                __mod = 2;
                __news += 2;
            }
        }
        _Traits::assign(__news, __plen, __fill);
        _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }


    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, size_t __gsize, const _CharT *__first, const _CharT *__last)     {
        size_t __idx = 0;
        size_t __ctr = 0;
        while (__last - __first > __gbeg[__idx] && static_cast<signed char>(__gbeg[__idx]) > 0 && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
            {
                __last -= __gbeg[__idx];
                __idx < __gsize - 1 ? ++__idx : ++__ctr;
            }
        while (__first != __last)
            *__s++ = *__first++;
        while (__ctr--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i) 
                    *__s++ = *__first++;
            }
        while (__idx--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i) 
                    *__s++ = *__first++;
            }
        return __s;
    }

;
    class numpunct : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        typedef __numpunct_cache<char> __cache_type;
    protected:
        __cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(size_t __refs);
        explicit numpunct(__cache_type *__cache, size_t __refs);
        explicit numpunct(__c_locale __cloc, size_t __refs);
        char_type decimal_point() const;
        char_type thousands_sep() const;
        string grouping() const;
        string_type truename() const;
        string_type falsename() const;
    protected:
        virtual ~std::__cxx11::numpunct<char>();
        virtual char_type do_decimal_point() const;
        virtual char_type do_thousands_sep() const;
        virtual string do_grouping() const;
        virtual string_type do_truename() const;
        virtual string_type do_falsename() const;
        void _M_initialize_numpunct(__c_locale __cloc);
    };
    class numpunct_byname : public numpunct<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit numpunct_byname(const char *__s, size_t __refs);
    protected:
        virtual ~std::__cxx11::numpunct_byname<char>();
    };
    class num_get : public locale::facet {
    public:
        typedef char char_type;
        typedef std::istreambuf_iterator<char, std::char_traits<char> > iter_type;
        static locale::id id;
        explicit num_get(size_t __refs);
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~std::num_get<char>();
        iter_type _M_extract_float(iter_type, iter_type, std::ios_base &, ios_base::iostate &, string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> iter_type _M_extract_int(iter_type, iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    class num_put : public locale::facet {
    public:
        typedef char char_type;
        typedef std::ostreambuf_iterator<char, std::char_traits<char> > iter_type;
        static locale::id id;
        explicit num_put(size_t __refs);
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> iter_type _M_insert_float(iter_type, std::ios_base &__io, char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, size_t __grouping_size, char_type __sep, const char_type *__p, char_type *__new, char_type *__cs, int &__len) const;
        template <typename _ValueT> iter_type _M_insert_int(iter_type, std::ios_base &__io, char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, size_t __grouping_size, char_type __sep, std::ios_base &__io, char_type *__new, char_type *__cs, int &__len) const;
        void _M_pad(char_type __fill, streamsize __w, std::ios_base &__io, char_type *__new, const char_type *__cs, int &__len) const;
        virtual ~std::num_put<char>();
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, long double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, const void *) const;
    };
    class ctype_byname;
    class numpunct : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        typedef __numpunct_cache<wchar_t> __cache_type;
    protected:
        __cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(size_t __refs);
        explicit numpunct(__cache_type *__cache, size_t __refs);
        explicit numpunct(__c_locale __cloc, size_t __refs);
        char_type decimal_point() const;
        char_type thousands_sep() const;
        string grouping() const;
        string_type truename() const;
        string_type falsename() const;
    protected:
        virtual ~std::__cxx11::numpunct<wchar_t>();
        virtual char_type do_decimal_point() const;
        virtual char_type do_thousands_sep() const;
        virtual string do_grouping() const;
        virtual string_type do_truename() const;
        virtual string_type do_falsename() const;
        void _M_initialize_numpunct(__c_locale __cloc);
    };
    class numpunct_byname : public numpunct<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit numpunct_byname(const char *__s, size_t __refs);
    protected:
        virtual ~std::__cxx11::numpunct_byname<wchar_t>();
    };
    class num_get : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > iter_type;
        static locale::id id;
        explicit num_get(size_t __refs);
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        iter_type get(iter_type __in, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~std::num_get<wchar_t>();
        iter_type _M_extract_float(iter_type, iter_type, std::ios_base &, ios_base::iostate &, string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> iter_type _M_extract_int(iter_type, iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual iter_type do_get(iter_type, iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    class num_put : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > iter_type;
        static locale::id id;
        explicit num_put(size_t __refs);
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, long double __v) const;
        iter_type put(iter_type __s, std::ios_base &__io, char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> iter_type _M_insert_float(iter_type, std::ios_base &__io, char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, size_t __grouping_size, char_type __sep, const char_type *__p, char_type *__new, char_type *__cs, int &__len) const;
        template <typename _ValueT> iter_type _M_insert_int(iter_type, std::ios_base &__io, char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, size_t __grouping_size, char_type __sep, std::ios_base &__io, char_type *__new, char_type *__cs, int &__len) const;
        void _M_pad(char_type __fill, streamsize __w, std::ios_base &__io, char_type *__new, const char_type *__cs, int &__len) const;
        virtual ~std::num_put<wchar_t>();
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, bool __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, long long __v) const;
        virtual iter_type do_put(iter_type __s, std::ios_base &__io, char_type __fill, unsigned long long __v) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, long double) const;
        virtual iter_type do_put(iter_type, std::ios_base &, char_type, const void *) const;
    };
    class ctype_byname;
}
namespace std {
    template <typename _Facet = std::ctype<char>> inline const std::ctype<char> &__check_facet(const std::ctype<char> *__f)     {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }

template <typename _Facet> inline const _Facet &__check_facet(const _Facet *__f)     {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_ios : public std::ios_base {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef ctype<char> __ctype_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char> > > __num_put_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char> > > __num_get_type;
    protected:
        basic_ostream<char, std::char_traits<char> > *_M_tie;
        mutable char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<char, std::char_traits<char> > *_M_streambuf;
        const __ctype_type *_M_ctype;
        const __num_put_type *_M_num_put;
        const __num_get_type *_M_num_get;
    public:
        operator void *() const;
        bool operator!() const;
        iostate rdstate() const         {
            return this->_M_streambuf_state;
        }


        void clear(iostate __state);
        void setstate(iostate __state)         {
            this->clear(this->rdstate() | __state);
        }


        void _M_setstate(iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        iostate exceptions() const;
        void exceptions(iostate __except);
        explicit basic_ios(basic_streambuf<char, std::char_traits<char> > *__sb);
        virtual ~std::basic_ios<char>();
        basic_ostream<char, std::char_traits<char> > *tie() const;
        basic_ostream<char, std::char_traits<char> > *tie(basic_ostream<char, std::char_traits<char> > *__tiestr);
        basic_streambuf<char, std::char_traits<char> > *rdbuf() const;
        basic_streambuf<char, std::char_traits<char> > *rdbuf(basic_streambuf<char, std::char_traits<char> > *__sb);
        std::basic_ios<char> &copyfmt(const std::basic_ios<char> &__rhs);
        char_type fill() const;
        char_type fill(char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(char_type __c, char __dfault) const;
        char_type widen(char __c) const         {
            return __check_facet(this->_M_ctype).widen(__c);
        }


    protected:
        basic_ios();
        void init(basic_streambuf<char, std::char_traits<char> > *__sb);
        void _M_cache_locale(const std::locale &__loc);
    }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_ios : public std::ios_base {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef ctype<wchar_t> __ctype_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_put_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_get_type;
    protected:
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *_M_tie;
        mutable char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *_M_streambuf;
        const __ctype_type *_M_ctype;
        const __num_put_type *_M_num_put;
        const __num_get_type *_M_num_get;
    public:
        operator void *() const;
        bool operator!() const;
        iostate rdstate() const;
        void clear(iostate __state);
        void setstate(iostate __state);
        void _M_setstate(iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        iostate exceptions() const;
        void exceptions(iostate __except);
        explicit basic_ios(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        virtual ~std::basic_ios<wchar_t>();
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *tie() const;
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *tie(basic_ostream<wchar_t, std::char_traits<wchar_t> > *__tiestr);
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *rdbuf() const;
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *rdbuf(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        std::basic_ios<wchar_t> &copyfmt(const std::basic_ios<wchar_t> &__rhs);
        char_type fill() const;
        char_type fill(char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(char_type __c, char __dfault) const;
        char_type widen(char __c) const;
    protected:
        basic_ios();
        void init(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        void _M_cache_locale(const std::locale &__loc);
    }
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios : public std::ios_base {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef ctype<_CharT> __ctype_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> > __num_get_type;
    protected:
        basic_ostream<_CharT, _Traits> *_M_tie;
        mutable char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<_CharT, _Traits> *_M_streambuf;
        const __ctype_type *_M_ctype;
        const __num_put_type *_M_num_put;
        const __num_get_type *_M_num_get;
    public:
        operator void *() const         {
            return this->fail() ? 0 : const_cast<basic_ios<_CharT, _Traits> *>(this);
        }


        bool operator!() const         {
            return this->fail();
        }


        iostate rdstate() const         {
            return this->_M_streambuf_state;
        }


        void clear(iostate __state = goodbit);
        void setstate(iostate __state)         {
            this->clear(this->rdstate() | __state);
        }


        void _M_setstate(iostate __state)         {
            this->_M_streambuf_state |= __state;
            if (this->exceptions() & __state)
                throw;
        }


        bool good() const         {
            return this->rdstate() == 0;
        }


        bool eof() const         {
            return (this->rdstate() & eofbit) != 0;
        }


        bool fail() const         {
            return (this->rdstate() & (badbit | failbit)) != 0;
        }


        bool bad() const         {
            return (this->rdstate() & badbit) != 0;
        }


        iostate exceptions() const         {
            return this->_M_exception;
        }


        void exceptions(iostate __except)         {
            this->_M_exception = __except;
            this->clear(this->_M_streambuf_state);
        }


        explicit basic_ios<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : std::ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)         {
            this->init(__sb);
        }


        virtual ~basic_ios<_CharT, _Traits>()         {
        }


        basic_ostream<_CharT, _Traits> *tie() const         {
            return this->_M_tie;
        }


        basic_ostream<_CharT, _Traits> *tie(basic_ostream<_CharT, _Traits> *__tiestr)         {
            basic_ostream<_CharT, _Traits> *__old = this->_M_tie;
            this->_M_tie = __tiestr;
            return __old;
        }


        basic_streambuf<_CharT, _Traits> *rdbuf() const         {
            return this->_M_streambuf;
        }


        basic_streambuf<_CharT, _Traits> *rdbuf(basic_streambuf<_CharT, _Traits> *__sb);
        basic_ios<_CharT, _Traits> &copyfmt(const basic_ios<_CharT, _Traits> &__rhs);
        char_type fill() const         {
            if (!this->_M_fill_init) {
                this->_M_fill = this->widen(' ');
                this->_M_fill_init = true;
            }
            return this->_M_fill;
        }


        char_type fill(char_type __ch)         {
            char_type __old = this->fill();
            this->_M_fill = __ch;
            return __old;
        }


        std::locale imbue(const std::locale &__loc);
        char narrow(char_type __c, char __dfault) const         {
            return __check_facet(this->_M_ctype).narrow(__c, __dfault);
        }


        char_type widen(char __c) const         {
            return __check_facet(this->_M_ctype).widen(__c);
        }


    protected:
        basic_ios<_CharT, _Traits>() : std::ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)         {
        }


        void init(basic_streambuf<_CharT, _Traits> *__sb);
        void _M_cache_locale(const std::locale &__loc);
    };
}
namespace std {
    void clear(iostate __state = goodbit)     {
        if (this->rdbuf())
            this->_M_streambuf_state = __state;
        else
            this->_M_streambuf_state = __state | badbit;
        if (this->exceptions() & this->rdstate())
            __throw_ios_failure(("basic_ios::clear"));
    }


    basic_streambuf<_CharT, _Traits> *rdbuf(basic_streambuf<_CharT, _Traits> *__sb)     {
        basic_streambuf<_CharT, _Traits> *__old = this->_M_streambuf;
        this->_M_streambuf = __sb;
        this->clear();
        return __old;
    }


    basic_ios<_CharT, _Traits> &copyfmt(const basic_ios<_CharT, _Traits> &__rhs)     {
        if (this != & __rhs) {
            std::ios_base::_Words *__words = (__rhs._M_word_size <= _S_local_word_size) ? this->_M_local_word : new std::ios_base::_Words [__rhs._M_word_size];
            std::ios_base::_Callback_list *__cb = __rhs._M_callbacks;
            if (__cb)
                __cb->_M_add_reference();
            this->_M_call_callbacks(erase_event);
            if (this->_M_word != this->_M_local_word) {
                delete [] this->_M_word;
                this->_M_word = 0;
            }
            this->_M_dispose_callbacks();
            this->_M_callbacks = __cb;
            for (int __i = 0; __i < __rhs._M_word_size; ++__i) 
                __words[__i] = __rhs._M_word[__i];
            this->_M_word = __words;
            this->_M_word_size = __rhs._M_word_size;
            this->flags(__rhs.flags());
            this->width(__rhs.width());
            this->precision(__rhs.precision());
            this->tie(__rhs.tie());
            this->fill(__rhs.fill());
            this->_M_ios_locale = __rhs.getloc();
            this->_M_cache_locale(this->_M_ios_locale);
            this->_M_call_callbacks(copyfmt_event);
            this->exceptions(__rhs.exceptions());
        }
        return *this;
    }


    std::locale imbue(const std::locale &__loc)     {
        std::locale __old(this->getloc());
        this->ios_base::imbue(__loc);
        this->_M_cache_locale(__loc);
        if (this->rdbuf() != 0)
            this->rdbuf()->pubimbue(__loc);
        return __old;
    }


    void init(basic_streambuf<_CharT, _Traits> *__sb)     {
        this->ios_base::_M_init();
        this->_M_cache_locale(this->_M_ios_locale);
        this->_M_fill = _CharT();
        this->_M_fill_init = false;
        this->_M_tie = 0;
        this->_M_exception = goodbit;
        this->_M_streambuf = __sb;
        this->_M_streambuf_state = __sb ? goodbit : badbit;
    }


    void _M_cache_locale(const std::locale &__loc)     {
        if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
            this->_M_ctype = & use_facet<__ctype_type>(__loc);
        else
            this->_M_ctype = 0;
        if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
            this->_M_num_put = & use_facet<__num_put_type>(__loc);
        else
            this->_M_num_put = 0;
        if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
            this->_M_num_get = & use_facet<__num_get_type>(__loc);
        else
            this->_M_num_get = 0;
    }


    class basic_ios : public std::ios_base {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef ctype<char> __ctype_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char> > > __num_put_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char> > > __num_get_type;
    protected:
        basic_ostream<char, std::char_traits<char> > *_M_tie;
        mutable char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<char, std::char_traits<char> > *_M_streambuf;
        const __ctype_type *_M_ctype;
        const __num_put_type *_M_num_put;
        const __num_get_type *_M_num_get;
    public:
        operator void *() const;
        bool operator!() const;
        iostate rdstate() const         {
            return this->_M_streambuf_state;
        }


        void clear(iostate __state);
        void setstate(iostate __state)         {
            this->clear(this->rdstate() | __state);
        }


        void _M_setstate(iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        iostate exceptions() const;
        void exceptions(iostate __except);
        explicit basic_ios(basic_streambuf<char, std::char_traits<char> > *__sb);
        virtual ~std::basic_ios<char>();
        basic_ostream<char, std::char_traits<char> > *tie() const;
        basic_ostream<char, std::char_traits<char> > *tie(basic_ostream<char, std::char_traits<char> > *__tiestr);
        basic_streambuf<char, std::char_traits<char> > *rdbuf() const;
        basic_streambuf<char, std::char_traits<char> > *rdbuf(basic_streambuf<char, std::char_traits<char> > *__sb);
        std::basic_ios<char> &copyfmt(const std::basic_ios<char> &__rhs);
        char_type fill() const;
        char_type fill(char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(char_type __c, char __dfault) const;
        char_type widen(char __c) const         {
            return __check_facet(this->_M_ctype).widen(__c);
        }


    protected:
        basic_ios();
        void init(basic_streambuf<char, std::char_traits<char> > *__sb);
        void _M_cache_locale(const std::locale &__loc);
    };
    class basic_ios : public std::ios_base {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef ctype<wchar_t> __ctype_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_put_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_get_type;
    protected:
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *_M_tie;
        mutable char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *_M_streambuf;
        const __ctype_type *_M_ctype;
        const __num_put_type *_M_num_put;
        const __num_get_type *_M_num_get;
    public:
        operator void *() const;
        bool operator!() const;
        iostate rdstate() const;
        void clear(iostate __state);
        void setstate(iostate __state);
        void _M_setstate(iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        iostate exceptions() const;
        void exceptions(iostate __except);
        explicit basic_ios(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        virtual ~std::basic_ios<wchar_t>();
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *tie() const;
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *tie(basic_ostream<wchar_t, std::char_traits<wchar_t> > *__tiestr);
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *rdbuf() const;
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *rdbuf(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        std::basic_ios<wchar_t> &copyfmt(const std::basic_ios<wchar_t> &__rhs);
        char_type fill() const;
        char_type fill(char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(char_type __c, char __dfault) const;
        char_type widen(char __c) const;
    protected:
        basic_ios();
        void init(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        void _M_cache_locale(const std::locale &__loc);
    };
}
namespace std {
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_ostream : virtual public basic_ios<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
        typedef basic_ios<char, std::char_traits<char> > __ios_type;
        typedef basic_ostream<char, std::char_traits<char> > __ostream_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char> > > __num_put_type;
        typedef ctype<char> __ctype_type;
        explicit basic_ostream(__streambuf_type *__sb);
        virtual ~std::basic_ostream<char>();
        class sentry {
            bool _M_ok;
            basic_ostream<char, std::char_traits<char> > &_M_os;
        public:
            explicit sentry(basic_ostream<char, std::char_traits<char> > &__os);
            ~std::basic_ostream<char, std::char_traits<char> >::sentry();
            operator bool() const;
        };
        friend  class sentry;
        __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &))         {
            return __pf(*this);
        }


        __ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &));
        __ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        __ostream_type &operator<<(long __n);
        __ostream_type &operator<<(unsigned long __n);
        __ostream_type &operator<<(bool __n);
        __ostream_type &operator<<(short __n);
        __ostream_type &operator<<(unsigned short __n);
        __ostream_type &operator<<(int __n);
        __ostream_type &operator<<(unsigned int __n);
        __ostream_type &operator<<(long long __n);
        __ostream_type &operator<<(unsigned long long __n);
        __ostream_type &operator<<(double __f);
        __ostream_type &operator<<(float __f);
        __ostream_type &operator<<(long double __f);
        __ostream_type &operator<<(const void *__p);
        __ostream_type &operator<<(__streambuf_type *__sb);
        __ostream_type &put(char_type __c);
        void _M_write(const char_type *__s, streamsize __n);
        __ostream_type &write(const char_type *__s, streamsize __n);
        __ostream_type &flush();
        pos_type tellp();
        __ostream_type &seekp(pos_type);
        __ostream_type &seekp(off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        template <typename _ValueT = long> __ostream_type &_M_insert(long __v)template <typename _ValueT = unsigned long> __ostream_type &_M_insert(unsigned long __v)template <typename _ValueT = bool> __ostream_type &_M_insert(bool __v)template <typename _ValueT = long long> __ostream_type &_M_insert(long long __v)template <typename _ValueT = unsigned long long> __ostream_type &_M_insert(unsigned long long __v)template <typename _ValueT = double> __ostream_type &_M_insert(double __v)template <typename _ValueT = long double> __ostream_type &_M_insert(long double __v)template <typename _ValueT = const void *> __ostream_type &_M_insert(const void *__v)template <typename _ValueT> __ostream_type &_M_insert(_ValueT __v);
    }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_ostream : virtual public basic_ios<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t> > __ios_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t> > __ostream_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_put_type;
        typedef ctype<wchar_t> __ctype_type;
        explicit basic_ostream(__streambuf_type *__sb);
        virtual ~std::basic_ostream<wchar_t>();
        class sentry {
            bool _M_ok;
            basic_ostream<wchar_t, std::char_traits<wchar_t> > &_M_os;
        public:
            explicit sentry(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__os);
            ~std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::sentry();
            operator bool() const;
        };
        friend  class sentry;
        __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &));
        __ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &));
        __ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        __ostream_type &operator<<(long __n);
        __ostream_type &operator<<(unsigned long __n);
        __ostream_type &operator<<(bool __n);
        __ostream_type &operator<<(short __n);
        __ostream_type &operator<<(unsigned short __n);
        __ostream_type &operator<<(int __n);
        __ostream_type &operator<<(unsigned int __n);
        __ostream_type &operator<<(long long __n);
        __ostream_type &operator<<(unsigned long long __n);
        __ostream_type &operator<<(double __f);
        __ostream_type &operator<<(float __f);
        __ostream_type &operator<<(long double __f);
        __ostream_type &operator<<(const void *__p);
        __ostream_type &operator<<(__streambuf_type *__sb);
        __ostream_type &put(char_type __c);
        void _M_write(const char_type *__s, streamsize __n);
        __ostream_type &write(const char_type *__s, streamsize __n);
        __ostream_type &flush();
        pos_type tellp();
        __ostream_type &seekp(pos_type);
        __ostream_type &seekp(off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        template <typename _ValueT = long> __ostream_type &_M_insert(long __v)template <typename _ValueT = unsigned long> __ostream_type &_M_insert(unsigned long __v)template <typename _ValueT = bool> __ostream_type &_M_insert(bool __v)template <typename _ValueT = long long> __ostream_type &_M_insert(long long __v)template <typename _ValueT = unsigned long long> __ostream_type &_M_insert(unsigned long long __v)template <typename _ValueT = double> __ostream_type &_M_insert(double __v)template <typename _ValueT = long double> __ostream_type &_M_insert(long double __v)template <typename _ValueT = const void *> __ostream_type &_M_insert(const void *__v)template <typename _ValueT> __ostream_type &_M_insert(_ValueT __v);
    }
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
        typedef ctype<_CharT> __ctype_type;
        explicit basic_ostream<_CharT, _Traits>(__streambuf_type *__sb)         {
            this->init(__sb);
        }


        virtual ~basic_ostream<_CharT, _Traits>()         {
        }


        class sentry;
        friend  class sentry;
        __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &))         {
            return __pf(*this);
        }


        __ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &))         {
            __pf(*this);
            return *this;
        }


        __ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &))         {
            __pf(*this);
            return *this;
        }


        __ostream_type &operator<<(long __n)         {
            return _M_insert(__n);
        }


        __ostream_type &operator<<(unsigned long __n)         {
            return _M_insert(__n);
        }


        __ostream_type &operator<<(bool __n)         {
            return _M_insert(__n);
        }


        __ostream_type &operator<<(short __n);
        __ostream_type &operator<<(unsigned short __n)         {
            return _M_insert(static_cast<unsigned long>(__n));
        }


        __ostream_type &operator<<(int __n);
        __ostream_type &operator<<(unsigned int __n)         {
            return _M_insert(static_cast<unsigned long>(__n));
        }


        __ostream_type &operator<<(long long __n)         {
            return _M_insert(__n);
        }


        __ostream_type &operator<<(unsigned long long __n)         {
            return _M_insert(__n);
        }


        __ostream_type &operator<<(double __f)         {
            return _M_insert(__f);
        }


        __ostream_type &operator<<(float __f)         {
            return _M_insert(static_cast<double>(__f));
        }


        __ostream_type &operator<<(long double __f)         {
            return _M_insert(__f);
        }


        __ostream_type &operator<<(const void *__p)         {
            return _M_insert(__p);
        }


        __ostream_type &operator<<(__streambuf_type *__sb);
        __ostream_type &put(char_type __c);
        void _M_write(const char_type *__s, streamsize __n)         {
            const streamsize __put = this->rdbuf()->sputn(__s, __n);
            if (__put != __n)
                this->setstate(ios_base::badbit);
        }


        __ostream_type &write(const char_type *__s, streamsize __n);
        __ostream_type &flush();
        pos_type tellp();
        __ostream_type &seekp(pos_type);
        __ostream_type &seekp(off_type, ios_base::seekdir);
    protected:
        basic_ostream<_CharT, _Traits>()         {
            this->init(0);
        }


        template <typename _ValueT> __ostream_type &_M_insert(_ValueT __v);
    };
    class sentry {
        bool _M_ok;
        basic_ostream<_CharT, _Traits> &_M_os;
    public:
        explicit sentry(basic_ostream<_CharT, _Traits> &__os);
        ~std::basic_ostream::sentry()         {
            if (bool(this->_M_os.flags() & ios_base::unitbuf) && !uncaught_exception()) {
                if (this->_M_os.rdbuf() && this->_M_os.rdbuf()->pubsync() == -1)
                    this->_M_os.setstate(ios_base::badbit);
            }
        }


        operator bool() const         {
            return this->_M_ok;
        }


    };
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__out, char __c)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> inline basic_ostream<wchar_t, std::char_traits<wchar_t> > &operator<<(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__out, wchar_t __c)template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, _CharT __c)     {
        return __ostream_insert(__out, & __c, 1);
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__out, char __c)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> inline basic_ostream<wchar_t, std::char_traits<wchar_t> > &operator<<(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__out, char __c)template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, char __c)     {
        return (__out << __out.widen(__c));
    }

;
    template <class _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__out, char __c)template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, char __c)     {
        return __ostream_insert(__out, &__c, 1);
    }

;
    template <class _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__out, signed char __c)template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, signed char __c)     {
        return (__out << static_cast<char>(__c));
    }

;
    template <class _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__out, unsigned char __c)template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, unsigned char __c)     {
        return (__out << static_cast<char>(__c));
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__out, const char *__s)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> inline basic_ostream<wchar_t, std::char_traits<wchar_t> > &operator<<(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__out, const wchar_t *__s)template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<streamsize>(_Traits::length(__s)));
        return __out;
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__out, const char *__s)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> basic_ostream<wchar_t, std::char_traits<wchar_t> > &operator<<(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__out, const char *__s)template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s);
    template <class _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__out, const char *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<streamsize>(char_traits<char>::length(__s)));
        return __out;
    }

template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const char *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<streamsize>(_Traits::length(__s)));
        return __out;
    }

;
    template <class _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__out, const signed char *__s)template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const signed char *__s)     {
        return (__out << reinterpret_cast<const char *>(__s));
    }

;
    template <class _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__out, const unsigned char *__s)template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const unsigned char *__s)     {
        return (__out << reinterpret_cast<const char *>(__s));
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &endl(basic_ostream<char, std::char_traits<char> > &__os)     {
        return flush(__os.put(__os.widen('\n')));
    }

template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> inline basic_ostream<wchar_t, std::char_traits<wchar_t> > &endl(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__os)template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &endl(basic_ostream<_CharT, _Traits> &__os)     {
        return flush(__os.put(__os.widen('\n')));
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &ends(basic_ostream<char, std::char_traits<char> > &__os)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> inline basic_ostream<wchar_t, std::char_traits<wchar_t> > &ends(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__os)template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &ends(basic_ostream<_CharT, _Traits> &__os)     {
        return __os.put(_CharT());
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> inline basic_ostream<char, std::char_traits<char> > &flush(basic_ostream<char, std::char_traits<char> > &__os)     {
        return __os.flush();
    }

template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> inline basic_ostream<wchar_t, std::char_traits<wchar_t> > &flush(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__os)template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &flush(basic_ostream<_CharT, _Traits> &__os)     {
        return __os.flush();
    }

;
}
namespace std {
    sentry(basic_ostream<_CharT, _Traits> &__os) : _M_ok(false), _M_os(__os)     {
        if (__os.tie() && __os.good())
            __os.tie()->flush();
        if (__os.good())
            this->_M_ok = true;
        else
            __os.setstate(ios_base::failbit);
    }


    template <typename _ValueT> basic_ostream<_CharT, _Traits> &_M_insert(_ValueT __v)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __num_put_type &__np = __check_facet(this->_M_num_put);
                if (__np.put(*this, *this, this->fill(), __v).failed())
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }

;
    basic_ostream<_CharT, _Traits> &operator<<(short __n)     {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }


    basic_ostream<_CharT, _Traits> &operator<<(int __n)     {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }


    basic_ostream<_CharT, _Traits> &operator<<(__streambuf_type *__sbin)     {
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb && __sbin) {
            try {
                if (!__copy_streambufs(__sbin, this->rdbuf()))
                    __err |= ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbin)
            __err |= ios_base::badbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }


    basic_ostream<_CharT, _Traits> &put(char_type __c)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __put = this->rdbuf()->sputc(__c);
                if (traits_type::eq_int_type(__put, traits_type::eof()))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }


    basic_ostream<_CharT, _Traits> &write(const _CharT *__s, streamsize __n)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            try {
                this->_M_write(__s, __n);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        return *this;
    }


    basic_ostream<_CharT, _Traits> &flush()     {
        ios_base::iostate __err = ios_base::goodbit;
        try {
            if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
                __err |= ios_base::badbit;
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }


    typename basic_ostream<_CharT, _Traits>::pos_type tellp()     {
        pos_type __ret = pos_type(-1);
        try {
            if (!this->fail())
                __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        return __ret;
    }


    basic_ostream<_CharT, _Traits> &seekp(pos_type __pos)     {
        ios_base::iostate __err = ios_base::goodbit;
        try {
            if (!this->fail()) {
                const pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);
                if (__p == pos_type(off_type(-1)))
                    __err |= ios_base::failbit;
            }
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }


    basic_ostream<_CharT, _Traits> &seekp(off_type __off, ios_base::seekdir __dir)     {
        ios_base::iostate __err = ios_base::goodbit;
        try {
            if (!this->fail()) {
                const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);
                if (__p == pos_type(off_type(-1)))
                    __err |= ios_base::failbit;
            }
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }


    template <typename _CharT = char, typename _Traits = std::char_traits<char>> basic_ostream<char, std::char_traits<char> > &operator<<(basic_ostream<char, std::char_traits<char> > &__out, const char *__s)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> basic_ostream<wchar_t, std::char_traits<wchar_t> > &operator<<(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__out, const char *__s)template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else {
            const size_t __clen = char_traits<char>::length(__s);
            try {
                struct __ptr_guard {
                    _CharT *__p;
                    __ptr_guard(_CharT *__ip) : __p(__ip)                     {
                    }


                    ~__ptr_guard()                     {
                        delete [] this->__p;
                    }


                    _CharT *__get()                     {
                        return this->__p;
                    }


                } __pg(new _CharT [__clen]);
                _CharT *__ws = __pg.__get();
                for (size_t __i = 0; __i < __clen; ++__i) 
                    __ws[__i] = __out.widen(__s[__i]);
                __ostream_insert(__out, __ws, __clen);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(ios_base::badbit);
            }
        }
        return __out;
    }

;
    class basic_ostream : virtual public basic_ios<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
        typedef basic_ios<char, std::char_traits<char> > __ios_type;
        typedef basic_ostream<char, std::char_traits<char> > __ostream_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char> > > __num_put_type;
        typedef ctype<char> __ctype_type;
        explicit basic_ostream(__streambuf_type *__sb);
        virtual ~std::basic_ostream<char>();
        class sentry {
            bool _M_ok;
            basic_ostream<char, std::char_traits<char> > &_M_os;
        public:
            explicit sentry(basic_ostream<char, std::char_traits<char> > &__os);
            ~std::basic_ostream<char, std::char_traits<char> >::sentry();
            operator bool() const;
        };
        friend  class sentry;
        __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &))         {
            return __pf(*this);
        }


        __ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &));
        __ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        __ostream_type &operator<<(long __n);
        __ostream_type &operator<<(unsigned long __n);
        __ostream_type &operator<<(bool __n);
        __ostream_type &operator<<(short __n);
        __ostream_type &operator<<(unsigned short __n);
        __ostream_type &operator<<(int __n);
        __ostream_type &operator<<(unsigned int __n);
        __ostream_type &operator<<(long long __n);
        __ostream_type &operator<<(unsigned long long __n);
        __ostream_type &operator<<(double __f);
        __ostream_type &operator<<(float __f);
        __ostream_type &operator<<(long double __f);
        __ostream_type &operator<<(const void *__p);
        __ostream_type &operator<<(__streambuf_type *__sb);
        __ostream_type &put(char_type __c);
        void _M_write(const char_type *__s, streamsize __n);
        __ostream_type &write(const char_type *__s, streamsize __n);
        __ostream_type &flush();
        pos_type tellp();
        __ostream_type &seekp(pos_type);
        __ostream_type &seekp(off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        template <typename _ValueT = long> __ostream_type &_M_insert(long __v)template <typename _ValueT = unsigned long> __ostream_type &_M_insert(unsigned long __v)template <typename _ValueT = bool> __ostream_type &_M_insert(bool __v)template <typename _ValueT = long long> __ostream_type &_M_insert(long long __v)template <typename _ValueT = unsigned long long> __ostream_type &_M_insert(unsigned long long __v)template <typename _ValueT = double> __ostream_type &_M_insert(double __v)template <typename _ValueT = long double> __ostream_type &_M_insert(long double __v)template <typename _ValueT = const void *> __ostream_type &_M_insert(const void *__v)template <typename _ValueT> __ostream_type &_M_insert(_ValueT __v);
    };
    class basic_ostream : virtual public basic_ios<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t> > __ios_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t> > __ostream_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_put_type;
        typedef ctype<wchar_t> __ctype_type;
        explicit basic_ostream(__streambuf_type *__sb);
        virtual ~std::basic_ostream<wchar_t>();
        class sentry {
            bool _M_ok;
            basic_ostream<wchar_t, std::char_traits<wchar_t> > &_M_os;
        public:
            explicit sentry(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__os);
            ~std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::sentry();
            operator bool() const;
        };
        friend  class sentry;
        __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &));
        __ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &));
        __ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        __ostream_type &operator<<(long __n);
        __ostream_type &operator<<(unsigned long __n);
        __ostream_type &operator<<(bool __n);
        __ostream_type &operator<<(short __n);
        __ostream_type &operator<<(unsigned short __n);
        __ostream_type &operator<<(int __n);
        __ostream_type &operator<<(unsigned int __n);
        __ostream_type &operator<<(long long __n);
        __ostream_type &operator<<(unsigned long long __n);
        __ostream_type &operator<<(double __f);
        __ostream_type &operator<<(float __f);
        __ostream_type &operator<<(long double __f);
        __ostream_type &operator<<(const void *__p);
        __ostream_type &operator<<(__streambuf_type *__sb);
        __ostream_type &put(char_type __c);
        void _M_write(const char_type *__s, streamsize __n);
        __ostream_type &write(const char_type *__s, streamsize __n);
        __ostream_type &flush();
        pos_type tellp();
        __ostream_type &seekp(pos_type);
        __ostream_type &seekp(off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        template <typename _ValueT = long> __ostream_type &_M_insert(long __v)template <typename _ValueT = unsigned long> __ostream_type &_M_insert(unsigned long __v)template <typename _ValueT = bool> __ostream_type &_M_insert(bool __v)template <typename _ValueT = long long> __ostream_type &_M_insert(long long __v)template <typename _ValueT = unsigned long long> __ostream_type &_M_insert(unsigned long long __v)template <typename _ValueT = double> __ostream_type &_M_insert(double __v)template <typename _ValueT = long double> __ostream_type &_M_insert(long double __v)template <typename _ValueT = const void *> __ostream_type &_M_insert(const void *__v)template <typename _ValueT> __ostream_type &_M_insert(_ValueT __v);
    };
}
namespace std {
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_istream : virtual public basic_ios<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
        typedef basic_ios<char, std::char_traits<char> > __ios_type;
        typedef basic_istream<char, std::char_traits<char> > __istream_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char> > > __num_get_type;
        typedef ctype<char> __ctype_type;
    protected:
        streamsize _M_gcount;
    public:
        explicit basic_istream(__streambuf_type *__sb);
        virtual ~std::basic_istream<char>();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<char> traits_type;
            typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
            typedef basic_istream<char, std::char_traits<char> > __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<char>::int_type __int_type;
            explicit sentry(basic_istream<char, std::char_traits<char> > &__is, bool __noskipws);
            operator bool() const;
        };
        friend  class sentry;
        __istream_type &operator>>(__istream_type &(*__pf)(__istream_type &));
        __istream_type &operator>>(__ios_type &(*__pf)(__ios_type &));
        __istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        __istream_type &operator>>(bool &__n);
        __istream_type &operator>>(short &__n);
        __istream_type &operator>>(unsigned short &__n);
        __istream_type &operator>>(int &__n);
        __istream_type &operator>>(unsigned int &__n);
        __istream_type &operator>>(long &__n);
        __istream_type &operator>>(unsigned long &__n);
        __istream_type &operator>>(long long &__n);
        __istream_type &operator>>(unsigned long long &__n);
        __istream_type &operator>>(float &__f);
        __istream_type &operator>>(double &__f);
        __istream_type &operator>>(long double &__f);
        __istream_type &operator>>(void *&__p);
        __istream_type &operator>>(__streambuf_type *__sb);
        streamsize gcount() const;
        int_type get();
        __istream_type &get(char_type &__c);
        __istream_type &get(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &get(char_type *__s, streamsize __n);
        __istream_type &get(__streambuf_type &__sb, char_type __delim);
        __istream_type &get(__streambuf_type &__sb);
        __istream_type &getline(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &getline(char_type *__s, streamsize __n);
        __istream_type &ignore(streamsize __n, int_type __delim);
        __istream_type &ignore(streamsize __n);
        __istream_type &ignore();
        int_type peek();
        __istream_type &read(char_type *__s, streamsize __n);
        streamsize readsome(char_type *__s, streamsize __n);
        __istream_type &putback(char_type __c);
        __istream_type &unget();
        int sync();
        pos_type tellg();
        __istream_type &seekg(pos_type);
        __istream_type &seekg(off_type, ios_base::seekdir);
    protected:
        basic_istream();
        template <typename _ValueT = unsigned short> __istream_type &_M_extract(unsigned short &__v)template <typename _ValueT = unsigned int> __istream_type &_M_extract(unsigned int &__v)template <typename _ValueT = long> __istream_type &_M_extract(long &__v)template <typename _ValueT = unsigned long> __istream_type &_M_extract(unsigned long &__v)template <typename _ValueT = bool> __istream_type &_M_extract(bool &__v)template <typename _ValueT = long long> __istream_type &_M_extract(long long &__v)template <typename _ValueT = unsigned long long> __istream_type &_M_extract(unsigned long long &__v)template <typename _ValueT = float> __istream_type &_M_extract(float &__v)template <typename _ValueT = double> __istream_type &_M_extract(double &__v)template <typename _ValueT = long double> __istream_type &_M_extract(long double &__v)template <typename _ValueT = void *> __istream_type &_M_extract(void *&__v)template <typename _ValueT> __istream_type &_M_extract(_ValueT &__v);
    }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_istream : virtual public basic_ios<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t> > __ios_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_get_type;
        typedef ctype<wchar_t> __ctype_type;
    protected:
        streamsize _M_gcount;
    public:
        explicit basic_istream(__streambuf_type *__sb);
        virtual ~std::basic_istream<wchar_t>();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
            typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<wchar_t>::int_type __int_type;
            explicit sentry(basic_istream<wchar_t, std::char_traits<wchar_t> > &__is, bool __noskipws);
            operator bool() const;
        };
        friend  class sentry;
        __istream_type &operator>>(__istream_type &(*__pf)(__istream_type &));
        __istream_type &operator>>(__ios_type &(*__pf)(__ios_type &));
        __istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        __istream_type &operator>>(bool &__n);
        __istream_type &operator>>(short &__n);
        __istream_type &operator>>(unsigned short &__n);
        __istream_type &operator>>(int &__n);
        __istream_type &operator>>(unsigned int &__n);
        __istream_type &operator>>(long &__n);
        __istream_type &operator>>(unsigned long &__n);
        __istream_type &operator>>(long long &__n);
        __istream_type &operator>>(unsigned long long &__n);
        __istream_type &operator>>(float &__f);
        __istream_type &operator>>(double &__f);
        __istream_type &operator>>(long double &__f);
        __istream_type &operator>>(void *&__p);
        __istream_type &operator>>(__streambuf_type *__sb);
        streamsize gcount() const;
        int_type get();
        __istream_type &get(char_type &__c);
        __istream_type &get(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &get(char_type *__s, streamsize __n);
        __istream_type &get(__streambuf_type &__sb, char_type __delim);
        __istream_type &get(__streambuf_type &__sb);
        __istream_type &getline(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &getline(char_type *__s, streamsize __n);
        __istream_type &ignore(streamsize __n, int_type __delim);
        __istream_type &ignore(streamsize __n);
        __istream_type &ignore();
        int_type peek();
        __istream_type &read(char_type *__s, streamsize __n);
        streamsize readsome(char_type *__s, streamsize __n);
        __istream_type &putback(char_type __c);
        __istream_type &unget();
        int sync();
        pos_type tellg();
        __istream_type &seekg(pos_type);
        __istream_type &seekg(off_type, ios_base::seekdir);
    protected:
        basic_istream();
        template <typename _ValueT = unsigned short> __istream_type &_M_extract(unsigned short &__v)template <typename _ValueT = unsigned int> __istream_type &_M_extract(unsigned int &__v)template <typename _ValueT = long> __istream_type &_M_extract(long &__v)template <typename _ValueT = unsigned long> __istream_type &_M_extract(unsigned long &__v)template <typename _ValueT = bool> __istream_type &_M_extract(bool &__v)template <typename _ValueT = long long> __istream_type &_M_extract(long long &__v)template <typename _ValueT = unsigned long long> __istream_type &_M_extract(unsigned long long &__v)template <typename _ValueT = float> __istream_type &_M_extract(float &__v)template <typename _ValueT = double> __istream_type &_M_extract(double &__v)template <typename _ValueT = long double> __istream_type &_M_extract(long double &__v)template <typename _ValueT = void *> __istream_type &_M_extract(void *&__v)template <typename _ValueT> __istream_type &_M_extract(_ValueT &__v);
    }
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> > __num_get_type;
        typedef ctype<_CharT> __ctype_type;
    protected:
        streamsize _M_gcount;
    public:
        explicit basic_istream<_CharT, _Traits>(__streambuf_type *__sb) : _M_gcount(streamsize(0))         {
            this->init(__sb);
        }


        virtual ~basic_istream<_CharT, _Traits>()         {
            this->_M_gcount = streamsize(0);
        }


        class sentry;
        friend  class sentry;
        __istream_type &operator>>(__istream_type &(*__pf)(__istream_type &))         {
            return __pf(*this);
        }


        __istream_type &operator>>(__ios_type &(*__pf)(__ios_type &))         {
            __pf(*this);
            return *this;
        }


        __istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &))         {
            __pf(*this);
            return *this;
        }


        __istream_type &operator>>(bool &__n)         {
            return _M_extract(__n);
        }


        __istream_type &operator>>(short &__n);
        __istream_type &operator>>(unsigned short &__n)         {
            return _M_extract(__n);
        }


        __istream_type &operator>>(int &__n);
        __istream_type &operator>>(unsigned int &__n)         {
            return _M_extract(__n);
        }


        __istream_type &operator>>(long &__n)         {
            return _M_extract(__n);
        }


        __istream_type &operator>>(unsigned long &__n)         {
            return _M_extract(__n);
        }


        __istream_type &operator>>(long long &__n)         {
            return _M_extract(__n);
        }


        __istream_type &operator>>(unsigned long long &__n)         {
            return _M_extract(__n);
        }


        __istream_type &operator>>(float &__f)         {
            return _M_extract(__f);
        }


        __istream_type &operator>>(double &__f)         {
            return _M_extract(__f);
        }


        __istream_type &operator>>(long double &__f)         {
            return _M_extract(__f);
        }


        __istream_type &operator>>(void *&__p)         {
            return _M_extract(__p);
        }


        __istream_type &operator>>(__streambuf_type *__sb);
        streamsize gcount() const         {
            return this->_M_gcount;
        }


        int_type get();
        __istream_type &get(char_type &__c);
        __istream_type &get(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &get(char_type *__s, streamsize __n)         {
            return this->get(__s, __n, this->widen('\n'));
        }


        __istream_type &get(__streambuf_type &__sb, char_type __delim);
        __istream_type &get(__streambuf_type &__sb)         {
            return this->get(__sb, this->widen('\n'));
        }


        __istream_type &getline(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &getline(char_type *__s, streamsize __n)         {
            return this->getline(__s, __n, this->widen('\n'));
        }


        __istream_type &ignore(streamsize __n, int_type __delim);
        __istream_type &ignore(streamsize __n);
        __istream_type &ignore();
        int_type peek();
        __istream_type &read(char_type *__s, streamsize __n);
        streamsize readsome(char_type *__s, streamsize __n);
        __istream_type &putback(char_type __c);
        __istream_type &unget();
        int sync();
        pos_type tellg();
        __istream_type &seekg(pos_type);
        __istream_type &seekg(off_type, ios_base::seekdir);
    protected:
        basic_istream<_CharT, _Traits>() : _M_gcount(streamsize(0))         {
            this->init(0);
        }


        template <typename _ValueT> __istream_type &_M_extract(_ValueT &__v);
    };
    basic_istream<char> &getline(char_type *__s, streamsize __n, char_type __delim);
    basic_istream<char> &ignore(streamsize __n);
    basic_istream<char> &ignore(streamsize __n, int_type __delim);
    basic_istream<wchar_t> &getline(char_type *__s, streamsize __n, char_type __delim);
    basic_istream<wchar_t> &ignore(streamsize __n);
    basic_istream<wchar_t> &ignore(streamsize __n, int_type __delim);
    class sentry {
        bool _M_ok;
    public:
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::__ctype_type __ctype_type;
        typedef typename _Traits::int_type __int_type;
        explicit sentry(basic_istream<_CharT, _Traits> &__is, bool __noskipws = false);
        operator bool() const         {
            return this->_M_ok;
        }


    };
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> basic_istream<char, std::char_traits<char> > &operator>>(basic_istream<char, std::char_traits<char> > &__in, char &__c)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, wchar_t &__c)template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c);
    template <class _Traits = std::char_traits<char>> inline basic_istream<char, std::char_traits<char> > &operator>>(basic_istream<char, std::char_traits<char> > &__in, unsigned char &__c)template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char &__c)     {
        return (__in >> reinterpret_cast<char &>(__c));
    }

;
    template <class _Traits = std::char_traits<char>> inline basic_istream<char, std::char_traits<char> > &operator>>(basic_istream<char, std::char_traits<char> > &__in, signed char &__c)template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char &__c)     {
        return (__in >> reinterpret_cast<char &>(__c));
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> basic_istream<char> &operator>>(basic_istream<char> &__in, char *__s)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, wchar_t *__s)template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT *__s);
    basic_istream<char> &operator>>(basic_istream<char> &__in, char *__s);
    template <class _Traits = std::char_traits<char>> inline basic_istream<char, std::char_traits<char> > &operator>>(basic_istream<char, std::char_traits<char> > &__in, unsigned char *__s)template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char *__s)     {
        return (__in >> reinterpret_cast<char *>(__s));
    }

;
    template <class _Traits = std::char_traits<char>> inline basic_istream<char, std::char_traits<char> > &operator>>(basic_istream<char, std::char_traits<char> > &__in, signed char *__s)template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char *__s)     {
        return (__in >> reinterpret_cast<char *>(__s));
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> class basic_iostream : public basic_istream<char, std::char_traits<char> >, public basic_ostream<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_istream<char, std::char_traits<char> > __istream_type;
        typedef basic_ostream<char, std::char_traits<char> > __ostream_type;
        explicit basic_iostream(basic_streambuf<char, std::char_traits<char> > *__sb);
        virtual ~std::basic_iostream<char>();
    protected:
        basic_iostream();
    }
template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> class basic_iostream : public basic_istream<wchar_t, std::char_traits<wchar_t> >, public basic_ostream<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t> > __ostream_type;
        explicit basic_iostream(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        virtual ~std::basic_iostream<wchar_t>();
    protected:
        basic_iostream();
    }
template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream : public basic_istream<_CharT, _Traits>, public basic_ostream<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        explicit basic_iostream<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : __istream_type(__sb), __ostream_type(__sb)         {
        }


        virtual ~basic_iostream<_CharT, _Traits>()         {
        }


    protected:
        basic_iostream<_CharT, _Traits>() : __istream_type(), __ostream_type()         {
        }


    };
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> basic_istream<char, std::char_traits<char> > &ws(basic_istream<char, std::char_traits<char> > &__in)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &ws(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in)template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__is);
}
namespace std {
    sentry(basic_istream<_CharT, _Traits> &__in, bool __noskip = false) : _M_ok(false)     {
        ios_base::iostate __err = ios_base::goodbit;
        if (__in.good()) {
            if (__in.tie())
                __in.tie()->flush();
            if (!__noskip && bool(__in.flags() & ios_base::skipws)) {
                const __int_type __eof = traits_type::eof();
                __streambuf_type *__sb = __in.rdbuf();
                __int_type __c = __sb->sgetc();
                const __ctype_type &__ct = __check_facet(__in._M_ctype);
                while (!traits_type::eq_int_type(__c, __eof) && __ct.is(ctype_base::space, traits_type::to_char_type(__c)))
                    __c = __sb->snextc();
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            }
        }
        if (__in.good() && __err == ios_base::goodbit)
            this->_M_ok = true;
        else {
            __err |= ios_base::failbit;
            __in.setstate(__err);
        }
    }


    template <typename _ValueT> basic_istream<_CharT, _Traits> &_M_extract(_ValueT &__v)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __v);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }

;
    basic_istream<_CharT, _Traits> &operator>>(short &__n)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const __num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<short>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<short>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__max;
                } else
                    __n = short(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }


    basic_istream<_CharT, _Traits> &operator>>(int &__n)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const __num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<int>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<int>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__max;
                } else
                    __n = int(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }


    basic_istream<_CharT, _Traits> &operator>>(__streambuf_type *__sbout)     {
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb && __sbout) {
            try {
                bool __ineof;
                if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
                    __err |= ios_base::failbit;
                if (__ineof)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::failbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbout)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }


    typename basic_istream<_CharT, _Traits>::int_type get()     {
        const int_type __eof = traits_type::eof();
        int_type __c = __eof;
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                __c = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__c, __eof))
                    this->_M_gcount = 1;
                else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return __c;
    }


    basic_istream<_CharT, _Traits> &get(char_type &__c)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const int_type __cb = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__cb, traits_type::eof())) {
                    this->_M_gcount = 1;
                    __c = traits_type::to_char_type(__cb);
                } else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }


    basic_istream<_CharT, _Traits> &get(char_type *__s, streamsize __n, char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const int_type __idelim = traits_type::to_int_type(__delim);
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        ++this->_M_gcount;
                        __c = __sb->snextc();
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }


    basic_istream<_CharT, _Traits> &get(__streambuf_type &__sb, char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const int_type __idelim = traits_type::to_int_type(__delim);
                const int_type __eof = traits_type::eof();
                __streambuf_type *__this_sb = this->rdbuf();
                int_type __c = __this_sb->sgetc();
                char_type __c2 = traits_type::to_char_type(__c);
                while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim) && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
                    {
                        ++this->_M_gcount;
                        __c = __this_sb->snextc();
                        __c2 = traits_type::to_char_type(__c);
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }


    basic_istream<_CharT, _Traits> &getline(char_type *__s, streamsize __n, char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const int_type __idelim = traits_type::to_int_type(__delim);
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                        ++this->_M_gcount;
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                else {
                    if (traits_type::eq_int_type(__c, __idelim)) {
                        __sb->sbumpc();
                        ++this->_M_gcount;
                    } else
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }


    basic_istream<_CharT, _Traits> &ignore()     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
                    __err |= ios_base::eofbit;
                else
                    this->_M_gcount = 1;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }


    basic_istream<_CharT, _Traits> &ignore(streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__large_ignore)
                    this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }


    basic_istream<_CharT, _Traits> &ignore(streamsize __n, int_type __delim)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__large_ignore)
                    this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                else if (traits_type::eq_int_type(__c, __delim)) {
                    if (this->_M_gcount < __gnu_cxx::__numeric_traits<streamsize>::__max)
                        ++this->_M_gcount;
                    __sb->sbumpc();
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }


    typename basic_istream<_CharT, _Traits>::int_type peek()     {
        int_type __c = traits_type::eof();
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                __c = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__c, traits_type::eof()))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __c;
    }


    basic_istream<_CharT, _Traits> &read(char_type *__s, streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                this->_M_gcount = this->rdbuf()->sgetn(__s, __n);
                if (this->_M_gcount != __n)
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }


    streamsize readsome(char_type *__s, streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const streamsize __num = this->rdbuf()->in_avail();
                if (__num > 0)
                    this->_M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
                else if (__num == -1)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return this->_M_gcount;
    }


    basic_istream<_CharT, _Traits> &putback(char_type __c)     {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }


    basic_istream<_CharT, _Traits> &unget()     {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }


    int sync()     {
        int __ret = -1;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                __streambuf_type *__sb = this->rdbuf();
                if (__sb) {
                    if (__sb->pubsync() == -1)
                        __err |= ios_base::badbit;
                    else
                        __ret = 0;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __ret;
    }


    typename basic_istream<_CharT, _Traits>::pos_type tellg()     {
        pos_type __ret = pos_type(-1);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                if (!this->fail())
                    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        return __ret;
    }


    basic_istream<_CharT, _Traits> &seekg(pos_type __pos)     {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::in);
                    if (__p == pos_type(off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }


    basic_istream<_CharT, _Traits> &seekg(off_type __off, ios_base::seekdir __dir)     {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::in);
                    if (__p == pos_type(off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }


    template <typename _CharT = char, typename _Traits = std::char_traits<char>> basic_istream<char, std::char_traits<char> > &operator>>(basic_istream<char, std::char_traits<char> > &__in, char &__c)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, wchar_t &__c)template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::int_type __int_type;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __int_type __cb = __in.rdbuf()->sbumpc();
                if (!_Traits::eq_int_type(__cb, _Traits::eof()))
                    __c = _Traits::to_char_type(__cb);
                else
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
            if (__err)
                __in.setstate(__err);
        }
        return __in;
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> basic_istream<char> &operator>>(basic_istream<char> &__in, char *__s)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &operator>>(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in, wchar_t *__s)template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT *__s)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename _Traits::int_type int_type;
        typedef _CharT char_type;
        typedef ctype<_CharT> __ctype_type;
        streamsize __extracted = 0;
        ios_base::iostate __err = ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                streamsize __num = __in.width();
                if (__num <= 0)
                    __num = __gnu_cxx::__numeric_traits<streamsize>::__max;
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const int_type __eof = _Traits::eof();
                __streambuf_type *__sb = __in.rdbuf();
                int_type __c = __sb->sgetc();
                while (__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof) && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        *__s++ = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __sb->snextc();
                    }
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                *__s = char_type();
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }

;
    template <typename _CharT = char, typename _Traits = std::char_traits<char>> basic_istream<char, std::char_traits<char> > &ws(basic_istream<char, std::char_traits<char> > &__in)template <typename _CharT = wchar_t, typename _Traits = std::char_traits<wchar_t>> basic_istream<wchar_t, std::char_traits<wchar_t> > &ws(basic_istream<wchar_t, std::char_traits<wchar_t> > &__in)template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__in)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename __istream_type::int_type __int_type;
        typedef ctype<_CharT> __ctype_type;
        const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
        const __int_type __eof = _Traits::eof();
        __streambuf_type *__sb = __in.rdbuf();
        __int_type __c = __sb->sgetc();
        while (!_Traits::eq_int_type(__c, __eof) && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
            __c = __sb->snextc();
        if (_Traits::eq_int_type(__c, __eof))
            __in.setstate(ios_base::eofbit);
        return __in;
    }

;
    class basic_istream : virtual public basic_ios<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
        typedef basic_ios<char, std::char_traits<char> > __ios_type;
        typedef basic_istream<char, std::char_traits<char> > __istream_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char> > > __num_get_type;
        typedef ctype<char> __ctype_type;
    protected:
        streamsize _M_gcount;
    public:
        explicit basic_istream(__streambuf_type *__sb);
        virtual ~std::basic_istream<char>();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<char> traits_type;
            typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
            typedef basic_istream<char, std::char_traits<char> > __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<char>::int_type __int_type;
            explicit sentry(basic_istream<char, std::char_traits<char> > &__is, bool __noskipws);
            operator bool() const;
        };
        friend  class sentry;
        __istream_type &operator>>(__istream_type &(*__pf)(__istream_type &));
        __istream_type &operator>>(__ios_type &(*__pf)(__ios_type &));
        __istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        __istream_type &operator>>(bool &__n);
        __istream_type &operator>>(short &__n);
        __istream_type &operator>>(unsigned short &__n);
        __istream_type &operator>>(int &__n);
        __istream_type &operator>>(unsigned int &__n);
        __istream_type &operator>>(long &__n);
        __istream_type &operator>>(unsigned long &__n);
        __istream_type &operator>>(long long &__n);
        __istream_type &operator>>(unsigned long long &__n);
        __istream_type &operator>>(float &__f);
        __istream_type &operator>>(double &__f);
        __istream_type &operator>>(long double &__f);
        __istream_type &operator>>(void *&__p);
        __istream_type &operator>>(__streambuf_type *__sb);
        streamsize gcount() const;
        int_type get();
        __istream_type &get(char_type &__c);
        __istream_type &get(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &get(char_type *__s, streamsize __n);
        __istream_type &get(__streambuf_type &__sb, char_type __delim);
        __istream_type &get(__streambuf_type &__sb);
        __istream_type &getline(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &getline(char_type *__s, streamsize __n);
        __istream_type &ignore(streamsize __n, int_type __delim);
        __istream_type &ignore(streamsize __n);
        __istream_type &ignore();
        int_type peek();
        __istream_type &read(char_type *__s, streamsize __n);
        streamsize readsome(char_type *__s, streamsize __n);
        __istream_type &putback(char_type __c);
        __istream_type &unget();
        int sync();
        pos_type tellg();
        __istream_type &seekg(pos_type);
        __istream_type &seekg(off_type, ios_base::seekdir);
    protected:
        basic_istream();
        template <typename _ValueT = unsigned short> __istream_type &_M_extract(unsigned short &__v)template <typename _ValueT = unsigned int> __istream_type &_M_extract(unsigned int &__v)template <typename _ValueT = long> __istream_type &_M_extract(long &__v)template <typename _ValueT = unsigned long> __istream_type &_M_extract(unsigned long &__v)template <typename _ValueT = bool> __istream_type &_M_extract(bool &__v)template <typename _ValueT = long long> __istream_type &_M_extract(long long &__v)template <typename _ValueT = unsigned long long> __istream_type &_M_extract(unsigned long long &__v)template <typename _ValueT = float> __istream_type &_M_extract(float &__v)template <typename _ValueT = double> __istream_type &_M_extract(double &__v)template <typename _ValueT = long double> __istream_type &_M_extract(long double &__v)template <typename _ValueT = void *> __istream_type &_M_extract(void *&__v)template <typename _ValueT> __istream_type &_M_extract(_ValueT &__v);
    };
    class basic_iostream : public basic_istream<char, std::char_traits<char> >, public basic_ostream<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_istream<char, std::char_traits<char> > __istream_type;
        typedef basic_ostream<char, std::char_traits<char> > __ostream_type;
        explicit basic_iostream(basic_streambuf<char, std::char_traits<char> > *__sb);
        virtual ~std::basic_iostream<char>();
    protected:
        basic_iostream();
    };
    class basic_istream : virtual public basic_ios<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t> > __ios_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_get_type;
        typedef ctype<wchar_t> __ctype_type;
    protected:
        streamsize _M_gcount;
    public:
        explicit basic_istream(__streambuf_type *__sb);
        virtual ~std::basic_istream<wchar_t>();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
            typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<wchar_t>::int_type __int_type;
            explicit sentry(basic_istream<wchar_t, std::char_traits<wchar_t> > &__is, bool __noskipws);
            operator bool() const;
        };
        friend  class sentry;
        __istream_type &operator>>(__istream_type &(*__pf)(__istream_type &));
        __istream_type &operator>>(__ios_type &(*__pf)(__ios_type &));
        __istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        __istream_type &operator>>(bool &__n);
        __istream_type &operator>>(short &__n);
        __istream_type &operator>>(unsigned short &__n);
        __istream_type &operator>>(int &__n);
        __istream_type &operator>>(unsigned int &__n);
        __istream_type &operator>>(long &__n);
        __istream_type &operator>>(unsigned long &__n);
        __istream_type &operator>>(long long &__n);
        __istream_type &operator>>(unsigned long long &__n);
        __istream_type &operator>>(float &__f);
        __istream_type &operator>>(double &__f);
        __istream_type &operator>>(long double &__f);
        __istream_type &operator>>(void *&__p);
        __istream_type &operator>>(__streambuf_type *__sb);
        streamsize gcount() const;
        int_type get();
        __istream_type &get(char_type &__c);
        __istream_type &get(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &get(char_type *__s, streamsize __n);
        __istream_type &get(__streambuf_type &__sb, char_type __delim);
        __istream_type &get(__streambuf_type &__sb);
        __istream_type &getline(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &getline(char_type *__s, streamsize __n);
        __istream_type &ignore(streamsize __n, int_type __delim);
        __istream_type &ignore(streamsize __n);
        __istream_type &ignore();
        int_type peek();
        __istream_type &read(char_type *__s, streamsize __n);
        streamsize readsome(char_type *__s, streamsize __n);
        __istream_type &putback(char_type __c);
        __istream_type &unget();
        int sync();
        pos_type tellg();
        __istream_type &seekg(pos_type);
        __istream_type &seekg(off_type, ios_base::seekdir);
    protected:
        basic_istream();
        template <typename _ValueT = unsigned short> __istream_type &_M_extract(unsigned short &__v)template <typename _ValueT = unsigned int> __istream_type &_M_extract(unsigned int &__v)template <typename _ValueT = long> __istream_type &_M_extract(long &__v)template <typename _ValueT = unsigned long> __istream_type &_M_extract(unsigned long &__v)template <typename _ValueT = bool> __istream_type &_M_extract(bool &__v)template <typename _ValueT = long long> __istream_type &_M_extract(long long &__v)template <typename _ValueT = unsigned long long> __istream_type &_M_extract(unsigned long long &__v)template <typename _ValueT = float> __istream_type &_M_extract(float &__v)template <typename _ValueT = double> __istream_type &_M_extract(double &__v)template <typename _ValueT = long double> __istream_type &_M_extract(long double &__v)template <typename _ValueT = void *> __istream_type &_M_extract(void *&__v)template <typename _ValueT> __istream_type &_M_extract(_ValueT &__v);
    };
    class basic_iostream : public basic_istream<wchar_t, std::char_traits<wchar_t> >, public basic_ostream<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t> > __ostream_type;
        explicit basic_iostream(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        virtual ~std::basic_iostream<wchar_t>();
    protected:
        basic_iostream();
    };
}
namespace std {
    extern istream cin;
    extern ostream cout;
    extern ostream cerr;
    extern ostream clog;
    extern wistream wcin;
    extern wostream wcout;
    extern wostream wcerr;
    extern wostream wclog;
    static ios_base::Init __ioinit;
}
namespace std {
    template <typename _Tp, typename _CharT = char, typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t> class istream_iterator : public iterator<std::input_iterator_tag, _Tp, _Dist, const _Tp *, const _Tp &> {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef basic_istream<_CharT, _Traits> istream_type;
    private:
        istream_type *_M_stream;
        _Tp _M_value;
        bool _M_ok;
    public:
        istream_iterator<_Tp, _CharT, _Traits, _Dist>() : _M_stream(0), _M_value(), _M_ok(false)         {
        }


        istream_iterator<_Tp, _CharT, _Traits, _Dist>(istream_type &__s) : _M_stream(& __s)         {
            this->_M_read();
        }


        istream_iterator<_Tp, _CharT, _Traits, _Dist>(const istream_iterator<_Tp, _CharT, _Traits, _Dist> &__obj) : _M_stream(__obj._M_stream), _M_value(__obj._M_value), _M_ok(__obj._M_ok)         {
        }


        const _Tp &operator*() const         {
            ;
            return this->_M_value;
        }


        const _Tp *operator->() const         {
            return & (this->operator*());
        }


        istream_iterator<_Tp, _CharT, _Traits, _Dist> &operator++()         {
            ;
            this->_M_read();
            return *this;
        }


        istream_iterator<_Tp, _CharT, _Traits, _Dist> operator++(int)         {
            ;
            istream_iterator<_Tp, _CharT, _Traits, _Dist> __tmp = *this;
            this->_M_read();
            return __tmp;
        }


        bool _M_equal(const istream_iterator<_Tp, _CharT, _Traits, _Dist> &__x) const         {
            return (this->_M_ok == __x._M_ok) && (!this->_M_ok || this->_M_stream == __x._M_stream);
        }


    private:
        void _M_read()         {
            this->_M_ok = (this->_M_stream && *this->_M_stream) ? true : false;
            if (this->_M_ok) {
                *this->_M_stream >> this->_M_value;
                this->_M_ok = *this->_M_stream ? true : false;
            }
        }


    };
    template <typename _Tp, typename _CharT, typename _Traits, typename _Dist> inline bool operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist> &__x, const istream_iterator<_Tp, _CharT, _Traits, _Dist> &__y)     {
        return __x._M_equal(__y);
    }

;
    template <class _Tp, class _CharT, class _Traits, class _Dist> inline bool operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist> &__x, const istream_iterator<_Tp, _CharT, _Traits, _Dist> &__y)     {
        return !__x._M_equal(__y);
    }

;
    template <typename _Tp, typename _CharT = char, typename _Traits = char_traits<_CharT>> class ostream_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef basic_ostream<_CharT, _Traits> ostream_type;
    private:
        ostream_type *_M_stream;
        const _CharT *_M_string;
    public:
        ostream_iterator<_Tp, _CharT, _Traits>(ostream_type &__s) : _M_stream(& __s), _M_string(0)         {
        }


        ostream_iterator<_Tp, _CharT, _Traits>(ostream_type &__s, const _CharT *__c) : _M_stream(& __s), _M_string(__c)         {
        }


        ostream_iterator<_Tp, _CharT, _Traits>(const ostream_iterator<_Tp, _CharT, _Traits> &__obj) : _M_stream(__obj._M_stream), _M_string(__obj._M_string)         {
        }


        ostream_iterator<_Tp, _CharT, _Traits> &operator=(const _Tp &__value)         {
            ;
            *this->_M_stream << __value;
            if (this->_M_string)
                *this->_M_stream << this->_M_string;
            return *this;
        }


        ostream_iterator<_Tp, _CharT, _Traits> &operator*()         {
            return *this;
        }


        ostream_iterator<_Tp, _CharT, _Traits> &operator++()         {
            return *this;
        }


        ostream_iterator<_Tp, _CharT, _Traits> &operator++(int)         {
            return *this;
        }


    };
}
namespace std {
    namespace rel_ops {
        template <class _Tp> inline bool operator!=(const _Tp &__x, const _Tp &__y)         {
            return !(__x == __y);
        }

;
        template <class _Tp> inline bool operator>(const _Tp &__x, const _Tp &__y)         {
            return __y < __x;
        }

;
        template <class _Tp> inline bool operator<=(const _Tp &__x, const _Tp &__y)         {
            return !(__y < __x);
        }

;
        template <class _Tp> inline bool operator>=(const _Tp &__x, const _Tp &__y)         {
            return !(__x < __y);
        }

;
    }
}
extern "C" {
    enum  {
        P_ALL,
        P_PID,
        P_PGID
    } typedef idtype_t;
    union wait {
        int w_status;
        struct {
            unsigned int __w_termsig : 7;
            unsigned int __w_coredump : 1;
            unsigned int __w_retcode : 8;
            unsigned int : 16;
        } __wait_terminated;
        struct {
            unsigned int __w_stopval : 8;
            unsigned int __w_stopsig : 8;
            unsigned int : 16;
        } __wait_stopped;
    };
    struct {
        int quot;
        int rem;
    } typedef div_t;
    struct {
        long quot;
        long rem;
    } typedef ldiv_t;
    struct {
        long long quot;
        long long rem;
    } typedef lldiv_t;
    extern size_t __ctype_get_mb_cur_max() throw();
    extern double atof(const char *__nptr) throw() __attribute__((nonnull(0))) __attribute__((pure));
    extern int atoi(const char *__nptr) throw() __attribute__((nonnull(0))) __attribute__((pure));
    extern long atol(const char *__nptr) throw() __attribute__((nonnull(0))) __attribute__((pure));
    extern long long atoll(const char *__nptr) throw() __attribute__((nonnull(0))) __attribute__((pure));
    extern double strtod(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(0)));
    extern float strtof(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(0)));
    extern long double strtold(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(0)));
    extern long strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(0)));
    extern unsigned long strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(0)));
    extern long long strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(0)));
    extern unsigned long long strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(0)));
    extern long long strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(0)));
    extern unsigned long long strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(0)));
    extern long strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, __locale_t __loc) throw() __attribute__((nonnull(0, 3)));
    extern unsigned long strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, __locale_t __loc) throw() __attribute__((nonnull(0, 3)));
    extern long long strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, __locale_t __loc) throw() __attribute__((nonnull(0, 3)));
    extern unsigned long long strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, __locale_t __loc) throw() __attribute__((nonnull(0, 3)));
    extern double strtod_l(const char *__restrict __nptr, char **__restrict __endptr, __locale_t __loc) throw() __attribute__((nonnull(0, 2)));
    extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr, __locale_t __loc) throw() __attribute__((nonnull(0, 2)));
    extern long double strtold_l(const char *__restrict __nptr, char **__restrict __endptr, __locale_t __loc) throw() __attribute__((nonnull(0, 2)));
    extern char *l64a(long __n) throw();
    extern long a64l(const char *__s) throw() __attribute__((nonnull(0))) __attribute__((pure));
    extern "C" {
        typedef __u_char u_char;
        typedef __u_short u_short;
        typedef __u_int u_int;
        typedef __u_long u_long;
        typedef __quad_t quad_t;
        typedef __u_quad_t u_quad_t;
        typedef __fsid_t fsid_t;
        typedef __loff_t loff_t;
        typedef __ino_t ino_t;
        typedef __ino64_t ino64_t;
        typedef __dev_t dev_t;
        typedef __gid_t gid_t;
        typedef __mode_t mode_t;
        typedef __nlink_t nlink_t;
        typedef __uid_t uid_t;
        typedef __off_t off_t;
        typedef __off64_t off64_t;
        typedef __id_t id_t;
        typedef __ssize_t ssize_t;
        typedef __daddr_t daddr_t;
        typedef __caddr_t caddr_t;
        typedef __key_t key_t;
        typedef __useconds_t useconds_t;
        typedef __suseconds_t suseconds_t;
        typedef unsigned long ulong;
        typedef unsigned short ushort;
        typedef unsigned int uint;
        typedef int int8_t __attribute__((mode(__QI__)));
        typedef int int16_t __attribute__((mode(__HI__)));
        typedef int int32_t __attribute__((mode(__SI__)));
        typedef int int64_t __attribute__((mode(__DI__)));
        typedef unsigned int u_int8_t __attribute__((mode(__QI__)));
        typedef unsigned int u_int16_t __attribute__((mode(__HI__)));
        typedef unsigned int u_int32_t __attribute__((mode(__SI__)));
        typedef unsigned int u_int64_t __attribute__((mode(__DI__)));
        typedef int register_t __attribute__((mode(__word__)));
        typedef int __sig_atomic_t;
        struct {
            unsigned long __val[16];
        } typedef __sigset_t;
        typedef __sigset_t sigset_t;
        typedef long __fd_mask;
        struct {
            __fd_mask fds_bits[16];
        } typedef fd_set;
        typedef __fd_mask fd_mask;
        extern "C" {
            extern int select(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, struct timeval *__restrict __timeout);
            extern int pselect(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, const struct timespec *__restrict __timeout, const __sigset_t *__restrict __sigmask);
        }
        extern "C" {
            extern unsigned int gnu_dev_major(unsigned long long __dev) throw() __attribute__((const));
            extern unsigned int gnu_dev_minor(unsigned long long __dev) throw() __attribute__((const));
            extern unsigned long long gnu_dev_makedev(unsigned int __major, unsigned int __minor) throw() __attribute__((const));
        }
        typedef __blksize_t blksize_t;
        typedef __blkcnt_t blkcnt_t;
        typedef __fsblkcnt_t fsblkcnt_t;
        typedef __fsfilcnt_t fsfilcnt_t;
        typedef __blkcnt64_t blkcnt64_t;
        typedef __fsblkcnt64_t fsblkcnt64_t;
        typedef __fsfilcnt64_t fsfilcnt64_t;
    }
    extern long random() throw();
    extern void srandom(unsigned int __seed) throw();
    extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen) throw() __attribute__((nonnull(1)));
    extern char *setstate(char *__statebuf) throw() __attribute__((nonnull(0)));
    struct random_data {
        int32_t *fptr;
        int32_t *rptr;
        int32_t *state;
        int rand_type;
        int rand_deg;
        int rand_sep;
        int32_t *end_ptr;
    };
    extern int random_r(struct random_data *__restrict __buf, int32_t *__restrict __result) throw() __attribute__((nonnull(0, 1)));
    extern int srandom_r(unsigned int __seed, struct random_data *__buf) throw() __attribute__((nonnull(1)));
    extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, size_t __statelen, struct random_data *__restrict __buf) throw() __attribute__((nonnull(1, 3)));
    extern int setstate_r(char *__restrict __statebuf, struct random_data *__restrict __buf) throw() __attribute__((nonnull(0, 1)));
    extern int rand() throw();
    extern void srand(unsigned int __seed) throw();
    extern int rand_r(unsigned int *__seed) throw();
    extern double drand48() throw();
    extern double erand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(0)));
    extern long lrand48() throw();
    extern long nrand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(0)));
    extern long mrand48() throw();
    extern long jrand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(0)));
    extern void srand48(long __seedval) throw();
    extern unsigned short *seed48(unsigned short __seed16v[3]) throw() __attribute__((nonnull(0)));
    extern void lcong48(unsigned short __param[7]) throw() __attribute__((nonnull(0)));
    struct drand48_data {
        unsigned short __x[3];
        unsigned short __old_x[3];
        unsigned short __c;
        unsigned short __init;
        unsigned long long __a;
    };
    extern int drand48_r(struct drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((nonnull(0, 1)));
    extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((nonnull(0, 1)));
    extern int lrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(0, 1)));
    extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(0, 1)));
    extern int mrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(0, 1)));
    extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(0, 1)));
    extern int srand48_r(long __seedval, struct drand48_data *__buffer) throw() __attribute__((nonnull(1)));
    extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer) throw() __attribute__((nonnull(0, 1)));
    extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer) throw() __attribute__((nonnull(0, 1)));
    extern void *malloc(size_t __size) throw() __attribute__((malloc));
    extern void *calloc(size_t __nmemb, size_t __size) throw() __attribute__((malloc));
    extern void *realloc(void *__ptr, size_t __size) throw() __attribute__((warn_unused_result));
    extern void free(void *__ptr) throw();
    extern void cfree(void *__ptr) throw();
    extern "C" {
        extern void *alloca(size_t __size) throw();
    }
    extern void *valloc(size_t __size) throw() __attribute__((malloc));
    extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size) throw() __attribute__((nonnull(0)));
    extern void *aligned_alloc(size_t __alignment, size_t __size) throw() __attribute__((malloc));
    extern void abort() throw();
    extern int atexit(void (*__func)()) throw() __attribute__((nonnull(0)));
    extern "C++" int at_quick_exit(void (*__func)()) throw() asm("at_quick_exit") __attribute__((nonnull(0)))
    extern int on_exit(void (*__func)(int, void *), void *__arg) throw() __attribute__((nonnull(0)));
    extern void exit(int __status) throw();
    extern void quick_exit(int __status) throw();
    extern void _Exit(int __status) throw();
    extern char *getenv(const char *__name) throw() __attribute__((nonnull(0)));
    extern char *secure_getenv(const char *__name) throw() __attribute__((nonnull(0)));
    extern int putenv(char *__string) throw() __attribute__((nonnull(0)));
    extern int setenv(const char *__name, const char *__value, int __replace) throw() __attribute__((nonnull(1)));
    extern int unsetenv(const char *__name) throw() __attribute__((nonnull(0)));
    extern int clearenv() throw();
    extern char *mktemp(char *__template) throw() __attribute__((nonnull(0)));
    extern int mkstemp(char *__template) __attribute__((nonnull(0)));
    extern int mkstemp64(char *__template) __attribute__((nonnull(0)));
    extern int mkstemps(char *__template, int __suffixlen) __attribute__((nonnull(0)));
    extern int mkstemps64(char *__template, int __suffixlen) __attribute__((nonnull(0)));
    extern char *mkdtemp(char *__template) throw() __attribute__((nonnull(0)));
    extern int mkostemp(char *__template, int __flags) __attribute__((nonnull(0)));
    extern int mkostemp64(char *__template, int __flags) __attribute__((nonnull(0)));
    extern int mkostemps(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(0)));
    extern int mkostemps64(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(0)));
    extern int system(const char *__command);
    extern char *canonicalize_file_name(const char *__name) throw() __attribute__((nonnull(0)));
    extern char *realpath(const char *__restrict __name, char *__restrict __resolved) throw();
    typedef int (*__compar_fn_t)(const void *, const void *);
    typedef __compar_fn_t comparison_fn_t;
    typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
    extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(0, 1, 4)));
    extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(0, 3)));
    extern void qsort_r(void *__base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void *__arg) __attribute__((nonnull(0, 3)));
    extern int abs(int __x) throw() __attribute__((const)) __attribute__((nothrow));
    extern long labs(long __x) throw() __attribute__((const)) __attribute__((nothrow));
    extern long long llabs(long long __x) throw() __attribute__((const)) __attribute__((nothrow));
    extern div_t div(int __numer, int __denom) throw() __attribute__((const));
    extern ldiv_t ldiv(long __numer, long __denom) throw() __attribute__((const));
    extern lldiv_t lldiv(long long __numer, long long __denom) throw() __attribute__((const));
    extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(2, 3)));
    extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(2, 3)));
    extern char *gcvt(double __value, int __ndigit, char *__buf) throw() __attribute__((nonnull(2)));
    extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(2, 3)));
    extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(2, 3)));
    extern char *qgcvt(long double __value, int __ndigit, char *__buf) throw() __attribute__((nonnull(2)));
    extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(2, 3, 4)));
    extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(2, 3, 4)));
    extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(2, 3, 4)));
    extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(2, 3, 4)));
    extern int mblen(const char *__s, size_t __n) throw();
    extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n) throw();
    extern int wctomb(char *__s, wchar_t __wchar) throw();
    extern size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s, size_t __n) throw();
    extern size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs, size_t __n) throw();
    extern int rpmatch(const char *__response) throw() __attribute__((nonnull(0)));
    extern int getsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) throw() __attribute__((nonnull(0, 1, 2)));
    extern void setkey(const char *__key) throw() __attribute__((nonnull(0)));
    extern int posix_openpt(int __oflag);
    extern int grantpt(int __fd) throw();
    extern int unlockpt(int __fd) throw();
    extern char *ptsname(int __fd) throw();
    extern int ptsname_r(int __fd, char *__buf, size_t __buflen) throw() __attribute__((nonnull(1)));
    extern int getpt();
    extern int getloadavg(double __loadavg[], int __nelem) throw() __attribute__((nonnull(0)));
}
namespace std {
    using ::div_t;
    using ::ldiv_t;
    using ::abort;
    using ::abs;
    using ::atexit;
    using ::atof;
    using ::atoi;
    using ::atol;
    using ::bsearch;
    using ::calloc;
    using ::div;
    using ::exit;
    using ::free;
    using ::getenv;
    using ::labs;
    using ::ldiv;
    using ::malloc;
    using ::mblen;
    using ::mbstowcs;
    using ::mbtowc;
    using ::qsort;
    using ::rand;
    using ::realloc;
    using ::srand;
    using ::strtod;
    using ::strtol;
    using ::strtoul;
    using ::system;
    using ::wcstombs;
    using ::wctomb;
    inline long abs(long __i)     {
        return __builtin_labs(__i);
    }


    inline ldiv_t div(long __i, long __j)     {
        return ldiv(__i, __j);
    }


    inline long long abs(long long __x)     {
        return __builtin_llabs(__x);
    }


}
namespace __gnu_cxx {
    using ::lldiv_t;
    using ::_Exit;
    using ::llabs;
    inline lldiv_t div(long long __n, long long __d)     {
        lldiv_t __q;
        __q.quot = __n / __d;
        __q.rem = __n % __d;
        return __q;
    }


    using ::lldiv;
    using ::atoll;
    using ::strtoll;
    using ::strtoull;
    using ::strtof;
    using ::strtold;
}
namespace std {
    using ::__gnu_cxx::lldiv_t;
    using ::__gnu_cxx::_Exit;
    using ::__gnu_cxx::llabs;
    using ::__gnu_cxx::div;
    using ::__gnu_cxx::lldiv;
    using ::__gnu_cxx::atoll;
    using ::__gnu_cxx::strtof;
    using ::__gnu_cxx::strtoll;
    using ::__gnu_cxx::strtoull;
    using ::__gnu_cxx::strtold;
}
namespace std {
    template <typename _FIter, typename _Tp> bool binary_search(_FIter, _FIter, const _Tp &);
    template <typename _FIter, typename _Tp, typename _Compare> bool binary_search(_FIter, _FIter, const _Tp &, _Compare);
    template <typename _IIter, typename _OIter> _OIter copy(_IIter, _IIter, _OIter);
    template <typename _BIter1, typename _BIter2> _BIter2 copy_backward(_BIter1, _BIter1, _BIter2);
    template <typename _FIter, typename _Tp> pair<_FIter, _FIter> equal_range(_FIter, _FIter, const _Tp &);
    template <typename _FIter, typename _Tp, typename _Compare> pair<_FIter, _FIter> equal_range(_FIter, _FIter, const _Tp &, _Compare);
    template <typename _FIter, typename _Tp> void fill(_FIter, _FIter, const _Tp &);
    template <typename _OIter, typename _Size, typename _Tp> _OIter fill_n(_OIter, _Size, const _Tp &);
    template <typename _FIter1, typename _FIter2> _FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2);
    template <typename _FIter1, typename _FIter2, typename _BinaryPredicate> _FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
    template <typename _IIter1, typename _IIter2> bool includes(_IIter1, _IIter1, _IIter2, _IIter2);
    template <typename _IIter1, typename _IIter2, typename _Compare> bool includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);
    template <typename _BIter> void inplace_merge(_BIter, _BIter, _BIter);
    template <typename _BIter, typename _Compare> void inplace_merge(_BIter, _BIter, _BIter, _Compare);
    template <typename _FIter1, typename _FIter2> void iter_swap(_FIter1, _FIter2);
    template <typename _FIter, typename _Tp> _FIter lower_bound(_FIter, _FIter, const _Tp &);
    template <typename _FIter, typename _Tp, typename _Compare> _FIter lower_bound(_FIter, _FIter, const _Tp &, _Compare);
    template <typename _RAIter> void make_heap(_RAIter, _RAIter);
    template <typename _RAIter, typename _Compare> void make_heap(_RAIter, _RAIter, _Compare);
    template <typename _Tp> const _Tp &max(const _Tp &, const _Tp &);
    template <typename _Tp, typename _Compare> const _Tp &max(const _Tp &, const _Tp &, _Compare);
    template <typename _Tp = unsigned long> inline const unsigned long &min(const unsigned long &__a, const unsigned long &__b)template <typename _Tp = long> inline const long &min(const long &__a, const long &__b)template <typename _Tp> const _Tp &min(const _Tp &, const _Tp &);
    template <typename _Tp, typename _Compare> const _Tp &min(const _Tp &, const _Tp &, _Compare);
    template <typename _BIter> bool next_permutation(_BIter, _BIter);
    template <typename _BIter, typename _Compare> bool next_permutation(_BIter, _BIter, _Compare);
    template <typename _IIter, typename _RAIter> _RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);
    template <typename _IIter, typename _RAIter, typename _Compare> _RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);
    template <typename _RAIter> void pop_heap(_RAIter, _RAIter);
    template <typename _RAIter, typename _Compare> void pop_heap(_RAIter, _RAIter, _Compare);
    template <typename _BIter> bool prev_permutation(_BIter, _BIter);
    template <typename _BIter, typename _Compare> bool prev_permutation(_BIter, _BIter, _Compare);
    template <typename _RAIter> void push_heap(_RAIter, _RAIter);
    template <typename _RAIter, typename _Compare> void push_heap(_RAIter, _RAIter, _Compare);
    template <typename _FIter, typename _Tp> _FIter remove(_FIter, _FIter, const _Tp &);
    template <typename _FIter, typename _Predicate> _FIter remove_if(_FIter, _FIter, _Predicate);
    template <typename _IIter, typename _OIter, typename _Tp> _OIter remove_copy(_IIter, _IIter, _OIter, const _Tp &);
    template <typename _IIter, typename _OIter, typename _Predicate> _OIter remove_copy_if(_IIter, _IIter, _OIter, _Predicate);
    template <typename _IIter, typename _OIter, typename _Tp> _OIter replace_copy(_IIter, _IIter, _OIter, const _Tp &, const _Tp &);
    template <typename _Iter, typename _OIter, typename _Predicate, typename _Tp> _OIter replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp &);
    template <typename _BIter> void reverse(_BIter, _BIter);
    template <typename _BIter, typename _OIter> _OIter reverse_copy(_BIter, _BIter, _OIter);
    inline namespace _V2 {
        template <typename _FIter> _FIter rotate(_FIter, _FIter, _FIter);
    }
    template <typename _FIter, typename _OIter> _OIter rotate_copy(_FIter, _FIter, _FIter, _OIter);
    template <typename _RAIter> void sort_heap(_RAIter, _RAIter);
    template <typename _RAIter, typename _Compare> void sort_heap(_RAIter, _RAIter, _Compare);
    template <typename _BIter, typename _Predicate> _BIter stable_partition(_BIter, _BIter, _Predicate);
    template <typename _Tp> void swap(_Tp &, _Tp &);
    template <typename _Tp, size_t _Nm> void swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]);
    template <typename _FIter1, typename _FIter2> _FIter2 swap_ranges(_FIter1, _FIter1, _FIter2);
    template <typename _FIter> _FIter unique(_FIter, _FIter);
    template <typename _FIter, typename _BinaryPredicate> _FIter unique(_FIter, _FIter, _BinaryPredicate);
    template <typename _FIter, typename _Tp> _FIter upper_bound(_FIter, _FIter, const _Tp &);
    template <typename _FIter, typename _Tp, typename _Compare> _FIter upper_bound(_FIter, _FIter, const _Tp &, _Compare);
    template <typename _FIter> _FIter adjacent_find(_FIter, _FIter);
    template <typename _FIter, typename _BinaryPredicate> _FIter adjacent_find(_FIter, _FIter, _BinaryPredicate);
    template <typename _IIter, typename _Tp> typename iterator_traits<_IIter>::difference_type count(_IIter, _IIter, const _Tp &);
    template <typename _IIter, typename _Predicate> typename iterator_traits<_IIter>::difference_type count_if(_IIter, _IIter, _Predicate);
    template <typename _IIter1, typename _IIter2> bool equal(_IIter1, _IIter1, _IIter2);
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> bool equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);
    template <typename _IIter, typename _Tp> _IIter find(_IIter, _IIter, const _Tp &);
    template <typename _FIter1, typename _FIter2> _FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);
    template <typename _FIter1, typename _FIter2, typename _BinaryPredicate> _FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
    template <typename _IIter, typename _Predicate> _IIter find_if(_IIter, _IIter, _Predicate);
    template <typename _IIter, typename _Funct> _Funct for_each(_IIter, _IIter, _Funct);
    template <typename _FIter, typename _Generator> void generate(_FIter, _FIter, _Generator);
    template <typename _OIter, typename _Size, typename _Generator> _OIter generate_n(_OIter, _Size, _Generator);
    template <typename _IIter1, typename _IIter2> bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);
    template <typename _IIter1, typename _IIter2, typename _Compare> bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);
    template <typename _FIter> _FIter max_element(_FIter, _FIter);
    template <typename _FIter, typename _Compare> _FIter max_element(_FIter, _FIter, _Compare);
    template <typename _IIter1, typename _IIter2, typename _OIter> _OIter merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
    template <typename _IIter1, typename _IIter2, typename _OIter, typename _Compare> _OIter merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
    template <typename _FIter> _FIter min_element(_FIter, _FIter);
    template <typename _FIter, typename _Compare> _FIter min_element(_FIter, _FIter, _Compare);
    template <typename _IIter1, typename _IIter2> pair<_IIter1, _IIter2> mismatch(_IIter1, _IIter1, _IIter2);
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> pair<_IIter1, _IIter2> mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);
    template <typename _RAIter> void nth_element(_RAIter, _RAIter, _RAIter);
    template <typename _RAIter, typename _Compare> void nth_element(_RAIter, _RAIter, _RAIter, _Compare);
    template <typename _RAIter> void partial_sort(_RAIter, _RAIter, _RAIter);
    template <typename _RAIter, typename _Compare> void partial_sort(_RAIter, _RAIter, _RAIter, _Compare);
    template <typename _BIter, typename _Predicate> _BIter partition(_BIter, _BIter, _Predicate);
    template <typename _RAIter> void random_shuffle(_RAIter, _RAIter);
    template <typename _RAIter, typename _Generator> void random_shuffle(_RAIter, _RAIter, _Generator &);
    template <typename _FIter, typename _Tp> void replace(_FIter, _FIter, const _Tp &, const _Tp &);
    template <typename _FIter, typename _Predicate, typename _Tp> void replace_if(_FIter, _FIter, _Predicate, const _Tp &);
    template <typename _FIter1, typename _FIter2> _FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2);
    template <typename _FIter1, typename _FIter2, typename _BinaryPredicate> _FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
    template <typename _FIter, typename _Size, typename _Tp> _FIter search_n(_FIter, _FIter, _Size, const _Tp &);
    template <typename _FIter, typename _Size, typename _Tp, typename _BinaryPredicate> _FIter search_n(_FIter, _FIter, _Size, const _Tp &, _BinaryPredicate);
    template <typename _IIter1, typename _IIter2, typename _OIter> _OIter set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
    template <typename _IIter1, typename _IIter2, typename _OIter, typename _Compare> _OIter set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
    template <typename _IIter1, typename _IIter2, typename _OIter> _OIter set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
    template <typename _IIter1, typename _IIter2, typename _OIter, typename _Compare> _OIter set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
    template <typename _IIter1, typename _IIter2, typename _OIter> _OIter set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
    template <typename _IIter1, typename _IIter2, typename _OIter, typename _Compare> _OIter set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
    template <typename _IIter1, typename _IIter2, typename _OIter> _OIter set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
    template <typename _IIter1, typename _IIter2, typename _OIter, typename _Compare> _OIter set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
    template <typename _RAIter> void sort(_RAIter, _RAIter);
    template <typename _RAIter, typename _Compare> void sort(_RAIter, _RAIter, _Compare);
    template <typename _RAIter> void stable_sort(_RAIter, _RAIter);
    template <typename _RAIter, typename _Compare> void stable_sort(_RAIter, _RAIter, _Compare);
    template <typename _IIter, typename _OIter, typename _UnaryOperation> _OIter transform(_IIter, _IIter, _OIter, _UnaryOperation);
    template <typename _IIter1, typename _IIter2, typename _OIter, typename _BinaryOperation> _OIter transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);
    template <typename _IIter, typename _OIter> _OIter unique_copy(_IIter, _IIter, _OIter);
    template <typename _IIter, typename _OIter, typename _BinaryPredicate> _OIter unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);
}
namespace std {
    template <typename _RandomAccessIterator, typename _Distance, typename _Compare> _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n, _Compare __comp)     {
        _Distance __parent = 0;
        for (_Distance __child = 1; __child < __n; ++__child) {
            if (__comp(__first + __parent, __first + __child))
                return __child;
            if ((__child & 1) == 0)
                ++__parent;
        }
        return __n;
    }

;
    template <typename _RandomAccessIterator, typename _Distance> inline bool __is_heap(_RandomAccessIterator __first, _Distance __n)     {
        return std::__is_heap_until(__first, __n, __gnu_cxx::__ops::__iter_less_iter()) == __n;
    }

;
    template <typename _RandomAccessIterator, typename _Compare, typename _Distance> inline bool __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)     {
        return std::__is_heap_until(__first, __n, __gnu_cxx::__ops::__iter_comp_iter(__comp)) == __n;
    }

;
    template <typename _RandomAccessIterator> inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)     {
        return std::__is_heap(__first, std::distance(__first, __last));
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        return std::__is_heap(__first, __comp, std::distance(__first, __last));
    }

;
    template <typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare> void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare __comp)     {
        _Distance __parent = (__holeIndex - 1) / 2;
        while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
            {
                *(__first + __holeIndex) = (*(__first + __parent));
                __holeIndex = __parent;
                __parent = (__holeIndex - 1) / 2;
            }
        *(__first + __holeIndex) = (__value);
    }

;
    template <typename _RandomAccessIterator> inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)     {
        typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
        ;
        ;
        _ValueType __value = (*(__last - 1));
        std::__push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0), (__value), __gnu_cxx::__ops::__iter_less_val());
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
        ;
        ;
        _ValueType __value = (*(__last - 1));
        std::__push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0), (__value), __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

;
    template <typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare> void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __comp)     {
        const _Distance __topIndex = __holeIndex;
        _Distance __secondChild = __holeIndex;
        while (__secondChild < (__len - 1) / 2)
            {
                __secondChild = 2 * (__secondChild + 1);
                if (__comp(__first + __secondChild, __first + (__secondChild - 1)))
                    __secondChild--;
                *(__first + __holeIndex) = (*(__first + __secondChild));
                __holeIndex = __secondChild;
            }
        if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2) {
            __secondChild = 2 * (__secondChild + 1);
            *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));
            __holeIndex = __secondChild - 1;
        }
        std::__push_heap(__first, __holeIndex, __topIndex, (__value), __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Compare __comp)     {
        typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
        _ValueType __value = (*__result);
        *__result = (*__first);
        std::__adjust_heap(__first, _DistanceType(0), _DistanceType(__last - __first), (__value), __comp);
    }

;
    template <typename _RandomAccessIterator> inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)     {
        typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
        ;
        ;
        ;
        if (__last - __first > 1) {
            --__last;
            std::__pop_heap(__first, __last, __last, __gnu_cxx::__ops::__iter_less_iter());
        }
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        ;
        ;
        ;
        if (__last - __first > 1) {
            --__last;
            std::__pop_heap(__first, __last, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
        }
    }

;
    template <typename _RandomAccessIterator, typename _Compare> void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
        if (__last - __first < 2)
            return;
        const _DistanceType __len = __last - __first;
        _DistanceType __parent = (__len - 2) / 2;
        while (true)
            {
                _ValueType __value = (*(__first + __parent));
                std::__adjust_heap(__first, __parent, __len, (__value), __comp);
                if (__parent == 0)
                    return;
                __parent--;
            }
    }

;
    template <typename _RandomAccessIterator> inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)     {
        ;
        std::__make_heap(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        ;
        std::__make_heap(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _RandomAccessIterator, typename _Compare> void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        while (__last - __first > 1)
            {
                --__last;
                std::__pop_heap(__first, __last, __last, __comp);
            }
    }

;
    template <typename _RandomAccessIterator> inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)     {
        ;
        ;
        std::__sort_heap(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        ;
        ;
        std::__sort_heap(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
}
namespace std {
    template <typename _T1, typename _T2> inline void _Construct(_T1 *__p, const _T2 &__value)     {
        ::new (static_cast<void *>(__p)) _T1((__value));
    }

;
    template <typename _Tp> inline void _Destroy(_Tp *__pointer)     {
        __pointer->~_Tp();
    }

;
    template <bool = true> struct _Destroy_aux {
        template <typename _ForwardIterator> static void __destroy(_ForwardIterator, _ForwardIterator)         {
        }

;
    }
template <bool> struct _Destroy_aux {
        template <typename _ForwardIterator> static void __destroy(_ForwardIterator __first, _ForwardIterator __last)         {
            for (; __first != __last; ++__first) 
                std::_Destroy(std::__addressof(*__first));
        }

;
    };
    struct _Destroy_aux {
        template <typename _ForwardIterator> static void __destroy(_ForwardIterator, _ForwardIterator)         {
        }

;
    };
    template <typename _ForwardIterator> inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;
        std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first, __last);
    }

;
    template <typename _ForwardIterator, typename _Allocator> void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc)     {
        typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
        for (; __first != __last; ++__first) 
            __traits::destroy(__alloc, std::__addressof(*__first));
    }

;
    template <typename _ForwardIterator, typename _Tp> inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last, allocator<_Tp> &)     {
        _Destroy(__first, __last);
    }

;
}
namespace std {
    template <typename _Tp> pair<_Tp *, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len)     {
        const ptrdiff_t __max = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
        if (__len > __max)
            __len = __max;
        while (__len > 0)
            {
                _Tp *__tmp = static_cast<_Tp *>(::operator new(__len * sizeof(_Tp), std::nothrow));
                if (__tmp != 0)
                    return std::pair<_Tp *, ptrdiff_t>(__tmp, __len);
                __len /= 2;
            }
        return std::pair<_Tp *, ptrdiff_t>(static_cast<_Tp *>(0), 0);
    }

;
    template <typename _Tp> inline void return_temporary_buffer(_Tp *__p)     {
        ::operator delete(__p, std::nothrow);
    }

;
    template <typename _ForwardIterator, typename _Tp> class _Temporary_buffer {
    public:
        typedef _Tp value_type;
        typedef value_type *pointer;
        typedef pointer iterator;
        typedef ptrdiff_t size_type;
    protected:
        size_type _M_original_len;
        size_type _M_len;
        pointer _M_buffer;
    public:
        size_type size() const         {
            return this->_M_len;
        }


        size_type requested_size() const         {
            return this->_M_original_len;
        }


        iterator begin()         {
            return this->_M_buffer;
        }


        iterator end()         {
            return this->_M_buffer + this->_M_len;
        }


        _Temporary_buffer<_ForwardIterator, _Tp>(_ForwardIterator __first, _ForwardIterator __last);
        ~_Temporary_buffer<_ForwardIterator, _Tp>()         {
            std::_Destroy(this->_M_buffer, this->_M_buffer + this->_M_len);
            std::return_temporary_buffer(this->_M_buffer);
        }


    private:
        _Temporary_buffer<_ForwardIterator, _Tp>(const _Temporary_buffer<_ForwardIterator, _Tp> &);
        void operator=(const _Temporary_buffer<_ForwardIterator, _Tp> &);
    };
    template <bool = true> struct __uninitialized_construct_buf_dispatch {
        template <typename _Pointer, typename _ForwardIterator> static void __ucr(_Pointer, _Pointer, _ForwardIterator)         {
        }

;
    }
template <bool> struct __uninitialized_construct_buf_dispatch {
        template <typename _Pointer, typename _ForwardIterator> static void __ucr(_Pointer __first, _Pointer __last, _ForwardIterator __seed)         {
            if (__first == __last)
                return;
            _Pointer __cur = __first;
            try {
                std::_Construct(std::__addressof(*__first), (*__seed));
                _Pointer __prev = __cur;
                ++__cur;
                for (; __cur != __last; ++__cur , ++__prev) 
                    std::_Construct(std::__addressof(*__cur), (*__prev));
                *__seed = (*__prev);
            } catch (...) {
                std::_Destroy(__first, __cur);
                throw;
            }
        }

;
    };
    struct __uninitialized_construct_buf_dispatch {
        template <typename _Pointer, typename _ForwardIterator> static void __ucr(_Pointer, _Pointer, _ForwardIterator)         {
        }

;
    };
    template <typename _Pointer, typename _ForwardIterator> inline void __uninitialized_construct_buf(_Pointer __first, _Pointer __last, _ForwardIterator __seed)     {
        typedef typename std::iterator_traits<_Pointer>::value_type _ValueType;
        std::__uninitialized_construct_buf_dispatch<__has_trivial_constructor(_ValueType)>::__ucr(__first, __last, __seed);
    }

;
    _Temporary_buffer<_ForwardIterator, _Tp>(_ForwardIterator __first, _ForwardIterator __last) : _M_original_len(std::distance(__first, __last)), _M_len(0), _M_buffer(0)     {
        try {
            std::pair<pointer, size_type> __p(std::get_temporary_buffer<value_type>(this->_M_original_len));
            this->_M_buffer = __p.first;
            this->_M_len = __p.second;
            if (this->_M_buffer)
                std::__uninitialized_construct_buf(this->_M_buffer, this->_M_buffer + this->_M_len, __first);
        } catch (...) {
            std::return_temporary_buffer(this->_M_buffer);
            this->_M_buffer = 0;
            this->_M_len = 0;
            throw;
        }
    }


}
namespace std {
    template <typename _Iterator, typename _Compare> void __move_median_to_first(_Iterator __result, _Iterator __a, _Iterator __b, _Iterator __c, _Compare __comp)     {
        if (__comp(__a, __b)) {
            if (__comp(__b, __c))
                std::iter_swap(__result, __b);
            else if (__comp(__a, __c))
                std::iter_swap(__result, __c);
            else
                std::iter_swap(__result, __a);
        } else if (__comp(__a, __c))
            std::iter_swap(__result, __a);
        else if (__comp(__b, __c))
            std::iter_swap(__result, __c);
        else
            std::iter_swap(__result, __b);
    }

;
    template <typename _InputIterator, typename _Predicate> inline _InputIterator __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, std::input_iterator_tag)     {
        while (__first != __last && !__pred(__first))
            ++__first;
        return __first;
    }

;
    template <typename _RandomAccessIterator, typename _Predicate> _RandomAccessIterator __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, std::random_access_iterator_tag)     {
        typename iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
        for (; __trip_count > 0; --__trip_count) {
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
        }
        switch (__last - __first) {
          case 3:
            if (__pred(__first))
                return __first;
            ++__first;
          case 2:
            if (__pred(__first))
                return __first;
            ++__first;
          case 1:
            if (__pred(__first))
                return __first;
            ++__first;
          case 0:
          default:
            return __last;
        }
    }

;
    template <typename _Iterator, typename _Predicate> inline _Iterator __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)     {
        return __find_if(__first, __last, __pred, std::__iterator_category(__first));
    }

;
    template <typename _InputIterator, typename _Predicate> inline _InputIterator __find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)     {
        return std::__find_if(__first, __last, __gnu_cxx::__ops::__negate(__pred), std::__iterator_category(__first));
    }

;
    template <typename _InputIterator, typename _Predicate, typename _Distance> _InputIterator __find_if_not_n(_InputIterator __first, _Distance &__len, _Predicate __pred)     {
        for (; __len; --__len , ++__first) 
            if (!__pred(__first))
                break;
        return __first;
    }

;
    template <typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate> _ForwardIterator1 __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)     {
        if (__first1 == __last1 || __first2 == __last2)
            return __first1;
        _ForwardIterator2 __p1(__first2);
        if (++__p1 == __last2)
            return std::__find_if(__first1, __last1, __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
        _ForwardIterator2 __p;
        _ForwardIterator1 __current = __first1;
        for (;;) {
            __first1 = std::__find_if(__first1, __last1, __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
            if (__first1 == __last1)
                return __last1;
            __p = __p1;
            __current = __first1;
            if (++__current == __last1)
                return __last1;
            while (__predicate(__current, __p))
                {
                    if (++__p == __last2)
                        return __first1;
                    if (++__current == __last1)
                        return __last1;
                }
            ++__first1;
        }
        return __first1;
    }

;
    template <typename _ForwardIterator, typename _Integer, typename _UnaryPredicate> _ForwardIterator __search_n_aux(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, _UnaryPredicate __unary_pred, std::forward_iterator_tag)     {
        __first = std::__find_if(__first, __last, __unary_pred);
        while (__first != __last)
            {
                typename iterator_traits<_ForwardIterator>::difference_type __n = __count;
                _ForwardIterator __i = __first;
                ++__i;
                while (__i != __last && __n != 1 && __unary_pred(__i))
                    {
                        ++__i;
                        --__n;
                    }
                if (__n == 1)
                    return __first;
                if (__i == __last)
                    return __last;
                __first = std::__find_if(++__i, __last, __unary_pred);
            }
        return __last;
    }

;
    template <typename _RandomAccessIter, typename _Integer, typename _UnaryPredicate> _RandomAccessIter __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, _UnaryPredicate __unary_pred, std::random_access_iterator_tag)     {
        typedef typename std::iterator_traits<_RandomAccessIter>::difference_type _DistanceType;
        _DistanceType __tailSize = __last - __first;
        _DistanceType __remainder = __count;
        while (__remainder <= __tailSize)
            {
                __first += __remainder;
                __tailSize -= __remainder;
                _RandomAccessIter __backTrack = __first;
                while (__unary_pred(--__backTrack))
                    {
                        if (--__remainder == 0)
                            return (__first - __count);
                    }
                __remainder = __count + 1 - (__first - __backTrack);
            }
        return __last;
    }

;
    template <typename _ForwardIterator, typename _Integer, typename _UnaryPredicate> _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, _UnaryPredicate __unary_pred)     {
        if (__count <= 0)
            return __first;
        if (__count == 1)
            return std::__find_if(__first, __last, __unary_pred);
        return std::__search_n_aux(__first, __last, __count, __unary_pred, std::__iterator_category(__first));
    }

;
    template <typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate> _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, std::forward_iterator_tag, std::forward_iterator_tag, _BinaryPredicate __comp)     {
        if (__first2 == __last2)
            return __last1;
        _ForwardIterator1 __result = __last1;
        while (1)
            {
                _ForwardIterator1 __new_result = std::__search(__first1, __last1, __first2, __last2, __comp);
                if (__new_result == __last1)
                    return __result;
                else {
                    __result = __new_result;
                    __first1 = __new_result;
                    ++__first1;
                }
            }
    }

;
    template <typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BinaryPredicate> _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, std::bidirectional_iterator_tag, std::bidirectional_iterator_tag, _BinaryPredicate __comp)     {
        typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
        typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
        _RevIterator1 __rlast1(__first1);
        _RevIterator2 __rlast2(__first2);
        _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1, _RevIterator2(__last2), __rlast2, __comp);
        if (__rresult == __rlast1)
            return __last1;
        else {
            _BidirectionalIterator1 __result = __rresult.base();
            std::advance(__result, - std::distance(__first2, __last2));
            return __result;
        }
    }

;
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)     {
        ;
        ;
        return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2), __gnu_cxx::__ops::__iter_equal_to_iter());
    }

;
    template <typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate> inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __comp)     {
        ;
        ;
        return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2), __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _InputIterator, typename _OutputIterator, typename _Predicate> _OutputIterator __remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)     {
        for (; __first != __last; ++__first) 
            if (!__pred(__first)) {
                *__result = *__first;
                ++__result;
            }
        return __result;
    }

;
    template <typename _InputIterator, typename _OutputIterator, typename _Tp> inline _OutputIterator remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__value)     {
        ;
        return std::__remove_copy_if(__first, __last, __result, __gnu_cxx::__ops::__iter_equals_val(__value));
    }

;
    template <typename _InputIterator, typename _OutputIterator, typename _Predicate> inline _OutputIterator remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)     {
        ;
        return std::__remove_copy_if(__first, __last, __result, __gnu_cxx::__ops::__pred_iter(__pred));
    }

;
    template <typename _ForwardIterator, typename _Predicate> _ForwardIterator __remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)     {
        __first = std::__find_if(__first, __last, __pred);
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        ++__first;
        for (; __first != __last; ++__first) 
            if (!__pred(__first)) {
                *__result = (*__first);
                ++__result;
            }
        return __result;
    }

;
    template <typename _ForwardIterator, typename _Tp> inline _ForwardIterator remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        ;
        return std::__remove_if(__first, __last, __gnu_cxx::__ops::__iter_equals_val(__value));
    }

;
    template <typename _ForwardIterator, typename _Predicate> inline _ForwardIterator remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)     {
        ;
        return std::__remove_if(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred));
    }

;
    template <typename _ForwardIterator, typename _BinaryPredicate> _ForwardIterator __adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)     {
        if (__first == __last)
            return __last;
        _ForwardIterator __next = __first;
        while (++__next != __last)
            {
                if (__binary_pred(__first, __next))
                    return __first;
                __first = __next;
            }
        return __last;
    }

;
    template <typename _ForwardIterator, typename _BinaryPredicate> _ForwardIterator __unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)     {
        __first = std::__adjacent_find(__first, __last, __binary_pred);
        if (__first == __last)
            return __last;
        _ForwardIterator __dest = __first;
        ++__first;
        while (++__first != __last)
            if (!__binary_pred(__dest, __first))
                *++__dest = (*__first);
        return ++__dest;
    }

;
    template <typename _ForwardIterator> inline _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last)     {
        ;
        return std::__unique(__first, __last, __gnu_cxx::__ops::__iter_equal_to_iter());
    }

;
    template <typename _ForwardIterator, typename _BinaryPredicate> inline _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)     {
        ;
        return std::__unique(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }

;
    template <typename _ForwardIterator, typename _OutputIterator, typename _BinaryPredicate> _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, std::forward_iterator_tag, std::output_iterator_tag)     {
        _ForwardIterator __next = __first;
        *__result = *__first;
        while (++__next != __last)
            if (!__binary_pred(__first, __next)) {
                __first = __next;
                *++__result = *__first;
            }
        return ++__result;
    }

;
    template <typename _InputIterator, typename _OutputIterator, typename _BinaryPredicate> _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, std::input_iterator_tag, std::output_iterator_tag)     {
        typename iterator_traits<_InputIterator>::value_type __value = *__first;
        decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred)) __rebound_pred = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
        *__result = __value;
        while (++__first != __last)
            if (!__rebound_pred(__first, __value)) {
                __value = *__first;
                *++__result = __value;
            }
        return ++__result;
    }

;
    template <typename _InputIterator, typename _ForwardIterator, typename _BinaryPredicate> _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __binary_pred, std::input_iterator_tag, std::forward_iterator_tag)     {
        *__result = *__first;
        while (++__first != __last)
            if (!__binary_pred(__result, __first))
                *++__result = *__first;
        return ++__result;
    }

;
    template <typename _BidirectionalIterator> void __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, std::bidirectional_iterator_tag)     {
        while (true)
            if (__first == __last || __first == --__last)
                return;
            else {
                std::iter_swap(__first, __last);
                ++__first;
            }
    }

;
    template <typename _RandomAccessIterator> void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, std::random_access_iterator_tag)     {
        if (__first == __last)
            return;
        --__last;
        while (__first < __last)
            {
                std::iter_swap(__first, __last);
                ++__first;
                --__last;
            }
    }

;
    template <typename _BidirectionalIterator> inline void reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)     {
        ;
        std::__reverse(__first, __last, std::__iterator_category(__first));
    }

;
    template <typename _BidirectionalIterator, typename _OutputIterator> _OutputIterator reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)     {
        ;
        while (__first != __last)
            {
                --__last;
                *__result = *__last;
                ++__result;
            }
        return __result;
    }

;
    template <typename _EuclideanRingElement> _EuclideanRingElement __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)     {
        while (__n != 0)
            {
                _EuclideanRingElement __t = __m % __n;
                __m = __n;
                __n = __t;
            }
        return __m;
    }

;
    inline namespace _V2 {
        template <typename _ForwardIterator> _ForwardIterator __rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, std::forward_iterator_tag)         {
            if (__first == __middle)
                return __last;
            else if (__last == __middle)
                return __first;
            _ForwardIterator __first2 = __middle;
            do {
                std::iter_swap(__first, __first2);
                ++__first;
                ++__first2;
                if (__first == __middle)
                    __middle = __first2;
            } while (__first2 != __last);
            _ForwardIterator __ret = __first;
            __first2 = __middle;
            while (__first2 != __last)
                {
                    std::iter_swap(__first, __first2);
                    ++__first;
                    ++__first2;
                    if (__first == __middle)
                        __middle = __first2;
                    else if (__first2 == __last)
                        __first2 = __middle;
                }
            return __ret;
        }

;
        template <typename _BidirectionalIterator> _BidirectionalIterator __rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, std::bidirectional_iterator_tag)         {
            if (__first == __middle)
                return __last;
            else if (__last == __middle)
                return __first;
            std::__reverse(__first, __middle, std::bidirectional_iterator_tag());
            std::__reverse(__middle, __last, std::bidirectional_iterator_tag());
            while (__first != __middle && __middle != __last)
                {
                    std::iter_swap(__first, --__last);
                    ++__first;
                }
            if (__first == __middle) {
                std::__reverse(__middle, __last, std::bidirectional_iterator_tag());
                return __last;
            } else {
                std::__reverse(__first, __middle, std::bidirectional_iterator_tag());
                return __first;
            }
        }

;
        template <typename _RandomAccessIterator> _RandomAccessIterator __rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, std::random_access_iterator_tag)         {
            if (__first == __middle)
                return __last;
            else if (__last == __middle)
                return __first;
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;
            typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
            _Distance __n = __last - __first;
            _Distance __k = __middle - __first;
            if (__k == __n - __k) {
                std::swap_ranges(__first, __middle, __middle);
                return __middle;
            }
            _RandomAccessIterator __p = __first;
            _RandomAccessIterator __ret = __first + (__last - __middle);
            for (;;) {
                if (__k < __n - __k) {
                    if (__is_pod(_ValueType) && __k == 1) {
                        _ValueType __t = (*__p);
                        std::copy(__p + 1, __p + __n, __p);
                        *(__p + __n - 1) = (__t);
                        return __ret;
                    }
                    _RandomAccessIterator __q = __p + __k;
                    for (_Distance __i = 0; __i < __n - __k; ++__i) {
                        std::iter_swap(__p, __q);
                        ++__p;
                        ++__q;
                    }
                    __n %= __k;
                    if (__n == 0)
                        return __ret;
                    std::swap(__n, __k);
                    __k = __n - __k;
                } else {
                    __k = __n - __k;
                    if (__is_pod(_ValueType) && __k == 1) {
                        _ValueType __t = (*(__p + __n - 1));
                        std::copy_backward(__p, __p + __n - 1, __p + __n);
                        *__p = (__t);
                        return __ret;
                    }
                    _RandomAccessIterator __q = __p + __n;
                    __p = __q - __k;
                    for (_Distance __i = 0; __i < __n - __k; ++__i) {
                        --__p;
                        --__q;
                        std::iter_swap(__p, __q);
                    }
                    __n %= __k;
                    if (__n == 0)
                        return __ret;
                    std::swap(__n, __k);
                }
            }
        }

;
        template <typename _ForwardIterator> inline _ForwardIterator rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)         {
            ;
            ;
            return std::__rotate(__first, __middle, __last, std::__iterator_category(__first));
        }

;
    }
    template <typename _ForwardIterator, typename _OutputIterator> inline _OutputIterator rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)     {
        ;
        ;
        return std::copy(__first, __middle, std::copy(__middle, __last, __result));
    }

;
    template <typename _ForwardIterator, typename _Predicate> _ForwardIterator __partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, std::forward_iterator_tag)     {
        if (__first == __last)
            return __first;
        while (__pred(*__first))
            if (++__first == __last)
                return __first;
        _ForwardIterator __next = __first;
        while (++__next != __last)
            if (__pred(*__next)) {
                std::iter_swap(__first, __next);
                ++__first;
            }
        return __first;
    }

;
    template <typename _BidirectionalIterator, typename _Predicate> _BidirectionalIterator __partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, std::bidirectional_iterator_tag)     {
        while (true)
            {
                while (true)
                    if (__first == __last)
                        return __first;
                    else if (__pred(*__first))
                        ++__first;
                    else
                        break;
                --__last;
                while (true)
                    if (__first == __last)
                        return __first;
                    else if (!bool(__pred(*__last)))
                        --__last;
                    else
                        break;
                std::iter_swap(__first, __last);
                ++__first;
            }
    }

;
    template <typename _ForwardIterator, typename _Pointer, typename _Predicate, typename _Distance> _ForwardIterator __stable_partition_adaptive(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len, _Pointer __buffer, _Distance __buffer_size)     {
        if (__len == 1)
            return __first;
        if (__len <= __buffer_size) {
            _ForwardIterator __result1 = __first;
            _Pointer __result2 = __buffer;
            *__result2 = (*__first);
            ++__result2;
            ++__first;
            for (; __first != __last; ++__first) 
                if (__pred(__first)) {
                    *__result1 = (*__first);
                    ++__result1;
                } else {
                    *__result2 = (*__first);
                    ++__result2;
                }
            std::copy(__buffer, __result2, __result1);
            return __result1;
        }
        _ForwardIterator __middle = __first;
        std::advance(__middle, __len / 2);
        _ForwardIterator __left_split = std::__stable_partition_adaptive(__first, __middle, __pred, __len / 2, __buffer, __buffer_size);
        _Distance __right_len = __len - __len / 2;
        _ForwardIterator __right_split = std::__find_if_not_n(__middle, __right_len, __pred);
        if (__right_len)
            __right_split = std::__stable_partition_adaptive(__right_split, __last, __pred, __right_len, __buffer, __buffer_size);
        std::rotate(__left_split, __middle, __right_split);
        std::advance(__left_split, std::distance(__middle, __right_split));
        return __left_split;
    }

;
    template <typename _ForwardIterator, typename _Predicate> _ForwardIterator __stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)     {
        __first = std::__find_if_not(__first, __last, __pred);
        if (__first == __last)
            return __first;
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        typedef typename iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
        return std::__stable_partition_adaptive(__first, __last, __pred, _DistanceType(__buf.requested_size()), __buf.begin(), _DistanceType(__buf.size()));
    }

;
    template <typename _ForwardIterator, typename _Predicate> inline _ForwardIterator stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)     {
        ;
        return std::__stable_partition(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred));
    }

;
    template <typename _RandomAccessIterator, typename _Compare> void __heap_select(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)     {
        std::__make_heap(__first, __middle, __comp);
        for (_RandomAccessIterator __i = __middle; __i < __last; ++__i) 
            if (__comp(__i, __first))
                std::__pop_heap(__first, __middle, __i, __comp);
    }

;
    template <typename _InputIterator, typename _RandomAccessIterator, typename _Compare> _RandomAccessIterator __partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)     {
        typedef typename iterator_traits<_InputIterator>::value_type _InputValueType;
        typedef iterator_traits<_RandomAccessIterator> _RItTraits;
        typedef typename _RItTraits::difference_type _DistanceType;
        if (__result_first == __result_last)
            return __result_last;
        _RandomAccessIterator __result_real_last = __result_first;
        while (__first != __last && __result_real_last != __result_last)
            {
                *__result_real_last = *__first;
                ++__result_real_last;
                ++__first;
            }
        std::__make_heap(__result_first, __result_real_last, __comp);
        while (__first != __last)
            {
                if (__comp(__first, __result_first))
                    std::__adjust_heap(__result_first, _DistanceType(0), _DistanceType(__result_real_last - __result_first), _InputValueType(*__first), __comp);
                ++__first;
            }
        std::__sort_heap(__result_first, __result_real_last, __comp);
        return __result_real_last;
    }

;
    template <typename _InputIterator, typename _RandomAccessIterator> inline _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)     {
        typedef typename iterator_traits<_InputIterator>::value_type _InputValueType;
        typedef typename iterator_traits<_RandomAccessIterator>::value_type _OutputValueType;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
        ;
        ;
        return std::__partial_sort_copy(__first, __last, __result_first, __result_last, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _InputIterator, typename _RandomAccessIterator, typename _Compare> inline _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)     {
        typedef typename iterator_traits<_InputIterator>::value_type _InputValueType;
        typedef typename iterator_traits<_RandomAccessIterator>::value_type _OutputValueType;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
        ;
        ;
        return std::__partial_sort_copy(__first, __last, __result_first, __result_last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _RandomAccessIterator, typename _Compare> void __unguarded_linear_insert(_RandomAccessIterator __last, _Compare __comp)     {
        typename iterator_traits<_RandomAccessIterator>::value_type __val = (*__last);
        _RandomAccessIterator __next = __last;
        --__next;
        while (__comp(__val, __next))
            {
                *__last = (*__next);
                __last = __next;
                --__next;
            }
        *__last = (__val);
    }

;
    template <typename _RandomAccessIterator, typename _Compare> void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        if (__first == __last)
            return;
        for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) {
            if (__comp(__i, __first)) {
                typename iterator_traits<_RandomAccessIterator>::value_type __val = (*__i);
                std::copy_backward(__first, __i, __i + 1);
                *__first = (__val);
            } else
                std::__unguarded_linear_insert(__i, __gnu_cxx::__ops::__val_comp_iter(__comp));
        }
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        for (_RandomAccessIterator __i = __first; __i != __last; ++__i) 
            std::__unguarded_linear_insert(__i, __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

;
    enum  {
        _S_threshold = 16
    };
    template <typename _RandomAccessIterator, typename _Compare> void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        if (__last - __first > int(_S_threshold)) {
            std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
            std::__unguarded_insertion_sort(__first + int(_S_threshold), __last, __comp);
        } else
            std::__insertion_sort(__first, __last, __comp);
    }

;
    template <typename _RandomAccessIterator, typename _Compare> _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __pivot, _Compare __comp)     {
        while (true)
            {
                while (__comp(__first, __pivot))
                    ++__first;
                --__last;
                while (__comp(__pivot, __last))
                    --__last;
                if (!(__first < __last))
                    return __first;
                std::iter_swap(__first, __last);
                ++__first;
            }
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline _RandomAccessIterator __unguarded_partition_pivot(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        _RandomAccessIterator __mid = __first + (__last - __first) / 2;
        std::__move_median_to_first(__first, __first + 1, __mid, __last - 1, __comp);
        return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void __partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)     {
        std::__heap_select(__first, __middle, __last, __comp);
        std::__sort_heap(__first, __middle, __comp);
    }

;
    template <typename _RandomAccessIterator, typename _Size, typename _Compare> void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)     {
        while (__last - __first > int(_S_threshold))
            {
                if (__depth_limit == 0) {
                    std::__partial_sort(__first, __last, __last, __comp);
                    return;
                }
                --__depth_limit;
                _RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last, __comp);
                std::__introsort_loop(__cut, __last, __depth_limit, __comp);
                __last = __cut;
            }
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        if (__first != __last) {
            std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2, __comp);
            std::__final_insertion_sort(__first, __last, __comp);
        }
    }

;
    template <typename _RandomAccessIterator, typename _Size, typename _Compare> void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)     {
        while (__last - __first > 3)
            {
                if (__depth_limit == 0) {
                    std::__heap_select(__first, __nth + 1, __last, __comp);
                    std::iter_swap(__first, __nth);
                    return;
                }
                --__depth_limit;
                _RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last, __comp);
                if (__cut <= __nth)
                    __first = __cut;
                else
                    __last = __cut;
            }
        std::__insertion_sort(__first, __last, __comp);
    }

;
    template <typename _ForwardIterator, typename _Tp, typename _Compare> inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        ;
        return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

;
    template <typename _ForwardIterator, typename _Tp, typename _Compare> _ForwardIterator __upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)     {
        typedef typename iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        _DistanceType __len = std::distance(__first, __last);
        while (__len > 0)
            {
                _DistanceType __half = __len >> 1;
                _ForwardIterator __middle = __first;
                std::advance(__middle, __half);
                if (__comp(__val, __middle))
                    __len = __half;
                else {
                    __first = __middle;
                    ++__first;
                    __len = __len - __half - 1;
                }
            }
        return __first;
    }

;
    template <typename _ForwardIterator, typename _Tp> inline _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        ;
        return std::__upper_bound(__first, __last, __val, __gnu_cxx::__ops::__val_less_iter());
    }

;
    template <typename _ForwardIterator, typename _Tp, typename _Compare> inline _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        ;
        return std::__upper_bound(__first, __last, __val, __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

;
    template <typename _ForwardIterator, typename _Tp, typename _CompareItTp, typename _CompareTpIt> pair<_ForwardIterator, _ForwardIterator> __equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)     {
        typedef typename iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        _DistanceType __len = std::distance(__first, __last);
        while (__len > 0)
            {
                _DistanceType __half = __len >> 1;
                _ForwardIterator __middle = __first;
                std::advance(__middle, __half);
                if (__comp_it_val(__middle, __val)) {
                    __first = __middle;
                    ++__first;
                    __len = __len - __half - 1;
                } else if (__comp_val_it(__val, __middle))
                    __len = __half;
                else {
                    _ForwardIterator __left = std::__lower_bound(__first, __middle, __val, __comp_it_val);
                    std::advance(__first, __len);
                    _ForwardIterator __right = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
                    return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
                }
            }
        return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }

;
    template <typename _ForwardIterator, typename _Tp> inline pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        ;
        ;
        return std::__equal_range(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val(), __gnu_cxx::__ops::__val_less_iter());
    }

;
    template <typename _ForwardIterator, typename _Tp, typename _Compare> inline pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        ;
        ;
        return std::__equal_range(__first, __last, __val, __gnu_cxx::__ops::__iter_comp_val(__comp), __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

;
    template <typename _ForwardIterator, typename _Tp> bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        ;
        ;
        _ForwardIterator __i = std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
        return __i != __last && !(__val < *__i);
    }

;
    template <typename _ForwardIterator, typename _Tp, typename _Compare> bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        ;
        ;
        _ForwardIterator __i = std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_comp_val(__comp));
        return __i != __last && !bool(__comp(__val, *__i));
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare> void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)     {
        while (__first1 != __last1 && __first2 != __last2)
            {
                if (__comp(__first2, __first1)) {
                    *__result = (*__first2);
                    ++__first2;
                } else {
                    *__result = (*__first1);
                    ++__first1;
                }
                ++__result;
            }
        if (__first1 != __last1)
            std::copy(__first1, __last1, __result);
    }

;
    template <typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BidirectionalIterator3, typename _Compare> void __move_merge_adaptive_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result, _Compare __comp)     {
        if (__first1 == __last1) {
            std::copy_backward(__first2, __last2, __result);
            return;
        } else if (__first2 == __last2)
            return;
        --__last1;
        --__last2;
        while (true)
            {
                if (__comp(__last2, __last1)) {
                    *--__result = (*__last1);
                    if (__first1 == __last1) {
                        std::copy_backward(__first2, ++__last2, __result);
                        return;
                    }
                    --__last1;
                } else {
                    *--__result = (*__last2);
                    if (__first2 == __last2)
                        return;
                    --__last2;
                }
            }
    }

;
    template <typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _Distance> _BidirectionalIterator1 __rotate_adaptive(_BidirectionalIterator1 __first, _BidirectionalIterator1 __middle, _BidirectionalIterator1 __last, _Distance __len1, _Distance __len2, _BidirectionalIterator2 __buffer, _Distance __buffer_size)     {
        _BidirectionalIterator2 __buffer_end;
        if (__len1 > __len2 && __len2 <= __buffer_size) {
            if (__len2) {
                __buffer_end = std::copy(__middle, __last, __buffer);
                std::copy_backward(__first, __middle, __last);
                return std::copy(__buffer, __buffer_end, __first);
            } else
                return __first;
        } else if (__len1 <= __buffer_size) {
            if (__len1) {
                __buffer_end = std::copy(__first, __middle, __buffer);
                std::copy(__middle, __last, __first);
                return std::copy_backward(__buffer, __buffer_end, __last);
            } else
                return __last;
        } else {
            std::rotate(__first, __middle, __last);
            std::advance(__first, std::distance(__middle, __last));
            return __first;
        }
    }

;
    template <typename _BidirectionalIterator, typename _Distance, typename _Pointer, typename _Compare> void __merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)     {
        if (__len1 <= __len2 && __len1 <= __buffer_size) {
            _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
            std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last, __first, __comp);
        } else if (__len2 <= __buffer_size) {
            _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
            std::__move_merge_adaptive_backward(__first, __middle, __buffer, __buffer_end, __last, __comp);
        } else {
            _BidirectionalIterator __first_cut = __first;
            _BidirectionalIterator __second_cut = __middle;
            _Distance __len11 = 0;
            _Distance __len22 = 0;
            if (__len1 > __len2) {
                __len11 = __len1 / 2;
                std::advance(__first_cut, __len11);
                __second_cut = std::__lower_bound(__middle, __last, *__first_cut, __gnu_cxx::__ops::__iter_comp_val(__comp));
                __len22 = std::distance(__middle, __second_cut);
            } else {
                __len22 = __len2 / 2;
                std::advance(__second_cut, __len22);
                __first_cut = std::__upper_bound(__first, __middle, *__second_cut, __gnu_cxx::__ops::__val_comp_iter(__comp));
                __len11 = std::distance(__first, __first_cut);
            }
            _BidirectionalIterator __new_middle = std::__rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11, __len22, __buffer, __buffer_size);
            std::__merge_adaptive(__first, __first_cut, __new_middle, __len11, __len22, __buffer, __buffer_size, __comp);
            std::__merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __buffer, __buffer_size, __comp);
        }
    }

;
    template <typename _BidirectionalIterator, typename _Distance, typename _Compare> void __merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Compare __comp)     {
        if (__len1 == 0 || __len2 == 0)
            return;
        if (__len1 + __len2 == 2) {
            if (__comp(__middle, __first))
                std::iter_swap(__first, __middle);
            return;
        }
        _BidirectionalIterator __first_cut = __first;
        _BidirectionalIterator __second_cut = __middle;
        _Distance __len11 = 0;
        _Distance __len22 = 0;
        if (__len1 > __len2) {
            __len11 = __len1 / 2;
            std::advance(__first_cut, __len11);
            __second_cut = std::__lower_bound(__middle, __last, *__first_cut, __gnu_cxx::__ops::__iter_comp_val(__comp));
            __len22 = std::distance(__middle, __second_cut);
        } else {
            __len22 = __len2 / 2;
            std::advance(__second_cut, __len22);
            __first_cut = std::__upper_bound(__first, __middle, *__second_cut, __gnu_cxx::__ops::__val_comp_iter(__comp));
            __len11 = std::distance(__first, __first_cut);
        }
        std::rotate(__first_cut, __middle, __second_cut);
        _BidirectionalIterator __new_middle = __first_cut;
        std::advance(__new_middle, std::distance(__middle, __second_cut));
        std::__merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22, __comp);
        std::__merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __comp);
    }

;
    template <typename _BidirectionalIterator, typename _Compare> void __inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)     {
        typedef typename iterator_traits<_BidirectionalIterator>::value_type _ValueType;
        typedef typename iterator_traits<_BidirectionalIterator>::difference_type _DistanceType;
        if (__first == __middle || __middle == __last)
            return;
        const _DistanceType __len1 = std::distance(__first, __middle);
        const _DistanceType __len2 = std::distance(__middle, __last);
        typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
        _TmpBuf __buf(__first, __last);
        if (__buf.begin() == 0)
            std::__merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
        else
            std::__merge_adaptive(__first, __middle, __last, __len1, __len2, __buf.begin(), _DistanceType(__buf.size()), __comp);
    }

;
    template <typename _BidirectionalIterator> inline void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)     {
        ;
        ;
        std::__inplace_merge(__first, __middle, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _BidirectionalIterator, typename _Compare> inline void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)     {
        ;
        ;
        std::__inplace_merge(__first, __middle, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _InputIterator, typename _OutputIterator, typename _Compare> _OutputIterator __move_merge(_InputIterator __first1, _InputIterator __last1, _InputIterator __first2, _InputIterator __last2, _OutputIterator __result, _Compare __comp)     {
        while (__first1 != __last1 && __first2 != __last2)
            {
                if (__comp(__first2, __first1)) {
                    *__result = (*__first2);
                    ++__first2;
                } else {
                    *__result = (*__first1);
                    ++__first1;
                }
                ++__result;
            }
        return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
    }

;
    template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Distance, typename _Compare> void __merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size, _Compare __comp)     {
        const _Distance __two_step = 2 * __step_size;
        while (__last - __first >= __two_step)
            {
                __result = std::__move_merge(__first, __first + __step_size, __first + __step_size, __first + __two_step, __result, __comp);
                __first += __two_step;
            }
        __step_size = std::min(_Distance(__last - __first), __step_size);
        std::__move_merge(__first, __first + __step_size, __first + __step_size, __last, __result, __comp);
    }

;
    template <typename _RandomAccessIterator, typename _Distance, typename _Compare> void __chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size, _Compare __comp)     {
        while (__last - __first >= __chunk_size)
            {
                std::__insertion_sort(__first, __first + __chunk_size, __comp);
                __first += __chunk_size;
            }
        std::__insertion_sort(__first, __last, __comp);
    }

;
    enum  {
        _S_chunk_size = 7
    };
    template <typename _RandomAccessIterator, typename _Pointer, typename _Compare> void __merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Compare __comp)     {
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;
        const _Distance __len = __last - __first;
        const _Pointer __buffer_last = __buffer + __len;
        _Distance __step_size = _S_chunk_size;
        std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
        while (__step_size < __len)
            {
                std::__merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
                __step_size *= 2;
                std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
                __step_size *= 2;
            }
    }

;
    template <typename _RandomAccessIterator, typename _Pointer, typename _Distance, typename _Compare> void __stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)     {
        const _Distance __len = (__last - __first + 1) / 2;
        const _RandomAccessIterator __middle = __first + __len;
        if (__len > __buffer_size) {
            std::__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size, __comp);
            std::__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size, __comp);
        } else {
            std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
            std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
        }
        std::__merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), _Distance(__last - __middle), __buffer, __buffer_size, __comp);
    }

;
    template <typename _RandomAccessIterator, typename _Compare> void __inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        if (__last - __first < 15) {
            std::__insertion_sort(__first, __last, __comp);
            return;
        }
        _RandomAccessIterator __middle = __first + (__last - __first) / 2;
        std::__inplace_stable_sort(__first, __middle, __comp);
        std::__inplace_stable_sort(__middle, __last, __comp);
        std::__merge_without_buffer(__first, __middle, __last, __middle - __first, __last - __middle, __comp);
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _Compare> bool __includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)     {
        while (__first1 != __last1 && __first2 != __last2)
            if (__comp(__first2, __first1))
                return false;
            else if (__comp(__first1, __first2))
                ++__first1;
            else
                ++__first1 , ++__first2;
        return __first2 == __last2;
    }

;
    template <typename _InputIterator1, typename _InputIterator2> inline bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)     {
        ;
        ;
        return std::__includes(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _Compare> inline bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)     {
        ;
        ;
        return std::__includes(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _BidirectionalIterator, typename _Compare> bool __next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)     {
        if (__first == __last)
            return false;
        _BidirectionalIterator __i = __first;
        ++__i;
        if (__i == __last)
            return false;
        __i = __last;
        --__i;
        for (;;) {
            _BidirectionalIterator __ii = __i;
            --__i;
            if (__comp(__i, __ii)) {
                _BidirectionalIterator __j = __last;
                while (!__comp(__i, --__j))
                    {
                    }
                std::iter_swap(__i, __j);
                std::__reverse(__ii, __last, std::__iterator_category(__first));
                return true;
            }
            if (__i == __first) {
                std::__reverse(__first, __last, std::__iterator_category(__first));
                return false;
            }
        }
    }

;
    template <typename _BidirectionalIterator> inline bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)     {
        ;
        return std::__next_permutation(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _BidirectionalIterator, typename _Compare> inline bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)     {
        ;
        return std::__next_permutation(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _BidirectionalIterator, typename _Compare> bool __prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)     {
        if (__first == __last)
            return false;
        _BidirectionalIterator __i = __first;
        ++__i;
        if (__i == __last)
            return false;
        __i = __last;
        --__i;
        for (;;) {
            _BidirectionalIterator __ii = __i;
            --__i;
            if (__comp(__ii, __i)) {
                _BidirectionalIterator __j = __last;
                while (!__comp(--__j, __i))
                    {
                    }
                std::iter_swap(__i, __j);
                std::__reverse(__ii, __last, std::__iterator_category(__first));
                return true;
            }
            if (__i == __first) {
                std::__reverse(__first, __last, std::__iterator_category(__first));
                return false;
            }
        }
    }

;
    template <typename _BidirectionalIterator> inline bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)     {
        ;
        return std::__prev_permutation(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _BidirectionalIterator, typename _Compare> inline bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)     {
        ;
        return std::__prev_permutation(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _InputIterator, typename _OutputIterator, typename _Predicate, typename _Tp> _OutputIterator __replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp &__new_value)     {
        for (; __first != __last; ++__first , ++__result) 
            if (__pred(__first))
                *__result = __new_value;
            else
                *__result = *__first;
        return __result;
    }

;
    template <typename _InputIterator, typename _OutputIterator, typename _Tp> inline _OutputIterator replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__old_value, const _Tp &__new_value)     {
        ;
        return std::__replace_copy_if(__first, __last, __result, __gnu_cxx::__ops::__iter_equals_val(__old_value), __new_value);
    }

;
    template <typename _InputIterator, typename _OutputIterator, typename _Predicate, typename _Tp> inline _OutputIterator replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp &__new_value)     {
        ;
        return std::__replace_copy_if(__first, __last, __result, __gnu_cxx::__ops::__pred_iter(__pred), __new_value);
    }

;
    template <typename _InputIterator, typename _Predicate> typename iterator_traits<_InputIterator>::difference_type __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)     {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        for (; __first != __last; ++__first) 
            if (__pred(__first))
                ++__n;
        return __n;
    }

;
    template <typename _InputIterator, typename _Function> _Function for_each(_InputIterator __first, _InputIterator __last, _Function __f)     {
        ;
        for (; __first != __last; ++__first) 
            __f(*__first);
        return (__f);
    }

;
    template <typename _InputIterator, typename _Tp> inline _InputIterator find(_InputIterator __first, _InputIterator __last, const _Tp &__val)     {
        ;
        return std::__find_if(__first, __last, __gnu_cxx::__ops::__iter_equals_val(__val));
    }

;
    template <typename _InputIterator, typename _Predicate> inline _InputIterator find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)     {
        ;
        return std::__find_if(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred));
    }

;
    template <typename _InputIterator, typename _ForwardIterator> _InputIterator find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2)     {
        ;
        ;
        for (; __first1 != __last1; ++__first1) 
            for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter) 
                if (*__first1 == *__iter)
                    return __first1;
        return __last1;
    }

;
    template <typename _InputIterator, typename _ForwardIterator, typename _BinaryPredicate> _InputIterator find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, _BinaryPredicate __comp)     {
        ;
        ;
        for (; __first1 != __last1; ++__first1) 
            for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter) 
                if (__comp(*__first1, *__iter))
                    return __first1;
        return __last1;
    }

;
    template <typename _ForwardIterator> inline _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last)     {
        ;
        return std::__adjacent_find(__first, __last, __gnu_cxx::__ops::__iter_equal_to_iter());
    }

;
    template <typename _ForwardIterator, typename _BinaryPredicate> inline _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)     {
        ;
        return std::__adjacent_find(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }

;
    template <typename _InputIterator, typename _Tp> inline typename iterator_traits<_InputIterator>::difference_type count(_InputIterator __first, _InputIterator __last, const _Tp &__value)     {
        ;
        return std::__count_if(__first, __last, __gnu_cxx::__ops::__iter_equals_val(__value));
    }

;
    template <typename _InputIterator, typename _Predicate> inline typename iterator_traits<_InputIterator>::difference_type count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)     {
        ;
        return std::__count_if(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred));
    }

;
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)     {
        ;
        ;
        return std::__search(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }

;
    template <typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate> inline _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)     {
        ;
        ;
        return std::__search(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }

;
    template <typename _ForwardIterator, typename _Integer, typename _Tp> inline _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val)     {
        ;
        return std::__search_n(__first, __last, __count, __gnu_cxx::__ops::__iter_equals_val(__val));
    }

;
    template <typename _ForwardIterator, typename _Integer, typename _Tp, typename _BinaryPredicate> inline _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred)     {
        ;
        return std::__search_n(__first, __last, __count, __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }

;
    template <typename _InputIterator, typename _OutputIterator, typename _UnaryOperation> _OutputIterator transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __unary_op)     {
        ;
        for (; __first != __last; ++__first , ++__result) 
            *__result = __unary_op(*__first);
        return __result;
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _BinaryOperation> _OutputIterator transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _OutputIterator __result, _BinaryOperation __binary_op)     {
        ;
        for (; __first1 != __last1; ++__first1 , ++__first2 , ++__result) 
            *__result = __binary_op(*__first1, *__first2);
        return __result;
    }

;
    template <typename _ForwardIterator, typename _Tp> void replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__old_value, const _Tp &__new_value)     {
        ;
        for (; __first != __last; ++__first) 
            if (*__first == __old_value)
                *__first = __new_value;
    }

;
    template <typename _ForwardIterator, typename _Predicate, typename _Tp> void replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp &__new_value)     {
        ;
        for (; __first != __last; ++__first) 
            if (__pred(*__first))
                *__first = __new_value;
    }

;
    template <typename _ForwardIterator, typename _Generator> void generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)     {
        ;
        for (; __first != __last; ++__first) 
            *__first = __gen();
    }

;
    template <typename _OutputIterator, typename _Size, typename _Generator> _OutputIterator generate_n(_OutputIterator __first, _Size __n, _Generator __gen)     {
        for (decltype(__n + 0) __niter = __n; __niter > 0; --__niter , ++__first) 
            *__first = __gen();
        return __first;
    }

;
    template <typename _InputIterator, typename _OutputIterator> inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)     {
        ;
        if (__first == __last)
            return __result;
        return std::__unique_copy(__first, __last, __result, __gnu_cxx::__ops::__iter_equal_to_iter(), std::__iterator_category(__first), std::__iterator_category(__result));
    }

;
    template <typename _InputIterator, typename _OutputIterator, typename _BinaryPredicate> inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred)     {
        ;
        if (__first == __last)
            return __result;
        return std::__unique_copy(__first, __last, __result, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred), std::__iterator_category(__first), std::__iterator_category(__result));
    }

;
    template <typename _RandomAccessIterator> inline void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)     {
        ;
        if (__first != __last)
            for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) {
                _RandomAccessIterator __j = __first + std::rand() % ((__i - __first) + 1);
                if (__i != __j)
                    std::iter_swap(__i, __j);
            }
    }

;
    template <typename _RandomAccessIterator, typename _RandomNumberGenerator> void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator &__rand)     {
        ;
        if (__first == __last)
            return;
        for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) {
            _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
            if (__i != __j)
                std::iter_swap(__i, __j);
        }
    }

;
    template <typename _ForwardIterator, typename _Predicate> inline _ForwardIterator partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)     {
        ;
        return std::__partition(__first, __last, __pred, std::__iterator_category(__first));
    }

;
    template <typename _RandomAccessIterator> inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)     {
        ;
        ;
        std::__partial_sort(__first, __middle, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)     {
        ;
        ;
        std::__partial_sort(__first, __middle, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _RandomAccessIterator> inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)     {
        ;
        ;
        if (__first == __last || __nth == __last)
            return;
        std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)     {
        ;
        ;
        if (__first == __last || __nth == __last)
            return;
        std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _RandomAccessIterator> inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last)     {
        ;
        std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        ;
        std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare> _OutputIterator __merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)     {
        while (__first1 != __last1 && __first2 != __last2)
            {
                if (__comp(__first2, __first1)) {
                    *__result = *__first2;
                    ++__first2;
                } else {
                    *__result = *__first1;
                    ++__first1;
                }
                ++__result;
            }
        return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator> inline _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)     {
        ;
        ;
        return std::__merge(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare> inline _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)     {
        ;
        ;
        return std::__merge(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
        typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
        _TmpBuf __buf(__first, __last);
        if (__buf.begin() == 0)
            std::__inplace_stable_sort(__first, __last, __comp);
        else
            std::__stable_sort_adaptive(__first, __last, __buf.begin(), _DistanceType(__buf.size()), __comp);
    }

;
    template <typename _RandomAccessIterator> inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)     {
        ;
        std::__stable_sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _RandomAccessIterator, typename _Compare> inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)     {
        ;
        std::__stable_sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare> _OutputIterator __set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)     {
        while (__first1 != __last1 && __first2 != __last2)
            {
                if (__comp(__first1, __first2)) {
                    *__result = *__first1;
                    ++__first1;
                } else if (__comp(__first2, __first1)) {
                    *__result = *__first2;
                    ++__first2;
                } else {
                    *__result = *__first1;
                    ++__first1;
                    ++__first2;
                }
                ++__result;
            }
        return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator> inline _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)     {
        ;
        ;
        return std::__set_union(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare> inline _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)     {
        ;
        ;
        return std::__set_union(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare> _OutputIterator __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)     {
        while (__first1 != __last1 && __first2 != __last2)
            if (__comp(__first1, __first2))
                ++__first1;
            else if (__comp(__first2, __first1))
                ++__first2;
            else {
                *__result = *__first1;
                ++__first1;
                ++__first2;
                ++__result;
            }
        return __result;
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator> inline _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)     {
        ;
        ;
        return std::__set_intersection(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare> inline _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)     {
        ;
        ;
        return std::__set_intersection(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare> _OutputIterator __set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)     {
        while (__first1 != __last1 && __first2 != __last2)
            if (__comp(__first1, __first2)) {
                *__result = *__first1;
                ++__first1;
                ++__result;
            } else if (__comp(__first2, __first1))
                ++__first2;
            else {
                ++__first1;
                ++__first2;
            }
        return std::copy(__first1, __last1, __result);
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator> inline _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)     {
        ;
        ;
        return std::__set_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare> inline _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)     {
        ;
        ;
        return std::__set_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare> _OutputIterator __set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)     {
        while (__first1 != __last1 && __first2 != __last2)
            if (__comp(__first1, __first2)) {
                *__result = *__first1;
                ++__first1;
                ++__result;
            } else if (__comp(__first2, __first1)) {
                *__result = *__first2;
                ++__first2;
                ++__result;
            } else {
                ++__first1;
                ++__first2;
            }
        return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator> inline _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)     {
        ;
        ;
        return std::__set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare> inline _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)     {
        ;
        ;
        return std::__set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _ForwardIterator, typename _Compare> _ForwardIterator __min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)     {
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        while (++__first != __last)
            if (__comp(__first, __result))
                __result = __first;
        return __result;
    }

;
    template <typename _ForwardIterator> inline _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last)     {
        ;
        return std::__min_element(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _ForwardIterator, typename _Compare> inline _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)     {
        ;
        return std::__min_element(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
    template <typename _ForwardIterator, typename _Compare> _ForwardIterator __max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)     {
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        while (++__first != __last)
            if (__comp(__result, __first))
                __result = __first;
        return __result;
    }

;
    template <typename _ForwardIterator> inline _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last)     {
        ;
        return std::__max_element(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

;
    template <typename _ForwardIterator, typename _Compare> inline _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)     {
        ;
        return std::__max_element(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

;
}
namespace std {
    namespace __detail {
        struct _List_node_base {
            std::__detail::_List_node_base *_M_next;
            std::__detail::_List_node_base *_M_prev;
            static void swap(std::__detail::_List_node_base &__x, std::__detail::_List_node_base &__y) throw();
            void _M_transfer(std::__detail::_List_node_base *const __first, std::__detail::_List_node_base *const __last) throw();
            void _M_reverse() throw();
            void _M_hook(std::__detail::_List_node_base *const __position) throw();
            void _M_unhook() throw();
        };
    }
    template <typename _Tp = unsigned long> struct _List_node : public __detail::_List_node_base {
        unsigned long _M_data;
    }
template <typename _Tp = Player> struct _List_node : public __detail::_List_node_base {
        Player _M_data;
    }
template <typename _Tp> struct _List_node : public __detail::_List_node_base {
        _Tp _M_data;
    };
    template <typename _Tp = Player> struct _List_iterator {
        typedef _List_iterator<Player> _Self;
        typedef _List_node<Player> _Node;
        typedef ptrdiff_t difference_type;
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef Player value_type;
        typedef Player *pointer;
        typedef Player &reference;
        _List_iterator() : _M_node(/*implicit*/__detail::_List_node_base *())         {
        }


        explicit _List_iterator(__detail::_List_node_base *__x);
        _Self _M_const_cast() const;
        reference operator*() const         {
            return static_cast<_Node *>(this->_M_node)->_M_data;
        }


        pointer operator->() const         {
            return std::__addressof(static_cast<_Node *>(this->_M_node)->_M_data);
        }


        _Self &operator++();
        _Self operator++(int)         {
            _Self __tmp = *this;
            this->_M_node = this->_M_node->_M_next;
            return __tmp;
        }


        _Self &operator--()         {
            this->_M_node = this->_M_node->_M_prev;
            return *this;
        }


        _Self operator--(int);
        bool operator==(const _Self &__x) const;
        bool operator!=(const _Self &__x) const;
        __detail::_List_node_base *_M_node;
    }
template <typename _Tp> struct _List_iterator {
        typedef _List_iterator<_Tp> _Self;
        typedef _List_node<_Tp> _Node;
        typedef ptrdiff_t difference_type;
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef _Tp *pointer;
        typedef _Tp &reference;
        _List_iterator<_Tp>() : _M_node(/*implicit*/__detail::_List_node_base *())         {
        }


        explicit _List_iterator<_Tp>(__detail::_List_node_base *__x) : _M_node(__x)         {
        }


        _Self _M_const_cast() const         {
            return *this;
        }


        reference operator*() const         {
            return static_cast<_Node *>(this->_M_node)->_M_data;
        }


        pointer operator->() const         {
            return std::__addressof(static_cast<_Node *>(this->_M_node)->_M_data);
        }


        _Self &operator++()         {
            this->_M_node = this->_M_node->_M_next;
            return *this;
        }


        _Self operator++(int)         {
            _Self __tmp = *this;
            this->_M_node = this->_M_node->_M_next;
            return __tmp;
        }


        _Self &operator--()         {
            this->_M_node = this->_M_node->_M_prev;
            return *this;
        }


        _Self operator--(int)         {
            _Self __tmp = *this;
            this->_M_node = this->_M_node->_M_prev;
            return __tmp;
        }


        bool operator==(const _Self &__x) const         {
            return this->_M_node == __x._M_node;
        }


        bool operator!=(const _Self &__x) const         {
            return this->_M_node != __x._M_node;
        }


        __detail::_List_node_base *_M_node;
    };
    template <typename _Tp = Player> struct _List_const_iterator
template <typename _Tp> struct _List_const_iterator {
        typedef _List_const_iterator<_Tp> _Self;
        typedef const _List_node<_Tp> _Node;
        typedef _List_iterator<_Tp> iterator;
        typedef ptrdiff_t difference_type;
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef const _Tp *pointer;
        typedef const _Tp &reference;
        _List_const_iterator<_Tp>() : _M_node(/*implicit*/const __detail::_List_node_base *())         {
        }


        explicit _List_const_iterator<_Tp>(const __detail::_List_node_base *__x) : _M_node(__x)         {
        }


        _List_const_iterator<_Tp>(const iterator &__x) : _M_node(__x._M_node)         {
        }


        iterator _M_const_cast() const         {
            return iterator(const_cast<__detail::_List_node_base *>(this->_M_node));
        }


        reference operator*() const         {
            return static_cast<_Node *>(this->_M_node)->_M_data;
        }


        pointer operator->() const         {
            return std::__addressof(static_cast<_Node *>(this->_M_node)->_M_data);
        }


        _Self &operator++()         {
            this->_M_node = this->_M_node->_M_next;
            return *this;
        }


        _Self operator++(int)         {
            _Self __tmp = *this;
            this->_M_node = this->_M_node->_M_next;
            return __tmp;
        }


        _Self &operator--()         {
            this->_M_node = this->_M_node->_M_prev;
            return *this;
        }


        _Self operator--(int)         {
            _Self __tmp = *this;
            this->_M_node = this->_M_node->_M_prev;
            return __tmp;
        }


        bool operator==(const _Self &__x) const         {
            return this->_M_node == __x._M_node;
        }


        bool operator!=(const _Self &__x) const         {
            return this->_M_node != __x._M_node;
        }


        const __detail::_List_node_base *_M_node;
    };
    template <typename _Val> inline bool operator==(const _List_iterator<_Val> &__x, const _List_const_iterator<_Val> &__y)     {
        return __x._M_node == __y._M_node;
    }

;
    template <typename _Val> inline bool operator!=(const _List_iterator<_Val> &__x, const _List_const_iterator<_Val> &__y)     {
        return __x._M_node != __y._M_node;
    }

;
    inline namespace __cxx11 {
        template <typename _Tp = Player, typename _Alloc = std::allocator<Player>> class _List_base {
        protected:
            typedef typename allocator<Player>::rebind<_List_node<Player> >::other _Node_alloc_type;
            typedef typename allocator<Player>::rebind<Player>::other _Tp_alloc_type;
            static size_t _S_distance(const __detail::_List_node_base *__first, const __detail::_List_node_base *__last);
            struct _List_impl : public _Node_alloc_type {
                _List_node<size_t> _M_node;
                _List_impl();
                _List_impl(const _Node_alloc_type &__a);
            };
            std::__cxx11::_List_base<Player, std::allocator<Player> >::_List_impl _M_impl;
            size_t _M_get_size() const;
            void _M_set_size(size_t __n);
            void _M_inc_size(size_t __n);
            void _M_dec_size(size_t __n);
            size_t _M_distance(const __detail::_List_node_base *__first, const __detail::_List_node_base *__last) const;
            size_t _M_node_count() const;
            _List_node<Player> *_M_get_node();
            void _M_put_node(_List_node<Player> *__p);
        public:
            typedef std::allocator<Player> allocator_type;
            _Node_alloc_type &_M_get_Node_allocator();
            const _Node_alloc_type &_M_get_Node_allocator() const;
            _Tp_alloc_type _M_get_Tp_allocator() const;
            allocator_type get_allocator() const;
            _List_base();
            _List_base(const _Node_alloc_type &__a);
            ~std::__cxx11::_List_base<Player, std::allocator<Player> >();
            void _M_clear();
            void _M_init();
        }
template <typename _Tp, typename _Alloc> class _List_base {
        protected:
            typedef typename _Alloc::template _Alloc::rebind<_List_node<_Tp> >::other _Node_alloc_type;
            typedef typename _Alloc::template _Alloc::rebind<_Tp>::other _Tp_alloc_type;
            static size_t _S_distance(const __detail::_List_node_base *__first, const __detail::_List_node_base *__last)             {
                size_t __n = 0;
                while (__first != __last)
                    {
                        __first = __first->_M_next;
                        ++__n;
                    }
                return __n;
            }


            struct _List_impl : public _Node_alloc_type {
                _List_node<size_t> _M_node;
                _List_impl() : _Node_alloc_type(), _M_node()                 {
                }


                _List_impl(const _Node_alloc_type &__a) : _Node_alloc_type(__a), _M_node()                 {
                }


            };
            std::__cxx11::_List_base::_List_impl _M_impl;
            size_t _M_get_size() const             {
                return this->_M_impl._M_node._M_data;
            }


            void _M_set_size(size_t __n)             {
                this->_M_impl._M_node._M_data = __n;
            }


            void _M_inc_size(size_t __n)             {
                this->_M_impl._M_node._M_data += __n;
            }


            void _M_dec_size(size_t __n)             {
                this->_M_impl._M_node._M_data -= __n;
            }


            size_t _M_distance(const __detail::_List_node_base *__first, const __detail::_List_node_base *__last) const             {
                return _S_distance(__first, __last);
            }


            size_t _M_node_count() const             {
                return this->_M_impl._M_node._M_data;
            }


            _List_node<_Tp> *_M_get_node()             {
                return this->_M_impl._Node_alloc_type::allocate(1);
            }


            void _M_put_node(_List_node<_Tp> *__p)             {
                this->_M_impl._Node_alloc_type::deallocate(__p, 1);
            }


        public:
            typedef _Alloc allocator_type;
            _Node_alloc_type &_M_get_Node_allocator()             {
                return *static_cast<_Node_alloc_type *>(& this->_M_impl);
            }


            const _Node_alloc_type &_M_get_Node_allocator() const             {
                return *static_cast<const _Node_alloc_type *>(& this->_M_impl);
            }


            _Tp_alloc_type _M_get_Tp_allocator() const             {
                return _Tp_alloc_type(_M_get_Node_allocator());
            }


            allocator_type get_allocator() const             {
                return allocator_type(_M_get_Node_allocator());
            }


            _List_base<_Tp, _Alloc>() : _M_impl()             {
                this->_M_init();
            }


            _List_base<_Tp, _Alloc>(const _Node_alloc_type &__a) : _M_impl(__a)             {
                this->_M_init();
            }


            ~_List_base<_Tp, _Alloc>()             {
                this->_M_clear();
            }


            void _M_clear();
            void _M_init()             {
                this->_M_impl._M_node._M_next = & this->_M_impl._M_node;
                this->_M_impl._M_node._M_prev = & this->_M_impl._M_node;
                this->_M_set_size(0);
            }


        };
        template <typename _Tp = Player, typename _Alloc = std::allocator<Player>> class list : protected _List_base<Player, std::allocator<Player> > {
            typedef typename allocator<Player>::value_type _Alloc_value_type;
            typedef _List_base<Player, std::allocator<Player> > _Base;
            typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
            typedef typename _Base::_Node_alloc_type _Node_alloc_type;
        public:
            typedef Player value_type;
            typedef typename _Tp_alloc_type::pointer pointer;
            typedef typename _Tp_alloc_type::const_pointer const_pointer;
            typedef typename _Tp_alloc_type::reference reference;
            typedef typename _Tp_alloc_type::const_reference const_reference;
            typedef _List_iterator<Player> iterator;
            typedef _List_const_iterator<Player> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef std::allocator<Player> allocator_type;
        protected:
            typedef _List_node<Player> _Node;
            using _Base::_M_impl;
            using _Base::_M_put_node;
            using _Base::_M_get_node;
            using _Base::_M_get_Tp_allocator;
            using _Base::_M_get_Node_allocator;
            _Node *_M_create_node(const value_type &__x);
        public:
            list();
            explicit list(const allocator_type &__a);
            explicit list(size_type __n, const value_type &__value, const allocator_type &__a);
            list(const std::__cxx11::list<Player, std::allocator<Player> > &__x);
            template <typename _InputIterator> list(_InputIterator __first, _InputIterator __last, const allocator_type &__a);
            std::__cxx11::list<Player, std::allocator<Player> > &operator=(const std::__cxx11::list<Player, std::allocator<Player> > &__x);
            void assign(size_type __n, const value_type &__val);
            template <typename _InputIterator> void assign(_InputIterator __first, _InputIterator __last);
            allocator_type get_allocator() const;
            iterator begin();
            const_iterator begin() const;
            iterator end();
            const_iterator end() const;
            reverse_iterator rbegin();
            const_reverse_iterator rbegin() const;
            reverse_iterator rend();
            const_reverse_iterator rend() const;
            bool empty() const;
            size_type size() const;
            size_type max_size() const;
            void resize(size_type __new_size, value_type __x);
            reference front();
            const_reference front() const;
            reference back();
            const_reference back() const;
            void push_front(const value_type &__x);
            void pop_front();
            void push_back(const value_type &__x);
            void pop_back();
            iterator insert(iterator __position, const value_type &__x);
            void insert(iterator __position, size_type __n, const value_type &__x);
            template <typename _InputIterator> void insert(iterator __position, _InputIterator __first, _InputIterator __last);
            iterator erase(iterator __position);
            iterator erase(iterator __first, iterator __last);
            void swap(std::__cxx11::list<Player, std::allocator<Player> > &__x);
            void clear();
            void splice(iterator __position, std::__cxx11::list<Player, std::allocator<Player> > &__x);
            void splice(iterator __position, std::__cxx11::list<Player, std::allocator<Player> > &__x, iterator __i);
            void splice(iterator __position, std::__cxx11::list<Player, std::allocator<Player> > &__x, iterator __first, iterator __last);
            void remove(const Player &__value);
            template <typename _Predicate> void remove_if(_Predicate);
            void unique();
            template <typename _BinaryPredicate> void unique(_BinaryPredicate);
            void merge(std::__cxx11::list<Player, std::allocator<Player> > &__x);
            template <typename _StrictWeakOrdering> void merge(std::__cxx11::list<Player, std::allocator<Player> > &__x, _StrictWeakOrdering __comp);
            void reverse();
            void sort();
            template <typename _StrictWeakOrdering> void sort(_StrictWeakOrdering);
        protected:
            template <typename _Integer> void _M_initialize_dispatch(_Integer __n, _Integer __x, std::__true_type);
            template <typename _InputIterator> void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, std::__false_type);
            void _M_fill_initialize(size_type __n, const value_type &__x);
            template <typename _Integer> void _M_assign_dispatch(_Integer __n, _Integer __val, std::__true_type);
            template <typename _InputIterator> void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, std::__false_type);
            void _M_fill_assign(size_type __n, const value_type &__val);
            void _M_transfer(iterator __position, iterator __first, iterator __last);
            void _M_insert(iterator __position, const value_type &__x);
            void _M_erase(iterator __position);
            void _M_check_equal_allocators(std::__cxx11::list<Player, std::allocator<Player> > &__x);
        }
template <typename _Tp, typename _Alloc = std::allocator<_Tp>> class list : protected _List_base<_Tp, _Alloc> {
            typedef typename _Alloc::value_type _Alloc_value_type;
            typedef _List_base<_Tp, _Alloc> _Base;
            typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
            typedef typename _Base::_Node_alloc_type _Node_alloc_type;
        public:
            typedef _Tp value_type;
            typedef typename _Tp_alloc_type::pointer pointer;
            typedef typename _Tp_alloc_type::const_pointer const_pointer;
            typedef typename _Tp_alloc_type::reference reference;
            typedef typename _Tp_alloc_type::const_reference const_reference;
            typedef _List_iterator<_Tp> iterator;
            typedef _List_const_iterator<_Tp> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef _Alloc allocator_type;
        protected:
            typedef _List_node<_Tp> _Node;
            using _Base::_M_impl;
            using _Base::_M_put_node;
            using _Base::_M_get_node;
            using _Base::_M_get_Tp_allocator;
            using _Base::_M_get_Node_allocator;
            _Node *_M_create_node(const value_type &__x)             {
                _Node *__p = this->_M_get_node();
                try {
                    _M_get_Tp_allocator().construct(std::__addressof(__p->_M_data), __x);
                } catch (...) {
                    _M_put_node(__p);
                    throw;
                }
                return __p;
            }


        public:
            list<_Tp, _Alloc>() : _Base()             {
            }


            explicit list<_Tp, _Alloc>(const allocator_type &__a) : _Base(_Node_alloc_type(__a))             {
            }


            explicit list<_Tp, _Alloc>(size_type __n, const value_type &__value = value_type(), const allocator_type &__a = allocator_type()) : _Base(_Node_alloc_type(__a))             {
                this->_M_fill_initialize(__n, __value);
            }


            list<_Tp, _Alloc>(const list<_Tp, _Alloc> &__x) : _Base(__x._M_get_Node_allocator())             {
                _M_initialize_dispatch(__x.begin(), __x.end(), std::__false_type());
            }


            template <typename _InputIterator> list<_Tp, _Alloc>(_InputIterator __first, _InputIterator __last, const allocator_type &__a = allocator_type()) : _Base(_Node_alloc_type(__a))             {
                typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                _M_initialize_dispatch(__first, __last, _Integral());
            }

;
            list<_Tp, _Alloc> &operator=(const list<_Tp, _Alloc> &__x);
            void assign(size_type __n, const value_type &__val)             {
                this->_M_fill_assign(__n, __val);
            }


            template <typename _InputIterator> void assign(_InputIterator __first, _InputIterator __last)             {
                typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                _M_assign_dispatch(__first, __last, _Integral());
            }

;
            allocator_type get_allocator() const             {
                return _Base::get_allocator();
            }


            iterator begin()             {
                return iterator(this->_M_impl._M_node._M_next);
            }


            const_iterator begin() const             {
                return const_iterator(this->_M_impl._M_node._M_next);
            }


            iterator end()             {
                return iterator(& this->_M_impl._M_node);
            }


            const_iterator end() const             {
                return const_iterator(& this->_M_impl._M_node);
            }


            reverse_iterator rbegin()             {
                return reverse_iterator(end());
            }


            const_reverse_iterator rbegin() const             {
                return const_reverse_iterator(end());
            }


            reverse_iterator rend()             {
                return reverse_iterator(begin());
            }


            const_reverse_iterator rend() const             {
                return const_reverse_iterator(begin());
            }


            bool empty() const             {
                return this->_M_impl._M_node._M_next == & this->_M_impl._M_node;
            }


            size_type size() const             {
                return this->_M_node_count();
            }


            size_type max_size() const             {
                return _M_get_Node_allocator().max_size();
            }


            void resize(size_type __new_size, value_type __x = value_type());
            reference front()             {
                return *begin();
            }


            const_reference front() const             {
                return *begin();
            }


            reference back()             {
                iterator __tmp = end();
                --__tmp;
                return *__tmp;
            }


            const_reference back() const             {
                const_iterator __tmp = end();
                --__tmp;
                return *__tmp;
            }


            void push_front(const value_type &__x)             {
                this->_M_insert(begin(), __x);
            }


            void pop_front()             {
                this->_M_erase(begin());
            }


            void push_back(const value_type &__x)             {
                this->_M_insert(end(), __x);
            }


            void pop_back()             {
                this->_M_erase(iterator(this->_M_impl._M_node._M_prev));
            }


            iterator insert(iterator __position, const value_type &__x);
            void insert(iterator __position, size_type __n, const value_type &__x)             {
                list<_Tp, _Alloc> __tmp(__n, __x, this->get_allocator());
                splice(__position, __tmp);
            }


            template <typename _InputIterator> void insert(iterator __position, _InputIterator __first, _InputIterator __last)             {
                list<_Tp, _Alloc> __tmp(__first, __last, this->get_allocator());
                splice(__position, __tmp);
            }

;
            iterator erase(iterator __position);
            iterator erase(iterator __first, iterator __last)             {
                while (__first != __last)
                    __first = erase(__first);
                return __last._M_const_cast();
            }


            void swap(list<_Tp, _Alloc> &__x)             {
                __detail::_List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);
                size_t __xsize = __x._M_get_size();
                __x._M_set_size(this->_M_get_size());
                this->_M_set_size(__xsize);
                std::__alloc_swap<typename _Base::_Node_alloc_type>::_S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
            }


            void clear()             {
                _Base::_M_clear();
                _Base::_M_init();
            }


            void splice(iterator __position, list<_Tp, _Alloc> &__x)             {
                if (!__x.empty()) {
                    this->_M_check_equal_allocators(__x);
                    this->_M_transfer(__position._M_const_cast(), __x.begin(), __x.end());
                    this->_M_inc_size(__x._M_get_size());
                    __x._M_set_size(0);
                }
            }


            void splice(iterator __position, list<_Tp, _Alloc> &__x, iterator __i)             {
                iterator __j = __i._M_const_cast();
                ++__j;
                if (__position == __i || __position == __j)
                    return;
                if (this != & __x)
                    this->_M_check_equal_allocators(__x);
                this->_M_transfer(__position._M_const_cast(), __i._M_const_cast(), __j);
                this->_M_inc_size(1);
                __x._M_dec_size(1);
            }


            void splice(iterator __position, list<_Tp, _Alloc> &__x, iterator __first, iterator __last)             {
                if (__first != __last) {
                    if (this != & __x)
                        this->_M_check_equal_allocators(__x);
                    size_t __n = this->_M_distance(__first._M_node, __last._M_node);
                    this->_M_inc_size(__n);
                    __x._M_dec_size(__n);
                    this->_M_transfer(__position._M_const_cast(), __first._M_const_cast(), __last._M_const_cast());
                }
            }


            void remove(const _Tp &__value);
            template <typename _Predicate> void remove_if(_Predicate);
            void unique();
            template <typename _BinaryPredicate> void unique(_BinaryPredicate);
            void merge(list<_Tp, _Alloc> &__x);
            template <typename _StrictWeakOrdering> void merge(list<_Tp, _Alloc> &__x, _StrictWeakOrdering __comp);
            void reverse()             {
                this->_M_impl._M_node._M_reverse();
            }


            void sort();
            template <typename _StrictWeakOrdering> void sort(_StrictWeakOrdering);
        protected:
            template <typename _Integer> void _M_initialize_dispatch(_Integer __n, _Integer __x, std::__true_type)             {
                this->_M_fill_initialize(static_cast<size_type>(__n), __x);
            }

;
            template <typename _InputIterator> void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, std::__false_type)             {
                for (; __first != __last; ++__first) 
                    this->push_back(*__first);
            }

;
            void _M_fill_initialize(size_type __n, const value_type &__x)             {
                for (; __n; --__n) 
                    this->push_back(__x);
            }


            template <typename _Integer> void _M_assign_dispatch(_Integer __n, _Integer __val, std::__true_type)             {
                this->_M_fill_assign(__n, __val);
            }

;
            template <typename _InputIterator> void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, std::__false_type);
            void _M_fill_assign(size_type __n, const value_type &__val);
            void _M_transfer(iterator __position, iterator __first, iterator __last)             {
                __position._M_node->_M_transfer(__first._M_node, __last._M_node);
            }


            void _M_insert(iterator __position, const value_type &__x)             {
                _Node *__tmp = this->_M_create_node(__x);
                __tmp->_M_hook(__position._M_node);
                this->_M_inc_size(1);
            }


            void _M_erase(iterator __position)             {
                this->_M_dec_size(1);
                __position._M_node->_M_unhook();
                _Node *__n = static_cast<_Node *>(__position._M_node);
                _M_get_Tp_allocator().destroy(std::__addressof(__n->_M_data));
                _M_put_node(__n);
            }


            void _M_check_equal_allocators(list<_Tp, _Alloc> &__x)             {
                if (std::__alloc_neq<typename _Base::_Node_alloc_type>::_S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
                    __builtin_abort();
            }


        };
    }
    template <typename _Tp, typename _Alloc> inline bool operator==(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y)     {
        typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
        const_iterator __end1 = __x.end();
        const_iterator __end2 = __y.end();
        const_iterator __i1 = __x.begin();
        const_iterator __i2 = __y.begin();
        while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
            {
                ++__i1;
                ++__i2;
            }
        return __i1 == __end1 && __i2 == __end2;
    }

;
    template <typename _Tp, typename _Alloc> inline bool operator<(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y)     {
        return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
    }

;
    template <typename _Tp, typename _Alloc> inline bool operator!=(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y)     {
        return !(__x == __y);
    }

;
    template <typename _Tp, typename _Alloc> inline bool operator>(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y)     {
        return __y < __x;
    }

;
    template <typename _Tp, typename _Alloc> inline bool operator<=(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y)     {
        return !(__y < __x);
    }

;
    template <typename _Tp, typename _Alloc> inline bool operator>=(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y)     {
        return !(__x < __y);
    }

;
    template <typename _Tp, typename _Alloc> inline void swap(list<_Tp, _Alloc> &__x, list<_Tp, _Alloc> &__y)     {
        __x.swap(__y);
    }

;
}
namespace std {
    void _M_clear()     {
        typedef _List_node<_Tp> _Node;
        __detail::_List_node_base *__cur = this->_M_impl._M_node._M_next;
        while (__cur != & this->_M_impl._M_node)
            {
                _Node *__tmp = static_cast<_Node *>(__cur);
                __cur = __tmp->_M_next;
                this->_M_get_Tp_allocator().destroy(std::__addressof(__tmp->_M_data));
                this->_M_put_node(__tmp);
            }
    }


    typename list<_Tp, _Alloc>::iterator insert(iterator __position, const value_type &__x)     {
        _Node *__tmp = this->_M_create_node(__x);
        __tmp->_M_hook(__position._M_const_cast()._M_node);
        this->_M_inc_size(1);
        return iterator(__tmp);
    }


    typename list<_Tp, _Alloc>::iterator erase(iterator __position)     {
        iterator __ret = iterator(__position._M_node->_M_next);
        this->_M_erase(__position._M_const_cast());
        return __ret;
    }


    void resize(size_type __new_size, value_type __x = value_type())     {
        iterator __i = begin();
        size_type __len = 0;
        for (; __i != end() && __len < __new_size; ++__i , ++__len) 
            ;
        if (__len == __new_size)
            erase(__i, end());
        else
            insert(end(), __new_size - __len, __x);
    }


    list<_Tp, _Alloc> &operator=(const list<_Tp, _Alloc> &__x)     {
        if (this != & __x) {
            iterator __first1 = begin();
            iterator __last1 = end();
            const_iterator __first2 = __x.begin();
            const_iterator __last2 = __x.end();
            for (; __first1 != __last1 && __first2 != __last2; ++__first1 , ++__first2) 
                *__first1 = *__first2;
            if (__first2 == __last2)
                erase(__first1, __last1);
            else
                insert(__last1, __first2, __last2);
        }
        return *this;
    }


    void _M_fill_assign(size_type __n, const value_type &__val)     {
        iterator __i = begin();
        for (; __i != end() && __n > 0; ++__i , --__n) 
            *__i = __val;
        if (__n > 0)
            insert(end(), __n, __val);
        else
            erase(__i, end());
    }


    template <typename _InputIterator> void _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2, std::__false_type)     {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , ++__first2) 
            *__first1 = *__first2;
        if (__first2 == __last2)
            erase(__first1, __last1);
        else
            insert(__last1, __first2, __last2);
    }

;
    void remove(const value_type &__value)     {
        iterator __first = begin();
        iterator __last = end();
        iterator __extra = __last;
        while (__first != __last)
            {
                iterator __next = __first;
                ++__next;
                if (*__first == __value) {
                    if (std::__addressof(*__first) != std::__addressof(__value))
                        this->_M_erase(__first);
                    else
                        __extra = __first;
                }
                __first = __next;
            }
        if (__extra != __last)
            this->_M_erase(__extra);
    }


    void unique()     {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
            return;
        iterator __next = __first;
        while (++__next != __last)
            {
                if (*__first == *__next)
                    this->_M_erase(__next);
                else
                    __first = __next;
                __next = __first;
            }
    }


    void merge(list<_Tp, _Alloc> &__x)     {
        if (this != & __x) {
            this->_M_check_equal_allocators(__x);
            iterator __first1 = begin();
            iterator __last1 = end();
            iterator __first2 = __x.begin();
            iterator __last2 = __x.end();
            while (__first1 != __last1 && __first2 != __last2)
                if (*__first2 < *__first1) {
                    iterator __next = __first2;
                    this->_M_transfer(__first1, __first2, ++__next);
                    __first2 = __next;
                } else
                    ++__first1;
            if (__first2 != __last2)
                this->_M_transfer(__last1, __first2, __last2);
            this->_M_inc_size(__x._M_get_size());
            __x._M_set_size(0);
        }
    }


    template <typename _StrictWeakOrdering> void merge(list<_Tp, _Alloc> &__x, _StrictWeakOrdering __comp)     {
        if (this != & __x) {
            this->_M_check_equal_allocators(__x);
            iterator __first1 = begin();
            iterator __last1 = end();
            iterator __first2 = __x.begin();
            iterator __last2 = __x.end();
            while (__first1 != __last1 && __first2 != __last2)
                if (__comp(*__first2, *__first1)) {
                    iterator __next = __first2;
                    this->_M_transfer(__first1, __first2, ++__next);
                    __first2 = __next;
                } else
                    ++__first1;
            if (__first2 != __last2)
                this->_M_transfer(__last1, __first2, __last2);
            this->_M_inc_size(__x._M_get_size());
            __x._M_set_size(0);
        }
    }

;
    void sort()     {
        if (this->_M_impl._M_node._M_next != & this->_M_impl._M_node && this->_M_impl._M_node._M_next->_M_next != & this->_M_impl._M_node) {
            list<_Tp, _Alloc> __carry;
            list<_Tp, _Alloc> __tmp[64];
            list<_Tp, _Alloc> *__fill = & __tmp[0];
            list<_Tp, _Alloc> *__counter;
            do {
                __carry.splice(__carry.begin(), *this, begin());
                for (__counter = & __tmp[0]; __counter != __fill && !__counter->empty(); ++__counter) {
                    __counter->merge(__carry);
                    __carry.swap(*__counter);
                }
                __carry.swap(*__counter);
                if (__counter == __fill)
                    ++__fill;
            } while (!this->empty());
            for (__counter = & __tmp[1]; __counter != __fill; ++__counter) 
                __counter->merge(*(__counter - 1));
            this->swap(*(__fill - 1));
        }
    }


    template <typename _Predicate> void remove_if(_Predicate __pred)     {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
            {
                iterator __next = __first;
                ++__next;
                if (__pred(*__first))
                    this->_M_erase(__first);
                __first = __next;
            }
    }

;
    template <typename _BinaryPredicate> void unique(_BinaryPredicate __binary_pred)     {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
            return;
        iterator __next = __first;
        while (++__next != __last)
            {
                if (__binary_pred(*__first, *__next))
                    this->_M_erase(__next);
                else
                    __first = __next;
                __next = __first;
            }
    }

;
    template <typename _StrictWeakOrdering> void sort(_StrictWeakOrdering __comp)     {
        if (this->_M_impl._M_node._M_next != & this->_M_impl._M_node && this->_M_impl._M_node._M_next->_M_next != & this->_M_impl._M_node) {
            list<_Tp, _Alloc> __carry;
            list<_Tp, _Alloc> __tmp[64];
            list<_Tp, _Alloc> *__fill = & __tmp[0];
            list<_Tp, _Alloc> *__counter;
            do {
                __carry.splice(__carry.begin(), *this, begin());
                for (__counter = & __tmp[0]; __counter != __fill && !__counter->empty(); ++__counter) {
                    __counter->merge(__carry, __comp);
                    __carry.swap(*__counter);
                }
                __carry.swap(*__counter);
                if (__counter == __fill)
                    ++__fill;
            } while (!this->empty());
            for (__counter = & __tmp[1]; __counter != __fill; ++__counter) 
                __counter->merge(*(__counter - 1), __comp);
            this->swap(*(__fill - 1));
        }
    }

;
}
struct Player {
    int id;
    int points;
    std::string name;
    Player(int playerId, std::string playerName) : id(playerId), name(playerName)     {
        this->points = 0;
    }


    void addPoints(int p)     {
        this->points += p;
    }


};
int main() {
    std::list<Player> listofPlayers;
    std::cout << "*******Iterate std::list using Iterators*******" << std::endl;
    std::list<Player>::iterator it;
    for (;; it ++) {
        int id = it->id;
        std::string name = it->name;
        it->addPoints(2);
        std::cout << id << " :: " << name << std::endl;
    }
    std::cout << "*******Iterate std::list using for_each and c++11's Lambda function *********" << std::endl;
    std::cout << "*******Iterate std::list using c++11 Range Based For Loop *********" << std::endl;
    std::cout << "*******Iterate std::list in backwords using Iterators *********" << std::endl;
    std::list<Player>::reverse_iterator revIt;
    for (;; revIt ++) {
        int id = revIt->id;
        std::string name = revIt->name;
        revIt->addPoints(9);
        std::cout << id << " :: " << name << std::endl;
    }
    return 0;
}


