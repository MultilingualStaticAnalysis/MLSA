#!/usr/bin/env python
# MLSA Multilingual Software Analysis
# This program is part of the MLSA package under development at Fordham University Department of Computer and Information Science.
# pyFunCall.py takes in the JSON ast file generated by pySA.py. The program walks through the JSON file to find all the function calls in the Python program. The program also finds the scope of the call (if it is found inside another function definition or in the main body of the program), the class of the call (if it is a member function -> if not, class is GLOBAL), and the arguments of the call
# Author: Anne Marie Bogar
# Date: June 8, 2017
# this code can be copied or used and is without warrenty or support, but this header needs to be copied along with the program FU2017
# Input: JSON file of Python program's ast
# Output: csv file
#		call_id(int),class(string),scope(string),function_name(string),argument1(string),argument2(string)...
# for arguments, all literals are encased in <> (ex: <5>) and all variables have their line number attached (ex: var-6)
# function calls that are arguments of another function call have their id next to () in csv line of the other function call
#               ex: 6,GLOBAL,file.py,function1,function2()4
# commas in list-type arguments are replaced with |
#               ex: [element1|element2|element3]
# Documentation for the Python AST can be found here: https://docs.python.org/2/library/ast.html

import sys
import os
import commands
import json
import csv

error = 'MLSA: cFunCall; '
calls = []
functions = []
fileFunctions = []
LAST_ELEMENT = -1
#Island Grammar Indices
ISLAND_GRAMMAR_CALLS = 1
ISLAND_GRAMMAR_FUNCS = 1
ISLAND_GRAMMAR_STATUS = 0
#Call Indices
CALL_ID = 0
CALL_SCOPE = 1
CALL_NAME = 2
#Function Indices
FUNC_FILE = 0

def collectCalls(astfile):
	global calls
	i = commands.getstatusoutput("./test < "+astfile)
	if i[ISLAND_GRAMMAR_STATUS] == 0 and i[ISLAND_GRAMMAR_CALLS] != "" and "syntax error" not in i[ISLAND_GRAMMAR_CALLS]:
		c = i[ISLAND_GRAMMAR_CALLS].split('\n')
		for d in c:
			#id,scope,name,args...
			calls.append(d.split(','))
	if "syntax error" in i[ISLAND_GRAMMAR_CALLS]:
		print "syntax error"

def refineCalls(cfile):
	global calls
	for c in calls:
		if c[CALL_SCOPE] == "main":
			c[CALL_SCOPE] = cfile

def collectFuncs(astfile):
	global functions
	i = commands.getstatusoutput("./cFuncDecl < "+astfile)
	if i[ISLAND_GRAMMAR_STATUS] == 0 and i[ISLAND_GRAMMAR_FUNCS] != "" and "syntax error" not in i[ISLAND_GRAMMAR_FUNCS]:
		c = i[ISLAND_GRAMMAR_FUNCS].split('\n')
		for d in c:
			functions.append(d.split(','))
	if "syntax error" in i[ISLAND_GRAMMAR_CALLS]:
		print "syntax error"

def refineFuncs(cfile):
	global fileFunctions
	for f in functions:
		add = True
		if cfile in f[FUNC_FILE]:
			for ff in fileFunctions:
				if (ff[0] == f[0]) and (ff[1] == f[1]) and (ff[2] == f[2]) and (ff[3] == f[3]):
					add = False
			if add:
				fileFunctions.append(f)

def printCalls(csvfile):
	try:
		with open(csvfile, 'w') as f:
			writer = csv.writer(f)
			writer.writerows(calls)
	except IOError:
		sys.exit(error+"problem writing Function Call csv file")

def printFuncs(funcfile):
	try:
		with open(funcfile, 'a') as f:
			writer = csv.writer(f)
			writer.writerows(fileFunctions)
	except IOError:
		sys.exit(error+"problem writing Function csv file")

def main(astfile, cfile, funcfile):
	collectCalls(astfile)
	refineCalls(cfile)
	collectFuncs(astfile)
	refineFuncs(cfile)
	printCalls(cfile+"_call.csv")
	printFuncs(funcfile)



if len(sys.argv) < 2:
    sys.exit(ERROR+"arguments needed")

main(sys.argv[1], sys.argv[2], sys.argv[3])