#!/usr/bin/env python
# MLSA Multilingual Software Analysis
# This program is part of the MLSA package under development at Fordham University Department of Computer and Information Science.
# generateDOT.py takes in the csv file generated by mergeFunCall. The program creates a tree structure to visualize the csv file from mergeFunCall, and then writes to a dot file that then generates a pdf of the tree through GraphViz
# Author: Anne Marie Bogar
# Date: November 13, 2017
# this code can be copied or used and is without warrenty or support, but this header needs to be copied along with the program FU2017
# Input: csv file
#		program_type(int),program_name(string),included_program_name(string)
# Output: dot file
#		Node0x859365863 [shape=rectangle, label="file1.py"];
#	        Node0x120389922 [shape=rectangle, label="0. (file2.py) \n function(arg)"];
#	        Node0x859365863 -> Node0x120389922;

import random
import os
import csv
import sys
import config

#global variables
ERROR = 'MLSA: generateIncludeDOT; '
excludeFile = 'excluded_files.txt'
for p in os.environ['PATH'].split(':'):
    if "mlsa/metrics" in p:
        excludeFile = p+'/'+excludeFile
        break
IDlist = {} #all the unique Node IDS
system = [] #all the programs in the system being analyzed
functionIncludes = [] #list of includes and programs to be printed out to graph
dot = ''
exclude = []
#csvfile = os.getcwd()+"/includes.csv"
#dotfile = os.getcwd()+'/includes.dot'
#title = os.getcwd()
#CSV file from mergeFunCall Indices
CSV_PROGRAM_TYPE_FIELD = 0
CSV_MAIN_PROGRAM_FIELD = 1
CSV_INCLUDED_PROGRAM_FIELD = 2
#Extension Indices
C_EXT = H_EXT = -1
CPP_EXT = HPP_EXT = -3
PY_EXT = JS_EXT = -2
#Specific Element Indices
LAST_ELEMENT = -1
FIRST_ELEMENT = 1
ERROR_NODE_NAME = 2

#------------------------------Include Class-----------------------------#

class Include:
    def __init__(self, name, ID, program, pType, parentName, parentID, ind=False):
        #for print Flow and Node
        self.name = name
        self.ID = ID
        self.parentName = parentName
        self.parentID = parentID
        #for determining shape
        self.pType = pType
        #for determing if the call is recursive or circular
        self.history = [self.parentName]
        self.circular = False
        #for adding Calls to the functionCalls list
        self.used = False
        #if the call is a main function (not called by any other function) -> first to be printed
        self.independent = ind

    def setUsed(self, used):
        self.used = used

    def setHistory(self, history):
        if self.independent == False:
            if self.history != history:
                self.history = history+self.history
            self.setCircular()

    def setCircular(self):
        count = 0
        for h in self.history:
            if h == self.parentName:
                count += 1
        if count > 1: #if there is more than one of the current program, the program is being called again -> circular
            self.circular = True

#------------------------------------------------------------------------#

#---------------------------Program Class--------------------------------#

#Program is a program in the system
class Program:
    def __init__(self, t, name):
        self.name = name
        self.getPath()
        self.root = True
        self.pType = t #1 for c/c++, 2 for python, 3 for javascript
        self.includes = [] #copy of the csv to analyze

    def getPath(self):
        p = self.name.split("/")
        p.pop()
        self.path = "/".join(p)+"/"

    #copies the information from the csv file to this array for the entire program
    def setIncludes(self, line):
        if line[CSV_INCLUDED_PROGRAM_FIELD] != "":
        	self.includes.append(line[CSV_INCLUDED_PROGRAM_FIELD])

#------------------------------------------------------------------------#

#----------------------------Body Functions------------------------------#

#finds random, unused number (for dot file) and adds it to IDlist
def randNum():
    global IDlist
    i = ""
    while True:
        #this version allows for 100,000,000 function calls
        i = "Node0x"+str(random.randint(100000000, 999999999)) #id assignment
        if IDlist.get(i, None) == None: #check to see if ID is already used
            IDlist[i] = 'taken'
            break
    return i

#determinesdot information and adds a call to programCalls if another program is called from this program
def prepareNode(include):
    #shapeDict = {language_id:shape}
    circularDict = {True: ', style=dashed, peripheries=2', False: ''}

    if "**" in include.name[:ERROR_NODE_NAME]:
        errorNode(include.name[ERROR_NODE_NAME:], include.ID, include.pType)
    else:
        printNode(include.ID, config.shapeDict[include.pType], include.name, circularDict[include.circular])
    if include.independent == False:
        printFlow(include.parentID, include.ID)

def errorNode(name, ID, pType):
    #shapeDict = {language_id:shape}
    printNode(ID, config.shapeDict[pType], "("+name+") Anonymous-Dynamic", ', style=dashed, peripheries=2')

#adds the appropriate ID to the next available call of the appropriate name in programCalls
def addInclude(name, ID, parentName, parentID, progName, pType):
    global functionIncludes
    parentHistory = []
    add = True
    for i in functionIncludes:
        if i.name == parentName and i.ID == parentID:
            parentHistory = i.history
            if i.circular:
                add = False
    if add:
        functionIncludes.append(Include(name, ID, progName, pType, parentName, parentID))
        functionIncludes[LAST_ELEMENT].setHistory(parentHistory)

#initialize functionCalls list with all main functions of independent programs
def setFunctionIncludes():
    global system, functionIncludes
    for program in system:
        if program.name[H_EXT:] == 'h' or program.name[HPP_EXT:] == 'hpp':
            program.root = False
        if program.name[PY_EXT:] == 'py' or program.name[JS_EXT:] == 'js':
            for p in system:
                for i in p.includes:
                    if program.name == p.path+i+'.py' or program.name == p.path+i or program.name == i or program.name == i+'.py':
                        program.root = False

    for program in system:
        if program.root and program.includes:
            functionIncludes.append(Include(program.name, randNum(), program.name, program.pType, '', -1, True))
            functionIncludes[LAST_ELEMENT].setHistory([])

#print the flow information in the dot format
def printFlow(fID, sID):
    global dot
    dot.write(str("\t"+fID+" -> "+sID+";\n"))

#print the node information in the dot format
def printNode(ID, shape, name, extras):
    global dot
    dot.write(str('\t'+ID+' [shape='+shape+extras+', label="'+name+'"];\n'))

def addProgram(t, pName):
    global system
    system.append(Program(t, pName))

def found(includedFile, prog):
    global system
    filename = [includedFile]
    filename.append(prog.path+includedFile)
    filename.append(prog.path+includedFile+'.py')
    if includedFile[:FIRST_ELEMENT] == '.':
        filename.append(prog.path+includedFile[FIRST_ELEMENT:]+'.py')
    for program in system:
        for f in filename:
            if program.name == f:
                return program.name
    return False

#------------------------------------------------------------------------#

#-----------------------------Main Function------------------------------#

def main(includeCsv, title, includeDot):
    global IDlist, system, dot, functionCalls

    try:
        with open(includeCsv, "r") as csvfile:
            reader = csv.reader(csvfile)
            progname = ''
            count = 0
            for i, row in enumerate(reader):
                count += 1
                if progname != row[CSV_MAIN_PROGRAM_FIELD]:
                    progname = row[CSV_MAIN_PROGRAM_FIELD]
                    addProgram(row[CSV_PROGRAM_TYPE_FIELD], progname)
                system[LAST_ELEMENT].setIncludes(row) #add line to Program object's csv array
            if count == 0:
                sys.exit(ERROR+'no function calls found in any programs')
    except IOError:
        sys.exit(ERROR, includeCsv, " does not exist")

    try:
        with open(excludeFile, 'r') as ex:
            templist = ex.read().splitlines()
            for t in templist:
                exclude.append(t)
    except IOError:
        sys.exit(ERROR+excludeFile+" does not exist")

    for program in system:
        temp = []
        for i in program.includes:
            name = found(i, program)
            if name:
                temp.append(name)
            else:
                if i not in exclude:
                    temp.append(i)
        program.includes = set(temp)

    #make array of all programs NOT called by another program
    setFunctionIncludes()
    if len(functionIncludes) == 0:
        sys.exit(ERROR+"no main program in system")

    #make a list of all function calls in the system
    #includeTypeDict = {language_id:id_of_language_usually_included} (for example, in c/c++, h/hpp programs are included)
    while True:
        added = False
        for i in functionIncludes:
            if i.used == False:
                i.setUsed(True)
                for p in system:
                    if p.name == i.name:
                        for ins in p.includes:
                            addInclude(ins, randNum(), i.name, i.ID, i.name, config.includeTypeDict[p.pType])
                            added = True
        if added == False:
            break

    try:
        with open(includeDot, "w") as dot:
            dot.write('digraph "'+title+' Dependency Graph" {\n') #set name for call graph
            dot.write('\tgraph [dpi=300\n') #set dpi to 300
            dot.write('\t\trankdir=LR\n') #make graph vertical
            dot.write('\t\tsize="7.5, 10"\n') #condense size to an 8.5x11 paper
            dot.write('\t\tlabel="'+title+' Dependency Graph"\n') #display name of call graph
            dot.write('\t];\n\n')
            for call in functionIncludes:
                prepareNode(call)
            dot.write("}")
    except IOError:
        sys.exit(ERROR+"problem writing dot file "+cdDot)

    #os.system("rm "+cgCsv)

#main(csvfile, title, dotfile)
